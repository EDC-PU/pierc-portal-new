
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAdmin() {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN_FACULTY';
    }

    function isSuperAdmin() {
      return isAdmin() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    function isPrimarySuperAdminEmail(email) {
      return email == 'pranavrathi07@gmail.com';
    }

    // User is creating their own profile, not assigning super admin, not assigning admin role unless they are the primary super admin.
    function isCreatingOwnValidProfile(data) {
      let isAttemptingPrivilegeEscalation = data.isSuperAdmin == true || data.role == 'ADMIN_FACULTY';
      let isAllowedRoleAssignment = !isAttemptingPrivilegeEscalation || (isAttemptingPrivilegeEscalation && isPrimarySuperAdminEmail(request.auth.token.email));

      let commonChecks = request.auth.uid == data.uid &&
                         data.email == request.auth.token.email &&
                         isAllowedRoleAssignment;

      if (data.isTeamMemberOnly == true) {
        return commonChecks &&
               data.associatedIdeaId != null &&
               data.associatedTeamLeaderUid != null;
      } else { // Idea Owner
        return commonChecks &&
               data.startupTitle != null && data.startupTitle != '' &&
               data.problemDefinition != null && data.problemDefinition != '' &&
               data.solutionDescription != null && data.solutionDescription != '' &&
               data.uniqueness != null && data.uniqueness != '' &&
               data.currentStage != null &&
               data.applicantCategory != null;
      }
    }


    // User is updating their own profile, not changing critical fields
    function isUpdatingOwnValidProfile(newData, oldData) {
      return request.auth.uid == newData.uid &&
             newData.uid == oldData.uid &&
             newData.email == oldData.email &&
             newData.role == oldData.role &&
             newData.isSuperAdmin == oldData.isSuperAdmin &&
             newData.isTeamMemberOnly == oldData.isTeamMemberOnly &&
             newData.associatedIdeaId == oldData.associatedIdeaId &&
             newData.associatedTeamLeaderUid == oldData.associatedTeamLeaderUid &&
             newData.createdAt.toMillis() == oldData.createdAt.toMillis();
    }

    // Idea owner is updating their idea, not changing status, phase, or admin-controlled fields
    function isIdeaOwnerUpdatingValidFields(newData, oldData) {
      let allowedUserModifiableFields = [
        'title', 'category', 'problem', 'solution', 'uniqueness', 'developmentStage',
        'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
        'fileURL', 'fileName', 'studioLocation',
        'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt'
      ];
      let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
      let onlyAllowedFieldsChanged = changedKeys.hasOnly(allowedUserModifiableFields);

      return onlyAllowedFieldsChanged &&
             newData.userId == oldData.userId &&
             newData.status == oldData.status &&
             newData.programPhase == oldData.programPhase &&
             newData.phase2Marks == oldData.phase2Marks &&
             newData.mentor == oldData.mentor &&
             newData.rejectionRemarks == oldData.rejectionRemarks &&
             newData.rejectedByUid == oldData.rejectedByUid &&
             newData.rejectedAt == oldData.rejectedAt &&
             newData.nextPhaseDate == oldData.nextPhaseDate &&
             newData.nextPhaseStartTime == oldData.nextPhaseStartTime &&
             newData.nextPhaseEndTime == oldData.nextPhaseEndTime &&
             newData.nextPhaseVenue == oldData.nextPhaseVenue &&
             newData.nextPhaseGuidelines == oldData.nextPhaseGuidelines &&
             newData.submittedAt.toMillis() == oldData.submittedAt.toMillis();
    }

    // Check if idea submission data is valid during creation by owner
    function isValidIdeaSubmission(data) {
      return data.userId == request.auth.uid &&
             data.title != null && data.title.size() > 0 &&
             data.problem != null && data.problem.size() > 0 &&
             data.solution != null && data.solution.size() > 0 &&
             data.uniqueness != null && data.uniqueness.size() > 0 &&
             data.developmentStage != null &&
             data.status == 'SUBMITTED' &&
             data.programPhase == null &&
             data.teamMemberEmails.size() >= 0 &&
             data.structuredTeamMembers.size() >= 0;
    }

    function isTeamMemberUpdatingOwnDetailsInIdea(request, resource) {
        let writeFields = request.writeFields;
        let onlyAllowedTopLevelKeys = writeFields.hasOnly(['structuredTeamMembers', 'updatedAt']);
        if (!onlyAllowedTopLevelKeys) { return false; }

        let criticalIdeaFieldsUnchanged =
            request.resource.data.userId == resource.data.userId &&
            request.resource.data.status == resource.data.status &&
            request.resource.data.programPhase == resource.data.programPhase &&
            // Team members should not modify the flat teamMemberEmails list directly; it's managed by owner/admin or system
            request.resource.data.teamMemberEmails.toSet().equals(resource.data.teamMemberEmails.toSet());

        if (!criticalIdeaFieldsUnchanged) { return false; }

        if (writeFields.has('structuredTeamMembers')) {
            let newMembersList = request.resource.data.structuredTeamMembers;
            let oldMembersList = resource.data.structuredTeamMembers;

            if (newMembersList.size() != oldMembersList.size()) { return false; } // No adding/removing members

            let modificationsMade = 0;
            let validSelfModification = false;

            for (let i = 0; i < newMembersList.size(); i++) {
                let newMemberEntry = newMembersList[i];
                let oldMemberEntry = oldMembersList[i]; // Assuming order is preserved and is reliable, or find by a persistent key if not.

                // Find the corresponding old member by email (more robust if order isn't guaranteed or if ID changes)
                let oldMemberMatch = oldMembersList.filter(om => om.email == newMemberEntry.email);
                if (oldMemberMatch.size() != 1) { return false; } // Should be exactly one match
                oldMemberEntry = oldMemberMatch[0];


                if (newMemberEntry.email == request.auth.token.email) { // This is the authenticated user's entry
                    // User is setting their ID to their auth.uid for the first time (previously nanoid)
                    // AND other fields are what they've submitted
                    if (newMemberEntry.id == request.auth.uid &&
                        oldMemberEntry.id != request.auth.uid && // old ID was not their UID
                        newMemberEntry.name == request.resource.data.structuredTeamMembers[i].name &&
                        newMemberEntry.phone == request.resource.data.structuredTeamMembers[i].phone &&
                        newMemberEntry.institute == request.resource.data.structuredTeamMembers[i].institute &&
                        newMemberEntry.department == request.resource.data.structuredTeamMembers[i].department &&
                        newMemberEntry.enrollmentNumber == request.resource.data.structuredTeamMembers[i].enrollmentNumber &&
                        newMemberEntry.email == oldMemberEntry.email // Email must not change
                       ) {
                        validSelfModification = true;
                        modificationsMade++;
                    }
                    // User is updating their details (name, phone, etc.), ID and email must match and ID must be their UID
                    else if (newMemberEntry.id == request.auth.uid &&
                             oldMemberEntry.id == request.auth.uid && // Old ID was already their UID
                             newMemberEntry.email == oldMemberEntry.email && // Email must not change
                             // Other fields can change
                             (newMemberEntry.name != oldMemberEntry.name ||
                              newMemberEntry.phone != oldMemberEntry.phone ||
                              newMemberEntry.institute != oldMemberEntry.institute ||
                              newMemberEntry.department != oldMemberEntry.department ||
                              newMemberEntry.enrollmentNumber != oldMemberEntry.enrollmentNumber)
                            ) {
                        validSelfModification = true;
                        modificationsMade++;
                    }
                     else if (newMemberEntry == oldMemberEntry) {
                        // Unchanged entry for self, this is fine if other entries were also unchanged.
                    }
                    else { return false; } // Invalid modification to self
                } else { // This is another team member's entry
                    if (newMemberEntry != oldMemberEntry) { return false; } // Must not change other members' data
                }
            }
            return modificationsMade <= 1 && (modificationsMade == 0 || validSelfModification);
        }
        return true; // Only updatedAt changed, or no change to structuredTeamMembers
    }


    // Users Collection
    match /users/{userId} {
      allow read: if request.auth != null;

      allow create: if request.auth.uid == userId &&
                      isCreatingOwnValidProfile(request.resource.data);

      allow update: if (request.auth.uid == userId &&
                       isUpdatingOwnValidProfile(request.resource.data, resource.data)) ||
                      (isAdmin() && !(isPrimarySuperAdminEmail(resource.data.email) && request.resource.data.isSuperAdmin == false && request.resource.data.role != 'ADMIN_FACULTY')) ;

      allow delete: if isAdmin() && !isPrimarySuperAdminEmail(resource.data.email);
    }

    // Ideas Collection
    match /ideas/{ideaId} {
      allow read: if request.auth != null &&
                    (resource.data.userId == request.auth.uid ||
                     request.auth.token.email in resource.data.teamMemberEmails ||
                     isAdmin());

      allow create: if request.auth.uid == request.resource.data.userId &&
                     isValidIdeaSubmission(request.resource.data);

      allow update: if isAdmin() ||
                     (request.auth.uid == resource.data.userId &&
                      isIdeaOwnerUpdatingValidFields(request.resource.data, resource.data)) ||
                     (request.auth.token.email in resource.data.teamMemberEmails &&
                      isTeamMemberUpdatingOwnDetailsInIdea(request, resource));


      allow delete: if isAdmin() || request.auth.uid == resource.data.userId;
    }

    // Announcements Collection
    match /announcements/{announcementId} {
      allow read: if request.auth != null;
      allow list: if request.auth != null;
      allow create, update, delete: if isAdmin();
    }

    // Cohorts Collection (Future Use)
    match /cohorts/{cohortId} {
      allow read: if request.auth != null;
      allow create, update, delete: if isAdmin();
    }

    // System Settings Document
    match /systemSettings/config {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Activity Logs Collection
    match /activityLogs/{logId} {
      allow read: if isAdmin();
      allow list: if isAdmin();
      allow create: if request.auth != null &&
                       request.resource.data.actorUid == request.auth.uid &&
                       request.resource.data.timestamp == request.time; // Ensure actor is self and timestamp is server-set
    }
  }
}
