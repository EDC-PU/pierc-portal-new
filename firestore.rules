
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN_FACULTY';
    }

    function isSuperAdmin() {
      return isAdmin() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    function isTeamMemberOnly(userId) {
      return request.auth != null && get(/databases/$(database)/documents/users/$(userId)).data.isTeamMemberOnly == true;
    }

    function isIdeaOwner(userId) {
      return request.auth != null &&
             get(/databases/$(database)/documents/users/$(userId)).data.isTeamMemberOnly == false &&
             get(/databases/$(database)/documents/users/$(userId)).data.role != 'ADMIN_FACULTY';
    }

    function isExistingUserProfile(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }

    function incomingUserProfileData() {
      return request.resource.data;
    }

    function existingUserProfileData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    // Users Collection
    match /users/{userId} {
      allow read: if request.auth != null && (isOwner(userId) || isAdmin());
      allow create: if request.auth != null && isOwner(userId) &&
                       incomingUserProfileData().uid == userId &&
                       incomingUserProfileData().email == request.auth.token.email &&
                       ( (incomingUserProfileData().role == 'ADMIN_FACULTY' && (request.auth.token.email == 'pranavrathi07@gmail.com' || MENTOR_EMAILS.has(request.auth.token.email))) ||
                         (incomingUserProfileData().role == 'STUDENT' || incomingUserProfileData().role == 'EXTERNAL_USER') ) &&
                       incomingUserProfileData().createdAt == request.time &&
                       incomingUserProfileData().updatedAt == request.time;

      allow update: if request.auth != null && (isOwner(userId) || isAdmin()) {
        let isUpdatingOwnProfile = isOwner(userId);
        let isUpdatingByAdmin = isAdmin() && !isOwner(userId);
        let existingData = existingUserProfileData(userId);
        let newData = incomingUserProfileData();

        // Fields common to all updates
        let commonAllowedFields = ['fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName', 'photoURL', 'displayName', 'updatedAt'];
        // Fields only idea owners can update for themselves
        let ideaOwnerSelfUpdateFields = ['startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'applicantCategory', 'currentStage'];
        // Fields only admins can update for others (role, isSuperAdmin)
        let adminOnlyUpdateFields = ['role', 'isSuperAdmin'];

        let allowedFields = commonAllowedFields;
        if (isUpdatingOwnProfile && isIdeaOwner(userId)) {
          allowedFields = commonAllowedFields.concat(ideaOwnerSelfUpdateFields);
        } else if (isUpdatingOwnProfile && isTeamMemberOnly(userId)) {
          // Team members can only update common fields
          allowedFields = commonAllowedFields;
        } else if (isUpdatingByAdmin) {
          // Admins can update common fields and role/superAdmin status
          // If the target is an idea owner, admin can also update idea fields for them.
           let targetIsIdeaOwner = !existingData.isTeamMemberOnly && existingData.role != 'ADMIN_FACULTY';
           if (targetIsIdeaOwner) {
                allowedFields = commonAllowedFields.concat(ideaOwnerSelfUpdateFields);
           }
           if (isSuperAdmin()) { // Only SuperAdmins can change role/superAdmin status
                allowedFields = allowedFields.concat(adminOnlyUpdateFields);
           }
        }

        let allChangesAllowed = newData.keys().removeAll(existingData.keys()).hasOnly(allowedFields) &&
                                newData.diff(existingData).affectedKeys().hasOnly(allowedFields);


        // Core checks
        let coreChecks = newData.uid == userId &&
                         newData.email == existingData.email && // Email cannot be changed
                         newData.createdAt == existingData.createdAt && // Creation time cannot be changed
                         newData.updatedAt == request.time;

        // Specific role/superAdmin change checks
        let roleChangeValid = true;
        if (newData.role != existingData.role || newData.isSuperAdmin != existingData.isSuperAdmin) {
          roleChangeValid = isUpdatingByAdmin && isSuperAdmin() &&
                            (existingData.email != 'pranavrathi07@gmail.com' || (newData.role == 'ADMIN_FACULTY' && newData.isSuperAdmin == true)); // Protect primary super admin
        }

        // Idea-related fields nullification for team members or admin accounts without ideas
        let ideaFieldsClearedCorrectly = true;
        let ideaFields = ['startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'applicantCategory', 'currentStage'];
        if (newData.isTeamMemberOnly == true || newData.role == 'ADMIN_FACULTY') {
            // If becoming a team member or admin, these fields should be null or not present
            // Allow if new value is null or if the key is not present in the new data
            ideaFieldsClearedCorrectly = ideaFields.every(field => newData[field] == null || !(field in newData));
        }

        return allChangesAllowed && coreChecks && roleChangeValid && ideaFieldsClearedCorrectly;
      }
      allow delete: if false; // Deletion handled by Cloud Function
    }

    // Ideas Collection
    function isValidIdeaSubmissionStructure(data) {
      return data.userId is string &&
             data.title is string && data.title.size() > 0 &&
             data.problem is string && data.problem.size() > 0 &&
             data.solution is string && data.solution.size() > 0 &&
             data.uniqueness is string && data.uniqueness.size() > 0 &&
             data.developmentStage is string &&
             data.applicantType is string &&
             (data.teamMembers is string || data.teamMembers == null) &&
             (data.fileURL is string || data.fileURL == null) &&
             (data.fileName is string || data.fileName == null) &&
             (data.studioLocation is string || data.studioLocation == null) &&
             data.status is string && (data.status == 'SUBMITTED' || data.status == 'UNDER_REVIEW' || data.status == 'IN_EVALUATION' || data.status == 'SELECTED' || data.status == 'NOT_SELECTED' || data.status == 'ARCHIVED_BY_ADMIN') &&
             (data.programPhase is string || data.programPhase == null) &&
             (data.phase2Marks is map || data.phase2Marks == null) &&
             (data.mentor is string || data.mentor == null) &&
             (data.cohortId is string || data.cohortId == null) &&
             (data.rejectionRemarks is string || data.rejectionRemarks == null) &&
             (data.rejectedByUid is string || data.rejectedByUid == null) &&
             (data.rejectedAt is timestamp || data.rejectedAt == null) &&
             (data.phase2PptUrl is string || data.phase2PptUrl == null) &&
             (data.phase2PptFileName is string || data.phase2PptFileName == null) &&
             (data.phase2PptUploadedAt is timestamp || data.phase2PptUploadedAt == null) &&
             (data.isOutlineAIGenerated is bool) &&
             (data.nextPhaseDate is timestamp || data.nextPhaseDate == null) &&
             (data.nextPhaseStartTime is string || data.nextPhaseStartTime == null) &&
             (data.nextPhaseEndTime is string || data.nextPhaseEndTime == null) &&
             (data.nextPhaseVenue is string || data.nextPhaseVenue == null) &&
             (data.nextPhaseGuidelines is string || data.nextPhaseGuidelines == null) &&
             (data.fundingSource is string || data.fundingSource == null) && // Added
             (data.totalFundingAllocated is number || data.totalFundingAllocated == null) &&
             (data.sanction1Amount is number || data.sanction1Amount == null) &&
             (data.sanction2Amount is number || data.sanction2Amount == null) &&
             (data.sanction1DisbursedAt is timestamp || data.sanction1DisbursedAt == null) &&
             (data.sanction2DisbursedAt is timestamp || data.sanction2DisbursedAt == null) &&
             (data.sanction1Expenses is list) && (data.sanction2Expenses is list) &&
             (data.beneficiaryName is string || data.beneficiaryName == null) &&
             (data.beneficiaryAccountNo is string || data.beneficiaryAccountNo == null) &&
             (data.beneficiaryBankName is string || data.beneficiaryBankName == null) &&
             (data.beneficiaryIfscCode is string || data.beneficiaryIfscCode == null) &&
             (data.beneficiaryAccountType is string || data.beneficiaryAccountType == null) &&
             (data.beneficiaryCity is string || data.beneficiaryCity == null) &&
             (data.beneficiaryBranchName is string || data.beneficiaryBranchName == null) &&
             (data.sanction1AppliedForNext is bool) &&
             (data.sanction1UtilizationStatus is string || data.sanction1UtilizationStatus == null) &&
             (data.sanction1UtilizationRemarks is string || data.sanction1UtilizationRemarks == null) &&
             (data.sanction1UtilizationReviewedBy is string || data.sanction1UtilizationReviewedBy == null) &&
             (data.sanction1UtilizationReviewedAt is timestamp || data.sanction1UtilizationReviewedAt == null) &&
             (data.sanction2UtilizationStatus is string || data.sanction2UtilizationStatus == null) &&
             (data.sanction2UtilizationRemarks is string || data.sanction2UtilizationRemarks == null) &&
             (data.sanction2UtilizationReviewedBy is string || data.sanction2UtilizationReviewedBy == null) &&
             (data.sanction2UtilizationReviewedAt is timestamp || data.sanction2UtilizationReviewedAt == null);
    }

    function isValidInitialTimestamps(data) {
      return data.createdAt == request.time &&
             data.submittedAt == request.time &&
             data.updatedAt == request.time;
    }

    function isValidResubmitTimestamps(data, oldData) {
      return data.createdAt == oldData.createdAt && // Original creation time must be preserved
             data.submittedAt == oldData.submittedAt && // Original submission time must be preserved
             data.updatedAt == request.time;
    }

    function isValidInitialOrResubmittedIdeaState(data, oldData) {
      // oldData will be null for a create operation, non-null for an update
      let isCreate = oldData == null;
      let isUpdateFromArchived = !isCreate && oldData.status == 'ARCHIVED_BY_ADMIN';

      return data.status == 'SUBMITTED' &&
             data.programPhase == null &&
             (data.phase2Marks == {} || data.phase2Marks == null) &&
             (isCreate ? isValidInitialTimestamps(data) : isValidResubmitTimestamps(data, oldData));
    }

    function isIdeaUpdateSafe(newData, oldData) {
      let unchangedCoreFields = newData.userId == oldData.userId &&
                               newData.title == oldData.title &&
                               newData.problem == oldData.problem &&
                               newData.solution == oldData.solution &&
                               newData.uniqueness == oldData.uniqueness &&
                               newData.developmentStage == oldData.developmentStage &&
                               newData.applicantType == oldData.applicantType &&
                               newData.submittedAt == oldData.submittedAt &&
                               newData.createdAt == oldData.createdAt;

      let allowedUserUpdatableFields = ['fileURL', 'fileName', 'studioLocation', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails', 'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'isOutlineAIGenerated', 'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName', 'sanction1Expenses', 'sanction2Expenses', 'sanction1AppliedForNext'];
      let allowedAdminUpdatableFields = ['status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', 'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', 'fundingSource', 'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount', 'sanction1DisbursedAt', 'sanction2DisbursedAt', 'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt', 'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt'];

      let userAllowedChanges = newData.diff(oldData).affectedKeys().hasOnly(allowedUserUpdatableFields.concat(['updatedAt']));
      let adminAllowedChanges = newData.diff(oldData).affectedKeys().hasOnly(allowedUserUpdatableFields.concat(allowedAdminUpdatableFields).concat(['updatedAt']));

      // If user is updating, ensure only user-allowed fields are changed
      let userUpdateValid = isOwner(oldData.userId) && userAllowedChanges;

      // If admin is updating, ensure only admin-allowed fields (which includes user-allowed fields) are changed
      let adminUpdateValid = isAdmin() && adminAllowedChanges;

      // If user is resubmitting an archived idea (by saving their profile)
      let resubmitFromArchiveValid = isOwner(oldData.userId) &&
                                     oldData.status == 'ARCHIVED_BY_ADMIN' &&
                                     isValidInitialOrResubmittedIdeaState(newData, oldData) && // Ensures status becomes SUBMITTED, phase resets etc.
                                     newData.userId == oldData.userId && // User ID must remain the same
                                     newData.createdAt == oldData.createdAt && // createdAt must remain the same
                                     newData.submittedAt == oldData.submittedAt; // submittedAt must remain the same

      return (userUpdateValid || adminUpdateValid || resubmitFromArchiveValid) &&
             newData.updatedAt == request.time;
    }

    function isUpdatingOnlyAllowedBeneficiaryFields(newData, oldData) {
      let allowedFieldsToChange = ['beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName', 'updatedAt'];
      return newData.keys().removeAll(oldData.keys()).hasOnly(allowedFieldsToChange) &&
             newData.diff(oldData).affectedKeys().hasOnly(allowedFieldsToChange);
    }


    match /ideas/{ideaId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null &&
                       isOwner(request.resource.data.userId) &&
                       isValidIdeaSubmissionStructure(request.resource.data) &&
                       isValidInitialOrResubmittedIdeaState(request.resource.data, null); // null for oldData in create
      allow update: if request.auth != null &&
                       isValidIdeaSubmissionStructure(request.resource.data) &&
                       isIdeaUpdateSafe(request.resource.data, resource.data) &&
                       (isOwner(resource.data.userId) || isAdmin());
      allow delete: if false; // Deletions managed by admin functions or specific rules if needed
    }

    // Cohorts Collection
    function isValidCohortStructure(data) {
      return data.name is string && data.name.size() > 0 &&
             data.startDate is timestamp &&
             data.endDate is timestamp && data.endDate > data.startDate &&
             data.batchSize is number && data.batchSize > 0 &&
             data.ideaIds is list &&
             (data.schedule is list || data.schedule == null) && // schedule can be null or list
             data.createdByUid is string &&
             (data.creatorDisplayName is string || data.creatorDisplayName == null);
    }

    match /cohorts/{cohortId} {
      allow read: if request.auth != null;
      allow create: if isAdmin() &&
                       isValidCohortStructure(request.resource.data) &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;
      allow update: if isAdmin() &&
                       isValidCohortStructure(request.resource.data) &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.updatedAt == request.time;
      allow delete: if isAdmin() && resource.data.ideaIds.size() == 0;
    }

    // Announcements Collection
    function isValidAnnouncementStructure(data) {
      return data.title is string && data.title.size() > 0 &&
             data.content is string && data.content.size() > 0 &&
             data.isUrgent is bool &&
             data.targetAudience is string && (data.targetAudience == 'ALL' || data.targetAudience == 'SPECIFIC_COHORT') &&
             (data.cohortId is string || data.cohortId == null) && // cohortId can be string or null
             data.createdByUid is string &&
             (data.creatorDisplayName is string || data.creatorDisplayName == null);
    }

    match /announcements/{announcementId} {
      allow read: if request.auth != null; // All authenticated users can read announcements
      allow create: if isAdmin() &&
                       isValidAnnouncementStructure(request.resource.data) &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       (request.resource.data.targetAudience == 'ALL' || (request.resource.data.targetAudience == 'SPECIFIC_COHORT' && request.resource.data.cohortId is string));
      allow update: if isAdmin() &&
                       isValidAnnouncementStructure(request.resource.data) &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.updatedAt == request.time &&
                       (request.resource.data.targetAudience == 'ALL' || (request.resource.data.targetAudience == 'SPECIFIC_COHORT' && request.resource.data.cohortId is string));
      allow delete: if isAdmin();
    }

    // System Settings Collection
    function isValidSystemSettingsStructure(data) {
      return data.portalName is string && data.portalName.size() > 0 &&
             data.maintenanceMode is bool &&
             data.allowNewRegistrations is bool &&
             data.defaultCohortSize is number && data.defaultCohortSize > 0 &&
             (data.updatedByUid is string || data.updatedByUid == null);
    }
    match /systemSettings/config {
      allow read: if true; // All can read system settings
      allow write: if isAdmin() &&
                      isValidSystemSettingsStructure(request.resource.data) &&
                      request.resource.data.updatedAt == request.time &&
                      request.resource.data.updatedByUid == request.auth.uid;
    }

    // Activity Logs Collection
    function isValidActivityLogStructure(data) {
        return data.timestamp is timestamp &&
               data.actorUid is string &&
               (data.actorDisplayName is string || data.actorDisplayName == null) &&
               data.action is string &&
               (data.target is map || data.target == null) &&
               (data.details is map || data.details == null);
    }
    match /activityLogs/{logId} {
      allow read: if isAdmin();
      allow create: if request.auth != null && // Any authenticated user or system can create logs
                       isValidActivityLogStructure(request.resource.data) &&
                       request.resource.data.timestamp == request.time &&
                       request.resource.data.actorUid == request.auth.uid; // Ensure actor is the one making the request
      allow update, delete: if false; // Logs are immutable
    }
  }
}
    