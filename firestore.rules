
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Global Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    function isUserProfileAdmin() {
      return isSignedIn() && getRole() == 'ADMIN_FACULTY';
    }

    function isUserProfileSuperAdmin() {
      return isSignedIn() && isUserProfileAdmin() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    function isEmailVerified() {
      return isSignedIn() && request.auth.token.email_verified;
    }

    function getMentorEmails() {
      // This list MUST be kept in sync with MENTOR_EMAILS in src/contexts/AuthContext.tsx
      return [
        'prashant.khanna8747@paruluniversity.ac.in',
        'riddhi.bagha29080@paruluniversity.ac.in',
        'nikhil.jumade24167@paruluniversity.ac.in',
        'jay.sudani@paruluniversity.ac.in',
        'hardik.kharva2899@paruluniversity.ac.in',
        'sonal.sudani23321@paruluniversity.ac.in',
        'panchamkumar.baraiya28771@paruluniversity.ac.in',
        'juned.shaikh32161@paruluniversity.ac.in'
      ];
    }

    function isMentorEmail(email) {
      return email in getMentorEmails();
    }

    function isSuperAdminEmail(email) {
      return email == 'pranavrathi07@gmail.com';
    }

    // User Profile Placeholders (Exact match needed with client-side defaults)
    // These are used by `isMentorAccountPlaceholder` and `isSuperAdminAccountPlaceholder`
    // IMPORTANT: If these strings change in `profile-setup/page.tsx`, they MUST be updated here too.
    // Mentor Placeholders
    let MENTOR_TITLE_PLACEHOLDER = 'Faculty/Mentor Account';
    let MENTOR_PROBLEM_DEF_PLACEHOLDER = 'Manages portal functions and/or mentorship.';
    let MENTOR_SOLUTION_DESC_PLACEHOLDER = 'Provides administrative or mentorship support.';
    let MENTOR_UNIQUENESS_PLACEHOLDER = 'Unique administrative/mentorship role.';
    let MENTOR_APPLICANT_CATEGORY_PLACEHOLDER = 'PARUL_STAFF';
    let MENTOR_CURRENT_STAGE_PLACEHOLDER = 'STARTUP_STAGE';

    // Super Admin Placeholders
    let SUPER_ADMIN_TITLE_PLACEHOLDER = 'Administrative Account';
    let SUPER_ADMIN_PROBLEM_DEF_PLACEHOLDER = 'Handles portal administration.'; // Adjusted to be distinct
    let SUPER_ADMIN_SOLUTION_DESC_PLACEHOLDER = 'Provides administrative functions and support.'; // Adjusted
    let SUPER_ADMIN_UNIQUENESS_PLACEHOLDER = 'Unique administrative role for system management.'; // Adjusted
    let SUPER_ADMIN_APPLICANT_CATEGORY_PLACEHOLDER = 'PARUL_STAFF';
    let SUPER_ADMIN_CURRENT_STAGE_PLACEHOLDER = 'STARTUP_STAGE';


    function isValidString(str, min, max) {
      return str is string && str.size() >= min && str.size() <= max;
    }
    function isValidOptionalString(str, max) {
      return str == null || (str is string && str.size() <= max);
    }
    function isValidOptionalStringOrMinMax(str, min, max) {
      return str == null || (str is string && str.size() >= min && str.size() <= max);
    }
    function isValidRole(role) {
      return role == 'STUDENT' || role == 'EXTERNAL_USER' || role == 'ADMIN_FACULTY';
    }
    function isValidApplicantCategory(category) {
      return category == 'PARUL_STUDENT' || category == 'PARUL_STAFF' || category == 'PARUL_ALUMNI' || category == 'OTHERS';
    }
    function isValidCurrentStage(stage) {
      return stage == 'IDEA' || stage == 'PROTOTYPE_STAGE' || stage == 'STARTUP_STAGE';
    }
    function isValidTeamMembersString(teamMembers) {
      return teamMembers == null || (teamMembers is string && teamMembers.size() <= 500);
    }

    function hasRequiredPersonalFields(data) {
      return isValidString(data.fullName, 3, 100) &&
             isValidString(data.contactNumber, 10, 15);
    }

    function hasValidOptionalAcademicFields(data, applicantCategory, email) {
      let isParulStudentContext = applicantCategory == 'PARUL_STUDENT' || (email != null && email.matches('.*@paruluniversity\\.ac\\.in$'));
      let enrollmentOk = true;
      let collegeOk = true;

      if (isParulStudentContext && data.applicantCategory == 'PARUL_STUDENT') { // Stricter for student idea owners
          enrollmentOk = isValidString(data.enrollmentNumber, 1, 50);
          collegeOk = isValidString(data.college, 1, 100);
      } else {
          enrollmentOk = isValidOptionalString(data.enrollmentNumber, 50);
          collegeOk = isValidOptionalString(data.college, 100);
      }
      return enrollmentOk &&
             collegeOk &&
             isValidOptionalString(data.instituteName, 100);
    }

    // Validates if the idea fields are present and correctly formatted for an idea owner.
    function isValidIdeaOwnerFields(data) {
      return isValidString(data.startupTitle, 5, 200) &&
             isValidString(data.problemDefinition, 10, 2000) &&
             isValidString(data.solutionDescription, 10, 2000) &&
             isValidString(data.uniqueness, 10, 2000) &&
             isValidApplicantCategory(data.applicantCategory) &&
             isValidCurrentStage(data.currentStage) &&
             isValidTeamMembersString(data.teamMembers);
    }

    // Validates if the idea fields match the specific placeholder values for a Mentor account.
    function isMentorAccountPlaceholder(data) {
      return data.startupTitle == MENTOR_TITLE_PLACEHOLDER &&
             data.problemDefinition == MENTOR_PROBLEM_DEF_PLACEHOLDER &&
             data.solutionDescription == MENTOR_SOLUTION_DESC_PLACEHOLDER &&
             data.uniqueness == MENTOR_UNIQUENESS_PLACEHOLDER &&
             data.applicantCategory == MENTOR_APPLICANT_CATEGORY_PLACEHOLDER &&
             data.currentStage == MENTOR_CURRENT_STAGE_PLACEHOLDER &&
             isValidTeamMembersString(data.teamMembers); // teamMembers can be empty or null
    }

    // Validates if the idea fields match the specific placeholder values for the Super Admin account.
    function isSuperAdminAccountPlaceholder(data) {
      return data.startupTitle == SUPER_ADMIN_TITLE_PLACEHOLDER &&
             data.problemDefinition == SUPER_ADMIN_PROBLEM_DEF_PLACEHOLDER &&
             data.solutionDescription == SUPER_ADMIN_SOLUTION_DESC_PLACEHOLDER &&
             data.uniqueness == SUPER_ADMIN_UNIQUENESS_PLACEHOLDER &&
             data.applicantCategory == SUPER_ADMIN_APPLICANT_CATEGORY_PLACEHOLDER &&
             data.currentStage == SUPER_ADMIN_CURRENT_STAGE_PLACEHOLDER &&
             isValidTeamMembersString(data.teamMembers);
    }


    // This function defines what constitutes valid user profile data WHEN IT'S BEING CREATED.
    function isValidUserProfileDataOnCreate(userId, data) {
      let email = request.auth.token.email; // Email from the auth token
      let isCreatingOwn = isOwner(userId);
      let roleOk = isValidRole(data.role);
      let personalFieldsOk = hasRequiredPersonalFields(data);
      let academicFieldsOk = hasValidOptionalAcademicFields(data, data.applicantCategory, email);
      let commonFieldsPresent = data.keys().hasAll([
                                'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin',
                                'fullName', 'contactNumber',
                                'createdAt', 'updatedAt', 'isTeamMemberOnly'
                              ]);
      let timestampsOk = data.createdAt == request.time && data.updatedAt == request.time;
      let coreDataMatch = data.uid == userId && data.email == email;

      // Super Admin specific creation logic
      if (isSuperAdminEmail(email)) {
        return isCreatingOwn &&
               coreDataMatch &&
               data.role == 'ADMIN_FACULTY' &&
               data.isSuperAdmin == true &&
               data.isTeamMemberOnly == false && // Super admin cannot be team member only
               personalFieldsOk &&
               academicFieldsOk && // Super admin can have academic fields, or they can be null
               (isSuperAdminAccountPlaceholder(data) || isValidIdeaOwnerFields(data)) && // Can be placeholder or a real idea
               timestampsOk &&
               commonFieldsPresent &&
               data.keys().hasOnly([ // Ensure only these fields are present
                  'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'isTeamMemberOnly',
                  'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                  'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                  'applicantCategory', 'currentStage', 'teamMembers',
                  'associatedIdeaId', 'associatedTeamLeaderUid', // Must be null for SA
                  'createdAt', 'updatedAt'
               ]) &&
               data.associatedIdeaId == null && data.associatedTeamLeaderUid == null;
      }
      // Mentor specific creation logic
      else if (isMentorEmail(email)) {
        return isCreatingOwn &&
               coreDataMatch &&
               data.role == 'ADMIN_FACULTY' &&
               data.isSuperAdmin == false && // Mentors are not super admins by default
               data.isTeamMemberOnly == false && // Mentors are not team members only
               personalFieldsOk &&
               academicFieldsOk && // Mentors can have academic fields
               (isMentorAccountPlaceholder(data) || isValidIdeaOwnerFields(data)) && // Can be placeholder or real idea
               timestampsOk &&
               commonFieldsPresent &&
               data.keys().hasOnly([
                  'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'isTeamMemberOnly',
                  'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                  'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                  'applicantCategory', 'currentStage', 'teamMembers',
                  'associatedIdeaId', 'associatedTeamLeaderUid', // Must be null for Mentors
                  'createdAt', 'updatedAt'
               ]) &&
               data.associatedIdeaId == null && data.associatedTeamLeaderUid == null;
      }
      // Team member specific creation logic
      else if (data.isTeamMemberOnly == true) {
        return isCreatingOwn &&
               coreDataMatch &&
               roleOk && // Role can be STUDENT or EXTERNAL_USER
               data.isSuperAdmin == false &&
               personalFieldsOk &&
               academicFieldsOk &&
               data.startupTitle == null && data.problemDefinition == null && // No idea details for team members
               data.solutionDescription == null && data.uniqueness == null &&
               data.applicantCategory == null && data.currentStage == null &&
               data.teamMembers == null && // teamMembers string is for idea owners only
               data.associatedIdeaId is string && data.associatedTeamLeaderUid is string && // Must have association
               timestampsOk &&
               commonFieldsPresent &&
               data.keys().hasOnly([
                  'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'isTeamMemberOnly',
                  'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                  'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                  'applicantCategory', 'currentStage', 'teamMembers',
                  'associatedIdeaId', 'associatedTeamLeaderUid',
                  'createdAt', 'updatedAt'
               ]);
      }
      // Regular idea owner creation logic
      else {
        return isCreatingOwn &&
               coreDataMatch &&
               roleOk && // Role can be STUDENT or EXTERNAL_USER
               data.isSuperAdmin == false &&
               data.isTeamMemberOnly == false &&
               personalFieldsOk &&
               academicFieldsOk &&
               isValidIdeaOwnerFields(data) && // Must have valid idea fields
               data.associatedIdeaId == null && data.associatedTeamLeaderUid == null && // No association for idea owners
               timestampsOk &&
               commonFieldsPresent &&
               data.keys().hasOnly([
                  'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'isTeamMemberOnly',
                  'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                  'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                  'applicantCategory', 'currentStage', 'teamMembers',
                  'associatedIdeaId', 'associatedTeamLeaderUid',
                  'createdAt', 'updatedAt'
               ]);
      }
    }

    // Validates profile data on update.
    function isValidUserProfileDataOnUpdate(userId, existingData, newData) {
      let isOwnUpdate = isOwner(userId);
      let personalFieldsOk = hasRequiredPersonalFields(newData);
      let academicFieldsOk = hasValidOptionalAcademicFields(newData, newData.applicantCategory, newData.email); // Use new email for context
      let commonImmutableFieldsOk = newData.uid == existingData.uid &&
                                    newData.email == existingData.email && // Email cannot be changed by user
                                    newData.role == existingData.role && // Role cannot be changed by user directly
                                    newData.isSuperAdmin == existingData.isSuperAdmin && // SA status not by user
                                    newData.isTeamMemberOnly == existingData.isTeamMemberOnly &&
                                    newData.createdAt == existingData.createdAt; // createdAt is immutable
      let timestampsOk = newData.updatedAt == request.time;

      // Super Admin specific update logic (can only be updated by self or another super admin)
      if (isSuperAdminEmail(existingData.email)) {
          // If owner is the super admin, they can update their personal/academic and idea fields.
          // Role, isSuperAdmin, isTeamMemberOnly cannot be changed by self.
          return isOwnUpdate &&
                 commonImmutableFieldsOk &&
                 personalFieldsOk &&
                 academicFieldsOk &&
                 (isSuperAdminAccountPlaceholder(newData) || isValidIdeaOwnerFields(newData)) &&
                 timestampsOk &&
                 newData.keys().hasOnly(existingData.keys()); // No new fields allowed
      }
      // Mentor specific update logic
      else if (isMentorEmail(existingData.email)) {
        let isExistingMentorPlaceholder = existingData.startupTitle == MENTOR_TITLE_PLACEHOLDER;
        let ideaLogicOk = false;
        if (isExistingMentorPlaceholder) {
          // If it was a placeholder, it can remain placeholder (only personal/academic changed) OR become a full idea
          ideaLogicOk = isMentorAccountPlaceholder(newData) || isValidIdeaOwnerFields(newData);
        } else {
          // If it was a full idea, it must remain a full idea
          ideaLogicOk = isValidIdeaOwnerFields(newData);
        }
        return isOwnUpdate &&
               commonImmutableFieldsOk &&
               personalFieldsOk &&
               academicFieldsOk &&
               ideaLogicOk &&
               timestampsOk &&
               newData.keys().hasOnly(existingData.keys());
      }
      // Team member specific update logic
      else if (existingData.isTeamMemberOnly == true) {
        return isOwnUpdate &&
               commonImmutableFieldsOk &&
               personalFieldsOk &&
               academicFieldsOk &&
               newData.startupTitle == null && newData.problemDefinition == null && // Still no idea details
               newData.solutionDescription == null && newData.uniqueness == null &&
               newData.applicantCategory == null && newData.currentStage == null &&
               newData.teamMembers == null &&
               newData.associatedIdeaId == existingData.associatedIdeaId && // Associations cannot change
               newData.associatedTeamLeaderUid == existingData.associatedTeamLeaderUid &&
               timestampsOk &&
               newData.keys().hasOnly(existingData.keys());
      }
      // Regular idea owner update logic
      else {
        return isOwnUpdate &&
               commonImmutableFieldsOk &&
               personalFieldsOk &&
               academicFieldsOk &&
               isValidIdeaOwnerFields(newData) && // Must remain valid idea owner
               newData.associatedIdeaId == null && newData.associatedTeamLeaderUid == null &&
               timestampsOk &&
               newData.keys().hasOnly(existingData.keys());
      }
    }

    // Rules for /users/{userId}
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isValidUserProfileDataOnCreate(userId, request.resource.data);
      allow update: if isSignedIn() && (
                      // Owner updating their own profile
                      (isOwner(userId) && isValidUserProfileDataOnUpdate(userId, resource.data, request.resource.data)) ||
                      // Super Admin updating any user's role/superAdmin status
                      (isUserProfileSuperAdmin() &&
                       request.resource.data.uid == resource.data.uid && // Cannot change UID
                       request.resource.data.email == resource.data.email && // Cannot change email
                       (request.resource.data.role != resource.data.role || request.resource.data.isSuperAdmin != resource.data.isSuperAdmin) && // Role or SA status must be changing
                       (isSuperAdminEmail(resource.data.email) ? (request.resource.data.role == 'ADMIN_FACULTY' && request.resource.data.isSuperAdmin == true) : true) && // Cannot demote the main SA
                       request.resource.data.updatedAt == request.time &&
                       request.writeFields.hasAny(['role', 'isSuperAdmin', 'updatedAt'])) || // Only these fields allowed for this type of admin update
                      // Admin updating limited fields on any user's profile (e.g. from Manage Users page)
                      (isUserProfileAdmin() && request.auth.uid != userId && // Admin is not the user themselves
                        request.resource.data.uid == resource.data.uid &&
                        request.resource.data.email == resource.data.email &&
                        request.resource.data.role == resource.data.role && // Admin cannot change role through this path, use specific role update
                        request.resource.data.isSuperAdmin == resource.data.isSuperAdmin && // Admin cannot change SA status here
                        request.resource.data.isTeamMemberOnly == resource.data.isTeamMemberOnly &&
                        request.resource.data.createdAt == resource.data.createdAt &&
                        request.resource.data.updatedAt == request.time &&
                        hasRequiredPersonalFields(request.resource.data) && // Ensure base personal fields are valid
                        // Check other fields remain consistent or are validly updated as per their type
                        hasValidOptionalAcademicFields(request.resource.data, request.resource.data.applicantCategory, request.resource.data.email) &&
                        (request.resource.data.isTeamMemberOnly == true || isValidIdeaOwnerFields(request.resource.data) || isMentorAccountPlaceholder(request.resource.data) || isSuperAdminAccountPlaceholder(request.resource.data)) &&
                        request.writeFields.hasOnly([ // Admin can only update these specific fields on other users
                          'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                          'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                          'applicantCategory', 'currentStage', 'teamMembers', 'updatedAt'
                        ])
                      )
                    );
      allow delete: if isUserProfileSuperAdmin() && resource.data.email != 'pranavrathi07@gmail.com'; // Only SA can delete, and not the main SA
    }

    // --- Idea Submission Rules ---
    function isValidIdeaContent(data) {
      return isValidString(data.title, 5, 200) &&
             isValidString(data.problem, 10, 2000) &&
             isValidString(data.solution, 10, 2000) &&
             isValidString(data.uniqueness, 10, 2000) &&
             isValidApplicantCategory(data.applicantType) && // applicantType used in idea doc
             isValidCurrentStage(data.developmentStage) && // developmentStage used in idea doc
             isValidOptionalString(data.teamMembers, 500) &&
             (data.studioLocation == null || data.studioLocation in ['SURAT', 'RAJKOT', 'BARODA', 'AHMEDABAD']) &&
             isValidOptionalString(data.fileURL, 1024) && isValidOptionalString(data.fileName, 255) &&
             isValidOptionalString(data.phase2PptUrl, 1024) && isValidOptionalString(data.phase2PptFileName, 255);
    }

    function creatorIsNotUsingAdminPlaceholderForIdea(userId) {
      let userProfile = get(/databases/$(database)/documents/users/$(userId)).data;
      // If the user is an admin/mentor, their profile's startupTitle must not be the placeholder if they are creating a *distinct* idea.
      // If they are a regular student/external, this check is effectively true.
      return !(userProfile.role == 'ADMIN_FACULTY' &&
               (userProfile.startupTitle == MENTOR_TITLE_PLACEHOLDER || userProfile.startupTitle == SUPER_ADMIN_TITLE_PLACEHOLDER));
    }

    function isValidIdeaSubmissionOnCreateOrResubmit(userId, data, isCreate) {
      let userProfile = get(/databases/$(database)/documents/users/$(userId)).data;
      let commonValidations = data.userId == userId &&
                              data.applicantDisplayName == (userProfile.displayName == null ? userProfile.fullName : userProfile.displayName) &&
                              data.applicantEmail == userProfile.email &&
                              isValidIdeaContent(data) &&
                              data.updatedAt == request.time &&
                              // Ensure admin-controlled fields are appropriately null/empty for new/resubmitted ideas
                              data.programPhase == null &&
                              data.cohortId == null &&
                              (data.phase2Marks == null || data.phase2Marks.size() == 0) &&
                              data.mentor == null &&
                              data.rejectionRemarks == null && data.rejectedByUid == null && data.rejectedAt == null &&
                              data.nextPhaseDate == null && data.nextPhaseStartTime == null && data.nextPhaseEndTime == null &&
                              data.nextPhaseVenue == null && data.nextPhaseGuidelines == null &&
                              (data.structuredTeamMembers == null || data.structuredTeamMembers.size() == 0) && // Reset for resubmission
                              (data.teamMemberEmails == null || data.teamMemberEmails.size() == 0); // Reset for resubmission

      if (isCreate) {
        return commonValidations &&
               creatorIsNotUsingAdminPlaceholderForIdea(userId) && // Critical check for admins/mentors
               data.status == 'SUBMITTED' &&
               data.submittedAt == request.time &&
               data.keys().hasOnly([
                 'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category', 'problem', 'solution', 'uniqueness',
                 'developmentStage', 'applicantType', 'teamMembers', 'status', 'programPhase', 'cohortId',
                 'phase2Marks', 'mentor', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                 'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                 'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                 'submittedAt', 'updatedAt', 'fileURL', 'fileName', 'studioLocation',
                 'structuredTeamMembers', 'teamMemberEmails' // Allowed on create (usually empty)
               ]);
      } else { // This is for resubmitting an archived idea
        return commonValidations &&
               data.status == 'SUBMITTED' && // Status must become SUBMITTED
               data.submittedAt == resource.data.submittedAt && // submittedAt is immutable on update
               // Ensure only user-editable idea fields + status + reset admin fields are being written
               request.writeFields.hasAll([
                  'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers',
                  'status', 'programPhase', 'cohortId', 'phase2Marks', 'mentor',
                  'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                  'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                  'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                  'updatedAt', 'structuredTeamMembers', 'teamMemberEmails'
                  // fileURL, fileName, studioLocation might also be updated by user profile save
               ]) &&
               (request.writeFields.has('fileURL') || true) && // Optional update
               (request.writeFields.has('fileName') || true) && // Optional update
               (request.writeFields.has('studioLocation') || true); // Optional update
      }
    }

    // Helper function to validate team member structure
    function isValidTeamMember(member) {
      return member.keys().hasAll(['id', 'name', 'email', 'phone', 'institute', 'department']) &&
             isValidString(member.id, 1, 50) &&
             isValidString(member.name, 1, 100) &&
             isValidString(member.email, 1, 100) && member.email.matches('.+@.+\\..+') &&
             isValidString(member.phone, 10, 15) &&
             isValidString(member.institute, 1, 100) &&
             isValidString(member.department, 1, 100) &&
             isValidOptionalString(member.enrollmentNumber, 50);
    }

    function isValidStructuredTeamMembersArray(membersArray) {
      return membersArray is list &&
             membersArray.size() <= 4 &&
             (membersArray.size() == 0 || membersArray.all(member, isValidTeamMember(member)));
    }


    match /ideas/{ideaId} {
      allow read: if isSignedIn();

      allow create: if isSignedIn() &&
                      isOwner(request.resource.data.userId) &&
                      isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, true);

      allow update: if isSignedIn() && (
                      // Owner resubmitting an archived idea (via profile save)
                      (isOwner(resource.data.userId) &&
                       resource.data.status == 'ARCHIVED_BY_ADMIN' &&
                       request.resource.data.status == 'SUBMITTED' &&
                       isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, false)
                      ) ||
                      // Admin performing general status/phase/mentor/cohort updates
                      (isUserProfileAdmin() &&
                        request.resource.data.userId == resource.data.userId && // Cannot change owner
                        request.resource.data.title == resource.data.title && // Title immutable by admin here
                        request.resource.data.updatedAt == request.time &&
                        // Check that only specific admin-updatable fields are changing
                        (
                          request.writeFields.hasAny([
                            'status', 'programPhase', 'cohortId', 'mentor',
                            'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                            'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                            'updatedAt'
                          ])
                        )
                      ) ||
                      // Admin archiving an idea
                      (isUserProfileAdmin() &&
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.title == resource.data.title &&
                        request.resource.data.status == 'ARCHIVED_BY_ADMIN' && // New status must be ARCHIVED
                        request.resource.data.programPhase == null && // Phase reset
                        (request.resource.data.phase2Marks == null || request.resource.data.phase2Marks.size() == 0) && // Marks reset
                        request.resource.data.mentor == null && // Mentor reset
                        request.resource.data.cohortId == null && // Cohort reset
                        // Ensure only the allowed fields for archiving are being written
                        request.writeFields.hasOnly([
                          'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId',
                          'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                          'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                          'updatedAt'
                        ])
                      ) ||
                      // Admin submitting/updating Phase 2 marks
                      (isUserProfileAdmin() &&
                        resource.data.programPhase == 'PHASE_2' &&
                        request.resource.data.programPhase == 'PHASE_2' && // Phase must remain PHASE_2
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.title == resource.data.title &&
                        request.resource.data.updatedAt == request.time &&
                        request.writeFields.hasAll(['phase2Marks', 'updatedAt']) && // Only marks and timestamp
                        request.writeFields.size() == 2 &&
                        (request.resource.data.phase2Marks[request.auth.uid].mark == null ||
                         (request.resource.data.phase2Marks[request.auth.uid].mark >= 0 &&
                          request.resource.data.phase2Marks[request.auth.uid].mark <= 100)) &&
                        request.resource.data.phase2Marks[request.auth.uid].adminDisplayName is string &&
                        request.resource.data.phase2Marks[request.auth.uid].markedAt == request.time
                      ) ||
                      // Owner updating PPT details
                      (isOwner(resource.data.userId) &&
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.title == resource.data.title && // Title is immutable by user here
                        request.resource.data.updatedAt == request.time &&
                        request.writeFields.hasOnly(['phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt']) &&
                        isValidOptionalString(request.resource.data.phase2PptUrl, 1024) &&
                        isValidOptionalString(request.resource.data.phase2PptFileName, 255) &&
                        (request.resource.data.phase2PptUploadedAt == null || request.resource.data.phase2PptUploadedAt == request.time)
                      ) ||
                      // Owner managing structured team members (add, update, remove)
                      (isOwner(resource.data.userId) &&
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.title == resource.data.title &&
                        request.resource.data.updatedAt == request.time &&
                        (
                          request.writeFields.hasOnly(['structuredTeamMembers', 'teamMemberEmails', 'updatedAt']) ||
                          request.writeFields.hasOnly(['structuredTeamMembers', 'updatedAt']) // If only removing/reordering, emails might not change
                        ) &&
                        isValidStructuredTeamMembersArray(request.resource.data.structuredTeamMembers) &&
                        (request.resource.data.teamMemberEmails is list && request.resource.data.teamMemberEmails.size() <= 4)
                      )
                    );
      allow delete: if false; // Prevent direct deletion, force archive flow

    }

    // Cohort Rules
    function isValidCohortData(data, isCreate) {
      let timestampsOk = isCreate ? (data.createdAt == request.time && data.updatedAt == request.time) : (data.updatedAt == request.time && data.createdAt == resource.data.createdAt);
      return isValidString(data.name, 3, 100) &&
             data.startDate is timestamp && data.endDate is timestamp && data.startDate < data.endDate &&
             data.batchSize is number && data.batchSize >= 1 && data.batchSize <= 200 &&
             data.ideaIds is list && (data.ideaIds.size() == 0 || data.ideaIds.all(id, id is string)) &&
             (data.schedule == null || (data.schedule is list && data.schedule.size() >= 0)) && // Schedule is optional
             data.createdByUid == request.auth.uid &&
             data.creatorDisplayName is string &&
             timestampsOk;
    }

    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isUserProfileAdmin() && isValidCohortData(request.resource.data, true) &&
                      request.resource.data.keys().hasOnly([
                        'name', 'startDate', 'endDate', 'batchSize', 'ideaIds', 'schedule',
                        'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt'
                      ]);
      allow update: if isUserProfileAdmin() &&
                      // Allow updating basic details or schedule or ideaIds by admin
                      (
                        (isValidCohortData(request.resource.data, false) &&
                         request.resource.data.createdByUid == resource.data.createdByUid && // Creator immutable
                         request.resource.data.creatorDisplayName == resource.data.creatorDisplayName && // Creator name immutable
                         // Allow specific fields to be updated by admin who created it or any super admin
                         (isOwner(resource.data.createdByUid) || isUserProfileSuperAdmin()) &&
                         request.writeFields.hasAny(['name', 'startDate', 'endDate', 'batchSize', 'schedule', 'updatedAt'])
                        ) ||
                        // Allow super admin to manage ideaIds in a cohort (add/remove)
                        (isUserProfileSuperAdmin() &&
                         request.resource.data.updatedAt == request.time &&
                         request.writeFields.hasOnly(['ideaIds', 'updatedAt']) && // Only ideaIds and timestamp
                         request.resource.data.ideaIds is list
                        )
                      );
      allow delete: if false; // No direct cohort deletion for now
    }

    // Announcement Rules
    function isValidAnnouncementData(data, isCreate) {
      let timestampsOk = isCreate ? (data.createdAt == request.time && data.updatedAt == request.time) : (data.updatedAt == request.time && data.createdAt == resource.data.createdAt);
      let targetAudienceOk = data.targetAudience == 'ALL' || data.targetAudience == 'SPECIFIC_COHORT';
      let cohortIdOk = (data.targetAudience == 'ALL' && data.cohortId == null) ||
                       (data.targetAudience == 'SPECIFIC_COHORT' && data.cohortId is string);

      return isValidString(data.title, 5, 100) &&
             isValidString(data.content, 10, 5000) &&
             data.isUrgent is bool &&
             targetAudienceOk &&
             cohortIdOk &&
             data.createdByUid == request.auth.uid &&
             data.creatorDisplayName is string &&
             isValidOptionalString(data.attachmentURL, 1024) && isValidOptionalString(data.attachmentName, 255) &&
             timestampsOk;
    }
    match /announcements/{announcementId} {
      allow read: if isSignedIn(); // All signed-in users can read announcements
      allow create: if isUserProfileAdmin() && isValidAnnouncementData(request.resource.data, true) &&
                      request.resource.data.keys().hasOnly([
                        'title', 'content', 'isUrgent', 'targetAudience', 'cohortId',
                        'attachmentURL', 'attachmentName',
                        'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt'
                      ]);
      allow update: if isUserProfileAdmin() && isOwner(resource.data.createdByUid) && // Only creator admin can update
                      isValidAnnouncementData(request.resource.data, false) &&
                      request.resource.data.createdByUid == resource.data.createdByUid && // Creator immutable
                      request.resource.data.creatorDisplayName == resource.data.creatorDisplayName; // Creator name immutable
      allow delete: if isUserProfileAdmin() && isOwner(resource.data.createdByUid); // Only creator admin can delete
    }

    // System Settings Rules
    function isValidSystemSettingsData(data) {
      return isValidString(data.portalName, 3, 50) &&
             data.maintenanceMode is bool &&
             data.allowNewRegistrations is bool &&
             data.defaultCohortSize is number && data.defaultCohortSize >= 1 && data.defaultCohortSize <= 100 &&
             data.updatedAt == request.time &&
             data.updatedByUid == request.auth.uid;
    }
    match /systemSettings/{settingsId} {
      // settingsId will always be 'config'
      allow read: if true; // System settings can be read by anyone (or make it isSignedIn())
      allow write: if isUserProfileSuperAdmin() && // Only Super Admins can change system settings
                     settingsId == 'config' &&
                     isValidSystemSettingsData(request.resource.data) &&
                     request.resource.data.keys().hasOnly([
                       'portalName', 'maintenanceMode', 'allowNewRegistrations', 'defaultCohortSize',
                       'updatedAt', 'updatedByUid'
                     ]);
    }

    // Activity Log Rules
    function isValidActivityLogData(data) {
      return data.timestamp == request.time &&
             data.actorUid == request.auth.uid && // Logged by the authenticated user
             data.actorDisplayName is string &&
             data.action is string &&
             (data.target == null || (
                data.target.type is string && data.target.id is string &&
                (data.target.displayName == null || data.target.displayName is string)
             )) &&
             (data.details == null || data.details is map);
    }
    match /activityLogs/{logId} {
      allow read: if isUserProfileAdmin(); // Only admins can read activity logs
      allow create: if isSignedIn() && isValidActivityLogData(request.resource.data) &&
                      request.resource.data.keys().hasOnly(['timestamp', 'actorUid', 'actorDisplayName', 'action', 'target', 'details']);
      allow update, delete: if false; // Logs are immutable
    }
  }
}

    