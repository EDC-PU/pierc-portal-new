
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isAdmin() {
      let userProfile = getUserData(request.auth.uid);
      return isSignedIn() && userProfile.role == 'ADMIN_FACULTY';
    }

    function isSuperAdmin() {
      let userProfile = getUserData(request.auth.uid);
      return isSignedIn() && userProfile.role == 'ADMIN_FACULTY' && userProfile.isSuperAdmin == true;
    }

    // User Profile Rules
    // Validates the structure of a user profile during creation.
    function isValidUserProfileStructure(data) {
      let commonFields = ['uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'fullName', 'contactNumber', 'createdAt', 'updatedAt'];
      let ideaOwnerFields = ['applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers'];
      let teamMemberFields = ['associatedIdeaId', 'associatedTeamLeaderUid'];
      let optionalAcademicFields = ['enrollmentNumber', 'college', 'instituteName'];

      let allAllowedFields = commonFields;

      // Basic common field checks
      if (!(data.uid is string &&
            data.email is string && // Email must be present
            (data.displayName == null || data.displayName is string) &&
            (data.photoURL == null || data.photoURL is string) &&
            data.role is string && (data.role == 'STUDENT' || data.role == 'EXTERNAL_USER' || data.role == 'ADMIN_FACULTY') &&
            data.isSuperAdmin is bool &&
            data.fullName is string && data.fullName.size() > 0 &&
            data.contactNumber is string && data.contactNumber.size() > 0 &&
            data.createdAt == request.time &&
            data.updatedAt == request.time
      )) {
        return false;
      }

      // Super admin can only be the specific email and must be ADMIN_FACULTY
      if (data.isSuperAdmin == true && !(request.auth.token.email == 'pranavrathi07@gmail.com' && data.role == 'ADMIN_FACULTY')) {
        return false;
      }
      // Only the specific email can set ADMIN_FACULTY role on create
      if (data.role == 'ADMIN_FACULTY' && request.auth.token.email != 'pranavrathi07@gmail.com') {
        return false;
      }


      if (data.isTeamMemberOnly == true) {
        allAllowedFields = allAllowedFields.concat(teamMemberFields).concat(optionalAcademicFields);
        if (!(data.associatedIdeaId is string && data.associatedIdeaId.size() > 0 &&
              data.associatedTeamLeaderUid is string && data.associatedTeamLeaderUid.size() > 0 &&
              data.startupTitle == null && data.problemDefinition == null && data.solutionDescription == null &&
              data.uniqueness == null && data.applicantCategory == null && data.currentStage == null && data.teamMembers == null
        )) {
          return false;
        }
      } else { // isTeamMemberOnly is false or null (idea owner or admin default)
        allAllowedFields = allAllowedFields.concat(ideaOwnerFields).concat(optionalAcademicFields);
         if (!(data.applicantCategory is string &&
              data.currentStage is string &&
              (data.startupTitle is string && data.startupTitle.size() > 0) && // allow admin placeholder
              data.problemDefinition is string &&
              data.solutionDescription is string &&
              data.uniqueness is string &&
              (data.teamMembers == null || data.teamMembers is string) && // Can be empty string or null for admin
              data.associatedIdeaId == null && data.associatedTeamLeaderUid == null
        )) {
          return false;
        }
        // Specific checks for admin's placeholder idea details
        if (data.role == 'ADMIN_FACULTY' && request.auth.token.email == 'pranavrathi07@gmail.com') {
            if (!(data.startupTitle == 'Administrative Account' &&
                  data.problemDefinition == 'Handles portal administration.' &&
                  data.solutionDescription == 'Provides administrative functions and support.' &&
                  data.uniqueness == 'Unique administrative role for system management.' &&
                  data.currentStage == 'STARTUP_STAGE' &&
                  data.applicantCategory == 'PARUL_STAFF' // or appropriate for admin
            )) {
                // Allow flexibility if admin is editing their profile later,
                // but on create, these placeholders are expected if it's the super admin.
                // This rule is for CREATE, so we are stricter.
                // If these aren't met for super admin initial setup, it's an issue.
                 // For now, let's trust the client logic for super admin initial setup.
                 // This check becomes too complex for initial rule.
            }
        }

      }

      // Check optional academic fields are of correct type if present
      if (('enrollmentNumber' in data && !(data.enrollmentNumber == null || data.enrollmentNumber is string)) ||
          ('college' in data && !(data.college == null || data.college is string)) ||
          ('instituteName' in data && !(data.instituteName == null || data.instituteName is string))
      ) {
        return false;
      }
      return data.keys().hasOnly(allAllowedFields);
    }

    function isCreatingOwnValidProfile(userId, incomingData) {
      return isOwner(userId)
             && incomingData.uid == userId // UID in data must match auth
             && incomingData.email == request.auth.token.email // Email in data must match auth
             && isValidUserProfileStructure(incomingData);
    }

    function isUpdatingOwnValidProfile(userId, requestData, resourceData) {
      return isOwner(userId)
             // Immutable fields
             && requestData.uid == resourceData.uid
             && requestData.email == resourceData.email
             && requestData.role == resourceData.role
             && requestData.isSuperAdmin == resourceData.isSuperAdmin
             && requestData.createdAt.toMillis() == resourceData.createdAt.toMillis()
             && requestData.updatedAt == request.time
             // Check updatable fields
             && requestData.fullName is string && requestData.fullName.size() > 0
             && requestData.contactNumber is string && requestData.contactNumber.size() > 0
             && (requestData.photoURL == null || requestData.photoURL is string)
             && (requestData.displayName == null || requestData.displayName is string)
             && (requestData.enrollmentNumber == null || requestData.enrollmentNumber is string)
             && (requestData.college == null || requestData.college is string)
             && (requestData.instituteName == null || requestData.instituteName is string)
             // Idea owner specific fields (can only be updated if not a teamMemberOnly profile)
             && (resourceData.isTeamMemberOnly == true ?
                  (requestData.startupTitle == null && requestData.problemDefinition == null && /*...all idea fields are null*/ true)
                :
                  (requestData.applicantCategory is string &&
                   requestData.currentStage is string &&
                   requestData.startupTitle is string &&
                   requestData.problemDefinition is string &&
                   requestData.solutionDescription is string &&
                   requestData.uniqueness is string &&
                   (requestData.teamMembers == null || requestData.teamMembers is string)
                  )
                )
            // Team association fields should not be changed by user on self-update
            && requestData.isTeamMemberOnly == resourceData.isTeamMemberOnly
            && requestData.associatedIdeaId == resourceData.associatedIdeaId
            && requestData.associatedTeamLeaderUid == resourceData.associatedTeamLeaderUid;
    }

    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isCreatingOwnValidProfile(userId, request.resource.data);
      allow update: if isOwner(userId) && isUpdatingOwnValidProfile(userId, request.resource.data, resource.data);
      allow delete: if isOwner(userId) && request.auth.token.email != 'pranavrathi07@gmail.com'; // Self-delete, not for super admin
    }

    // Admin operations on user profiles
    match /users/{targetUserId} {
        allow update: if isAdmin() && request.resource.data.updatedAt == request.time; // Admins can update user profiles (e.g., roles)
                       // Add more specific field checks for admin updates if needed.
                       // For role/isSuperAdmin changes by admin:
                       // request.resource.data.role is string
                       // request.resource.data.isSuperAdmin is bool
                       // Ensure admin is not demoting/modifying primary super admin
                       // !(resource.data.email == 'pranavrathi07@gmail.com' && (request.resource.data.isSuperAdmin == false || request.resource.data.role != 'ADMIN_FACULTY'))


        allow delete: if isSuperAdmin() && resource.data.email != 'pranavrathi07@gmail.com'; // Super Admins can delete users, not primary SA
    }


    // Idea Submission Rules
    function isValidInitialIdeaStructure(ideaData) {
        // Fields guaranteed to be sent by createIdeaFromProfile
        let requiredFields = [
            'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'problem', 'solution', 'uniqueness',
            'developmentStage', 'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
            'status', 'programPhase', 'submittedAt', 'updatedAt'
        ];
        // Optional fields not sent initially, so they shouldn't be in `hasOnly` unless explicitly checked for absence
        // For idea creation, client sends only the above.

        return ideaData.userId == request.auth.uid
            && ideaData.applicantDisplayName is string
            && ideaData.applicantEmail is string
            && ideaData.title is string && ideaData.title.size() > 0
            && ideaData.problem is string && ideaData.problem.size() > 0
            && ideaData.solution is string && ideaData.solution.size() > 0
            && ideaData.uniqueness is string && ideaData.uniqueness.size() > 0
            && ideaData.developmentStage is string
            && ideaData.applicantType is string
            && (ideaData.teamMembers is string) // Original free text team members
            && ideaData.structuredTeamMembers is list && ideaData.structuredTeamMembers.size() == 0
            && ideaData.teamMemberEmails is list && ideaData.teamMemberEmails.size() == 0
            && ideaData.status == 'SUBMITTED'
            && ideaData.programPhase == null
            && ideaData.submittedAt == request.time
            && ideaData.updatedAt == request.time
            // Ensure fields not sent at creation are not present
            && !('fileURL' in ideaData)
            && !('fileName' in ideaData)
            && !('studioLocation' in ideaData)
            && !('mentor' in ideaData)
            && !('cohortId' in ideaData)
            && !('phase2Marks' in ideaData || (ideaData.phase2Marks is map && ideaData.phase2Marks.size() == 0)) // should not be present at all
            && !('rejectionRemarks' in ideaData)
            && !('rejectedByUid' in ideaData)
            && !('rejectedAt' in ideaData)
            && !('phase2PptUrl' in ideaData)
            && !('phase2PptFileName' in ideaData)
            && !('phase2PptUploadedAt' in ideaData)
            && !('nextPhaseDate' in ideaData)
            && !('nextPhaseStartTime' in ideaData)
            && !('nextPhaseEndTime' in ideaData)
            && !('nextPhaseVenue' in ideaData)
            && !('nextPhaseGuidelines' in ideaData)
            && request.resource.data.keys().hasOnly(requiredFields);
    }

    function isCreatingOwnIdea(userId, ideaData) {
      let userProfile = getUserData(userId);
      return isSignedIn()
             && request.auth.uid == userId
             // User must NOT be 'teamMemberOnly'. Can be explicitly false or null/absent.
             && (userProfile.isTeamMemberOnly == false || userProfile.isTeamMemberOnly == null)
             && isValidInitialIdeaStructure(ideaData);
    }

    function isIdeaOwner(ideaUserId) {
        return isSignedIn() && request.auth.uid == ideaUserId;
    }

    function isIdeaTeamMember(ideaResource) {
        return isSignedIn() && request.auth.token.email in ideaResource.data.teamMemberEmails;
    }

    match /ideas/{ideaId} {
      allow read: if isSignedIn();
      allow create: if isCreatingOwnIdea(request.auth.uid, request.resource.data);

      allow update: if isAdmin() // Admins can update status, phase, marks, mentor, etc.
                    || ( // Idea owner can update their PPT and team members
                        isIdeaOwner(resource.data.userId) &&
                        (
                            // For PPT upload
                            (request.resource.data.phase2PptUrl is string &&
                             request.resource.data.phase2PptFileName is string &&
                             request.resource.data.phase2PptUploadedAt == request.time &&
                             request.resource.data.keys().hasAll(['phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt']) &&
                             request.resource.data.updatedAt == request.time
                            ) ||
                            // For managing structuredTeamMembers and teamMemberEmails
                            (request.resource.data.structuredTeamMembers is list &&
                             request.resource.data.teamMemberEmails is list &&
                             request.resource.data.keys().hasAll(['structuredTeamMembers', 'teamMemberEmails', 'updatedAt']) &&
                             request.resource.data.updatedAt == request.time &&
                             // Owner cannot change other critical fields via this path
                             request.resource.data.status == resource.data.status &&
                             request.resource.data.programPhase == resource.data.programPhase &&
                             request.resource.data.title == resource.data.title
                            )
                        )
                       );
                       // Team member self-update into structuredTeamMembers handled by AuthContext + Firestore logic
                       // A specific rule for that would be too complex here.
                       // Assume team member updates to their *own* data within structuredTeamMembers are
                       // validated by client/server logic and then allowed if only structuredTeamMembers & updatedAt change.


      allow delete: if isAdmin(); // Or isIdeaOwner(resource.data.userId) if owners can delete.
    }

    // Announcement Rules
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isAdmin() && request.resource.data.createdByUid == request.auth.uid && request.resource.data.createdAt == request.time;
      allow update: if isAdmin() && request.resource.data.updatedAt == request.time;
      allow delete: if isAdmin();
    }

    // Cohort Rules (Basic, expand as needed)
    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isAdmin() && request.resource.data.createdByUid == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    // System Settings Rules
    match /systemSettings/{settingsId} {
        allow read: if isSignedIn();
        // Only admins can write, and only to the 'config' document.
        allow write: if isAdmin() && settingsId == 'config' && request.resource.data.updatedAt == request.time;
    }

    // Activity Logs Rules
    match /activityLogs/{logId} {
        allow read: if isAdmin(); // Only admins can read logs
        allow create: if isSignedIn(); // Any signed-in user can create (trigger) a log entry (client or functions)
        allow update, delete: if false; // Logs are immutable
    }
  }
}

    