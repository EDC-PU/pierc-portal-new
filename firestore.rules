
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isSuperAdminUser() {
      return request.auth.token.isSuperAdmin == true || request.auth.token.email == 'pranavrathi07@gmail.com';
    }

    function isAdminUser() {
      return request.auth.token.role == 'ADMIN_FACULTY';
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingUser() {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    // Validation functions
    function isValidUserProfileData(data) {
      return data.fullName is string &&
             data.contactNumber is string &&
             (data.role in ['STUDENT', 'EXTERNAL_USER', 'ADMIN_FACULTY'] || data.role == null) &&
             (data.applicantCategory is string || data.applicantCategory == null) &&
             (data.currentStage is string || data.currentStage == null) &&
             (data.startupTitle is string || data.startupTitle == null) &&
             (data.problemDefinition is string || data.problemDefinition == null) &&
             (data.solutionDescription is string || data.solutionDescription == null) &&
             (data.uniqueness is string || data.uniqueness == null);
    }
    
    function isValidEventData(data) {
      return data.title is string && data.title.size() > 0 &&
             data.description is string && data.description.size() > 0 &&
             data.location is string && data.location.size() > 0 &&
             data.category is string && data.category in ['WORKSHOP', 'DEADLINE', 'MEETING', 'WEBINAR', 'OTHER'] &&
             // Timestamps are server-generated, so we cannot check their type on create.
             // We trust the client is sending a serverTimestamp() and validate the final type on update.
             data.rsvpCount == 0 &&
             data.rsvps.size() == 0 &&
             data.createdByUid == request.auth.uid;
    }

    function isIdeaDataInternallyConsistent(data) {
        let teamMemberEmails = data.structuredTeamMembers.map(m => m.email.lower());
        return data.teamMemberEmails.toSet().hasAll(teamMemberEmails) &&
               data.teamMemberEmails.size() == teamMemberEmails.size() &&
               (data.phase2Marks == null || data.phase2Marks is map) &&
               (data.sanction1Amount + data.sanction2Amount == data.totalFundingAllocated || (data.totalFundingAllocated == null || data.sanction1Amount == null || data.sanction2Amount == null));
    }

    function isValidIdeaData(data) {
        return data.title is string &&
               data.problem is string &&
               data.solution is string &&
               data.uniqueness is string &&
               data.developmentStage is string &&
               data.applicantType is string &&
               data.status is string &&
               (data.programPhase is string || data.programPhase == null) &&
               (data.cohortId is string || data.cohortId == null) &&
               (data.mentor is string || data.mentor == null) &&
               data.createdAt is timestamp &&
               data.submittedAt is timestamp &&
               data.updatedAt is timestamp;
    }

    // Rules
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(userId) && isValidUserProfileData(request.resource.data);
      allow update: if (isOwner(userId) && isOwnProfileUpdateAllowed(request.resource.data, resource.data)) ||
                       (isSuperAdminUser() && isValidUserProfileData(request.resource.data));
      allow delete: if isOwner(userId) || isSuperAdminUser();

      function isOwnProfileUpdateAllowed(newData, existingData) {
        let nonEditableFields = ['uid', 'email', 'role', 'isSuperAdmin', 'createdAt', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'];
        let allowedFieldsForTeamMember = ['fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName', 'photoURL', 'updatedAt'];
        let allowedFieldsForOwner = ['fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName', 'photoURL', 'updatedAt', 'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers'];
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();

        let coreFieldsUnchanged = !changedKeys.hasAny(nonEditableFields);

        if (existingData.isTeamMemberOnly == true) {
          return coreFieldsUnchanged && changedKeys.hasOnly(allowedFieldsForTeamMember);
        } else {
          return coreFieldsUnchanged && changedKeys.hasOnly(allowedFieldsForOwner);
        }
      }
    }
    
    match /ideas/{ideaId} {
      allow read: if isSignedIn();
      allow create: if (isOwner(request.resource.data.userId) || isSuperAdminUser()) &&
                       isValidIdeaData(request.resource.data) &&
                       isIdeaDataInternallyConsistent(request.resource.data) &&
                       isValidInitialOrResubmittedIdeaState(request.resource.data);
      
      allow update: if (isSuperAdminUser()) ||
                       (isOwner(resource.data.userId) && isOwnerMakingAllowedChanges(request.resource.data, resource.data)) ||
                       (isAdminUser() && isAdminUpdatingAllowedFields(request.resource.data, resource.data));

      function isOwnerMakingAllowedChanges(newData, existingData) {
        let immutableFields = ['userId', 'createdAt', 'submittedAt'];
        let ownerEditableFields = [
          'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
          'fileURL', 'fileName', 'studioLocation', 'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt',
          'isOutlineAIGenerated', 'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode',
          'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName', 'sanction1Expenses', 'sanction2Expenses', 'sanction1AppliedForNext'
        ];
        let changedKeys = newData.diff(existingData).affectedKeys();
        
        return !changedKeys.hasAny(immutableFields) &&
               changedKeys.hasOnly(ownerEditableFields) &&
               isIdeaDataInternallyConsistent(newData) &&
               isValidIdeaData(newData) &&
               (existingData.status in ['SUBMITTED', 'ARCHIVED_BY_ADMIN']);
      }

      function isAdminUpdatingAllowedFields(newData, existingData) {
        let immutableFields = ['userId', 'createdAt', 'submittedAt', 'title', 'problem', 'solution', 'uniqueness', 'applicantType', 'developmentStage'];
        let allowedAdminFieldsToChange = [
            'status', 'programPhase', 'cohortId', 'mentor', 'phase2Marks', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', 'updatedAt',
            'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
            'fundingSource', 'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount', 'sanction1DisbursedAt', 'sanction2DisbursedAt',
            'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt',
            'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt',
            'isOutlineAIGenerated',
            'sanction1Expenses', 'sanction2Expenses', 'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode',
            'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName', 'sanction1AppliedForNext'
        ];
        let changedKeys = newData.diff(existingData).affectedKeys();
        
        return !changedKeys.hasAny(immutableFields) &&
               changedKeys.hasOnly(allowedAdminFieldsToChange) &&
               isIdeaDataInternallyConsistent(newData) &&
               isValidIdeaData(newData) &&
               newData.userId == existingData.userId &&
               newData.createdAt.toMillis() == existingData.createdAt.toMillis() &&
               newData.submittedAt.toMillis() == existingData.submittedAt.toMillis();
      }

       function isValidInitialOrResubmittedIdeaState(data) {
          return data.status == 'SUBMITTED' &&
                 data.programPhase == null &&
                 data.cohortId == null &&
                 data.mentor == null &&
                 data.phase2Marks.size() == 0 &&
                 data.isOutlineAIGenerated == false &&
                 data.rejectionRemarks == null &&
                 data.rejectedByUid == null &&
                 data.rejectedAt == null &&
                 data.phase2PptUrl == null &&
                 data.phase2PptFileName == null &&
                 data.phase2PptUploadedAt == null &&
                 data.nextPhaseDate == null &&
                 data.nextPhaseStartTime == null &&
                 data.nextPhaseEndTime == null &&
                 data.nextPhaseVenue == null &&
                 data.nextPhaseGuidelines == null &&
                 data.fundingSource == null &&
                 data.totalFundingAllocated == null &&
                 data.sanction1Amount == null &&
                 data.sanction2Amount == null &&
                 data.sanction1DisbursedAt == null &&
                 data.sanction2DisbursedAt == null &&
                 data.sanction1Expenses.size() == 0 &&
                 data.sanction2Expenses.size() == 0 &&
                 data.beneficiaryName == null &&
                 data.beneficiaryAccountNo == null &&
                 data.beneficiaryBankName == null &&
                 data.beneficiaryIfscCode == null &&
                 data.beneficiaryAccountType == null &&
                 data.beneficiaryCity == null &&
                 data.beneficiaryBranchName == null &&
                 data.sanction1AppliedForNext == false &&
                 data.sanction1UtilizationStatus == 'NOT_APPLICABLE' &&
                 data.sanction1UtilizationRemarks == null &&
                 data.sanction1UtilizationReviewedBy == null &&
                 data.sanction1UtilizationReviewedAt == null &&
                 data.sanction2UtilizationStatus == 'NOT_APPLICABLE' &&
                 data.sanction2UtilizationRemarks == null &&
                 data.sanction2UtilizationReviewedBy == null &&
                 data.sanction2UtilizationReviewedAt == null;
      }
    }
    
    match /systemSettings/config {
        allow read: if isSignedIn();
        allow write: if isAdminUser() || isSuperAdminUser();
    }
    
    match /cohorts/{cohortId} {
        allow read: if isSignedIn();
        allow create, update, delete: if isSuperAdminUser() || isAdminUser();
    }
    
    match /announcements/{announcementId} {
        allow read: if isSignedIn();
        allow create, update, delete: if isAdminUser() || isSuperAdminUser();
    }

    match /activityLogs/{logId} {
        allow read: if isAdminUser() || isSuperAdminUser();
        allow create: if isSignedIn();
    }
    
    match /events/{eventId} {
      allow read: if isSignedIn();
      allow create: if isSuperAdminUser() || (isAdminUser() && isValidEventData(request.resource.data));
      allow update: if (isSuperAdminUser()) ||
                       (isAdminUser() && request.resource.data.createdByUid == resource.data.createdByUid) ||
                       (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['rsvps', 'rsvpCount']));
      allow delete: if isSuperAdminUser() || isAdminUser();
    }
    
    match /notifications/{notificationId} {
      allow read, update: if isSignedIn() && isOwner(resource.data.userId);
      allow create: if isSignedIn();
    }

  }
}
