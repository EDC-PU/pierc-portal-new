
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdmin() {
      // return isSignedIn() && request.auth.token.admin == true; // Ideal, needs custom claims
      return isSignedIn() && (request.auth.token.admin == true || request.auth.email == 'pranavrathi07@gmail.com');
    }

    function isSuperAdmin() {
       return isSignedIn() && (request.auth.token.isSuperAdmin == true || request.auth.email == 'pranavrathi07@gmail.com');
    }

    function getRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    function isUserProfileDataValid(data) {
      return data.uid is string &&
             (data.email == null || data.email is string) &&
             (data.displayName == null || data.displayName is string) &&
             (data.photoURL == null || data.photoURL is string) &&
             (data.role == null || data.role is string) && // Allow null role initially
             data.fullName is string &&
             data.contactNumber is string &&
             (data.applicantCategory == null || data.applicantCategory is string) &&
             (data.currentStage == null || data.currentStage is string) &&
             (data.startupTitle == null || data.startupTitle is string) &&
             (data.problemDefinition == null || data.problemDefinition is string) &&
             (data.solutionDescription == null || data.solutionDescription is string) &&
             (data.uniqueness == null || data.uniqueness is string) &&
             (data.enrollmentNumber == null || data.enrollmentNumber is string) &&
             (data.college == null || data.college is string) &&
             (data.instituteName == null || data.instituteName is string) &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             data.isSuperAdmin is bool &&
             (data.isTeamMemberOnly == null || data.isTeamMemberOnly is bool) &&
             (data.associatedIdeaId == null || data.associatedIdeaId is string) &&
             (data.associatedTeamLeaderUid == null || data.associatedTeamLeaderUid is string);
    }
     function isIdeaDataInternallyConsistent(data) {
        return data.userId is string &&
               data.title is string && data.title.size() > 0 &&
               data.problem is string && data.problem.size() > 0 &&
               data.solution is string && data.solution.size() > 0 &&
               data.uniqueness is string && data.uniqueness.size() > 0 &&
               data.developmentStage is string &&
               (data.applicantType == null || data.applicantType is string) &&
               (data.category == null || data.category is string) &&
               data.status is string &&
               (data.programPhase == null || data.programPhase is string) &&
               (data.mentor == null || data.mentor is string) &&
               (data.cohortId == null || data.cohortId is string) &&
               (data.phase2PptUrl == null || data.phase2PptUrl is string) &&
               (data.phase2PptFileName == null || data.phase2PptFileName is string) &&
               (data.phase2PptUploadedAt == null || data.phase2PptUploadedAt is timestamp) &&
               (data.isOutlineAIGenerated == null || data.isOutlineAIGenerated is bool) &&
               (data.nextPhaseDate == null || data.nextPhaseDate is timestamp) &&
               (data.nextPhaseStartTime == null || data.nextPhaseStartTime is string) &&
               (data.nextPhaseEndTime == null || data.nextPhaseEndTime is string) &&
               (data.nextPhaseVenue == null || data.nextPhaseVenue is string) &&
               (data.nextPhaseGuidelines == null || data.nextPhaseGuidelines is string) &&
               (data.fundingSource == null || data.fundingSource is string) &&
               (data.totalFundingAllocated == null || data.totalFundingAllocated is number) &&
               (data.sanction1Amount == null || data.sanction1Amount is number) &&
               (data.sanction2Amount == null || data.sanction2Amount is number) &&
               (data.sanction1DisbursedAt == null || data.sanction1DisbursedAt is timestamp) &&
               (data.sanction2DisbursedAt == null || data.sanction2DisbursedAt is timestamp) &&
               (data.beneficiaryName == null || data.beneficiaryName is string) &&
               (data.beneficiaryAccountNo == null || data.beneficiaryAccountNo is string) &&
               (data.beneficiaryBankName == null || data.beneficiaryBankName is string) &&
               (data.beneficiaryIfscCode == null || data.beneficiaryIfscCode is string) &&
               (data.beneficiaryAccountType == null || data.beneficiaryAccountType is string) &&
               (data.beneficiaryCity == null || data.beneficiaryCity is string) &&
               (data.beneficiaryBranchName == null || data.beneficiaryBranchName is string) &&
               (data.sanction1AppliedForNext == null || data.sanction1AppliedForNext is bool) &&
               (data.sanction1UtilizationStatus == null || data.sanction1UtilizationStatus is string) &&
               (data.sanction1UtilizationRemarks == null || data.sanction1UtilizationRemarks is string) &&
               (data.sanction1UtilizationReviewedBy == null || data.sanction1UtilizationReviewedBy is string) &&
               (data.sanction1UtilizationReviewedAt == null || data.sanction1UtilizationReviewedAt is timestamp) &&
               (data.sanction2UtilizationStatus == null || data.sanction2UtilizationStatus is string) &&
               (data.sanction2UtilizationRemarks == null || data.sanction2UtilizationRemarks is string) &&
               (data.sanction2UtilizationReviewedBy == null || data.sanction2UtilizationReviewedBy is string) &&
               (data.sanction2UtilizationReviewedAt == null || data.sanction2UtilizationReviewedAt is timestamp) &&
               data.phase2Marks is map &&
               data.sanction1Expenses is list &&
               data.sanction2Expenses is list &&
               data.submittedAt is timestamp &&
               data.updatedAt is timestamp &&
               (data.createdAt == null || data.createdAt is timestamp) && // createdAt might not exist on very old docs if not backfilled
               (data.rejectionRemarks == null || data.rejectionRemarks is string) &&
               (data.rejectedByUid == null || data.rejectedByUid is string) &&
               (data.rejectedAt == null || data.rejectedAt is timestamp) &&
               (data.applicantDisplayName == null || data.applicantDisplayName is string) &&
               (data.applicantEmail == null || data.applicantEmail is string) &&
               (data.teamMembers == null || data.teamMembers is string) &&
               (data.structuredTeamMembers == null || data.structuredTeamMembers is list) &&
               (data.teamMemberEmails == null || data.teamMemberEmails is list) &&
               (data.fileURL == null || data.fileURL is string) &&
               (data.fileName == null || data.fileName is string) &&
               (data.studioLocation == null || data.studioLocation is string) &&
               (data.updatedByMentorAssignerUid == null || data.updatedByMentorAssignerUid is string)
               ;
      }


    // Function to check if user data is complete for idea submission context
    function isUserDataCompleteForIdea(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId)).data;
      return userDoc.role != null &&
             userDoc.fullName != null && userDoc.fullName != '' &&
             userDoc.contactNumber != null && userDoc.contactNumber != '' &&
             ( (userDoc.role == 'ADMIN_FACULTY' || userDoc.isTeamMemberOnly == true) || // Admins or team members don't need these for their "idea" record
               (userDoc.applicantCategory != null &&
                userDoc.currentStage != null &&
                userDoc.startupTitle != null && userDoc.startupTitle != '' &&
                userDoc.problemDefinition != null && userDoc.problemDefinition != '' &&
                userDoc.solutionDescription != null && userDoc.solutionDescription != '' &&
                userDoc.uniqueness != null && userDoc.uniqueness != '')
             );
    }

    // Function to check the overall validity of idea data, including specific field values and relationships.
    function isValidIdeaData(data) {
      return isIdeaDataInternallyConsistent(data) &&
             data.status in ['SUBMITTED', 'UNDER_REVIEW', 'IN_EVALUATION', 'SELECTED', 'NOT_SELECTED', 'ARCHIVED_BY_ADMIN'] &&
             (data.programPhase == null || data.programPhase in ['PHASE_1', 'PHASE_2', 'COHORT', 'INCUBATED']) &&
             (data.fundingSource == null || data.fundingSource in ['SSIP_PIET', 'SSIP_PARUL_UNIVERSITY', 'SSIP_PIMSR', 'SSIP_PHYSIOTHERAPY']) &&
             (data.beneficiaryAccountType == null || data.beneficiaryAccountType in ['SAVINGS', 'CURRENT']) &&
             (data.sanction1UtilizationStatus == null || data.sanction1UtilizationStatus in ['PENDING', 'APPROVED', 'REJECTED', 'NOT_APPLICABLE']) &&
             (data.sanction2UtilizationStatus == null || data.sanction2UtilizationStatus in ['PENDING', 'APPROVED', 'REJECTED', 'NOT_APPLICABLE']) &&
             (data.phase2Marks == null || data.phase2Marks is map) && // Ensure phase2Marks is a map
             (data.sanction1Expenses == null || data.sanction1Expenses is list) && // Ensure expenses are lists
             (data.sanction2Expenses == null || data.sanction2Expenses is list) &&
             (data.structuredTeamMembers == null || data.structuredTeamMembers is list) &&
             (data.teamMemberEmails == null || data.teamMemberEmails is list) &&
             // If status is SELECTED, programPhase must be set (unless it's being set in the same request)
             (data.status != 'SELECTED' || data.programPhase != null || request.resource.data.programPhase != null) &&
             // If phase is COHORT, cohortId should be set (unless it's being set in same request)
             (data.programPhase != 'COHORT' || data.cohortId != null || request.resource.data.cohortId != null) &&
             // If phase is INCUBATED, funding fields should ideally be populated by admin
             (data.programPhase != 'INCUBATED' || (
                (data.fundingSource != null || request.resource.data.fundingSource != null) &&
                (data.totalFundingAllocated != null || request.resource.data.totalFundingAllocated != null) &&
                (data.sanction1Amount != null || request.resource.data.sanction1Amount != null) &&
                (data.sanction2Amount != null || request.resource.data.sanction2Amount != null)
             ) || data.status != 'SELECTED') // Allow if not selected yet or if admin is in process of setting it
             ;
    }

    // Initial state for new ideas or resubmitted ideas (after user profile save)
    function isValidInitialOrResubmittedIdeaState(data) {
        return data.status == 'SUBMITTED' &&
               data.programPhase == null &&
               data.mentor == null &&
               data.cohortId == null &&
               data.phase2Marks == {} &&
               data.isOutlineAIGenerated == false &&
               data.rejectionRemarks == null &&
               data.rejectedByUid == null &&
               data.rejectedAt == null &&
               data.phase2PptUrl == null &&
               data.phase2PptFileName == null &&
               data.phase2PptUploadedAt == null &&
               data.nextPhaseDate == null &&
               data.nextPhaseStartTime == null &&
               data.nextPhaseEndTime == null &&
               data.nextPhaseVenue == null &&
               data.nextPhaseGuidelines == null &&
               data.fundingSource == null &&
               data.totalFundingAllocated == null &&
               data.sanction1Amount == null &&
               data.sanction2Amount == null &&
               data.sanction1DisbursedAt == null &&
               data.sanction2DisbursedAt == null &&
               data.sanction1Expenses == [] &&
               data.sanction2Expenses == [] &&
               data.beneficiaryName == null &&
               data.beneficiaryAccountNo == null &&
               data.beneficiaryBankName == null &&
               data.beneficiaryIfscCode == null &&
               data.beneficiaryAccountType == null &&
               data.beneficiaryCity == null &&
               data.beneficiaryBranchName == null &&
               data.sanction1AppliedForNext == false &&
               data.sanction1UtilizationStatus == 'NOT_APPLICABLE' &&
               data.sanction1UtilizationRemarks == null &&
               data.sanction1UtilizationReviewedBy == null &&
               data.sanction1UtilizationReviewedAt == null &&
               data.sanction2UtilizationStatus == 'NOT_APPLICABLE' &&
               data.sanction2UtilizationRemarks == null &&
               data.sanction2UtilizationReviewedBy == null &&
               data.sanction2UtilizationReviewedAt == null &&
               isIdeaDataInternallyConsistent(data); // Also check base types
    }

    // Fields a user is allowed to update on their own idea submission (mostly through profile updates that sync here)
    let allowedUserIdeaFields = [
      'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType',
      'studioLocation', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
      'applicantDisplayName', 'applicantEmail', // these are updated from profile sync
      'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', // User can upload PPT for Phase 2
      'status', // User can change status from ARCHIVED_BY_ADMIN or NOT_SELECTED to SUBMITTED
      'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName', // User can update their bank details
      'sanction1Expenses', 'sanction2Expenses', // User can add expenses
      'sanction1AppliedForNext', // User can apply for next sanction
      'updatedAt'
    ];
    function isUpdatingOnlyAllowedUserIdeaFields(changedKeys) {
      return changedKeys.hasOnly(allowedUserIdeaFields);
    }

    let allowedAdminFieldsToChange = [
      'status', 'programPhase', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
      'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
      'mentor', 'cohortId', 'phase2Marks', 'isOutlineAIGenerated',
      'fundingSource', 'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount',
      'sanction1DisbursedAt', 'sanction2DisbursedAt',
      'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt',
      'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt',
      'updatedAt', 'updatedByMentorAssignerUid',
      // Added fields admin needs to reset or initialize
      'sanction1Expenses', 'sanction2Expenses',
      'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName',
      'sanction1AppliedForNext'
    ];
    function isUpdatingOnlyAllowedAdminIdeaFields(changedKeys) {
       return changedKeys.hasOnly(allowedAdminFieldsToChange);
    }

    function isUpdatingOnlyAllowedBeneficiaryFields(changedKeys) {
        let allowedFields = [
            'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName',
            'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName',
            'updatedAt'
        ];
        return changedKeys.hasOnly(allowedFields);
    }

    function isUnchangedForUserResubmit(existingData, newData) {
      // When user resubmits an ARCHIVED or NOT_SELECTED idea, only specific fields should change, others must remain same or be reset by admin flow
      return newData.userId == existingData.userId &&
             // These are updated from profile
             // newData.title == existingData.title &&
             // newData.problem == existingData.problem &&
             // newData.solution == existingData.solution &&
             // newData.uniqueness == existingData.uniqueness &&
             // newData.developmentStage == existingData.developmentStage &&
             // newData.applicantType == existingData.applicantType &&
             // newData.teamMembers == existingData.teamMembers && // Now managed by structuredTeamMembers
             // Timestamps are handled by server or rules
             // newData.createdAt == existingData.createdAt && // Should be preserved
             // newData.submittedAt == existingData.submittedAt && // Should be preserved
             // User specific uploads are preserved
             (newData.fileURL == existingData.fileURL || newData.fileURL == null) &&
             (newData.fileName == existingData.fileName || newData.fileName == null) &&
             (newData.studioLocation == existingData.studioLocation || newData.studioLocation == null) &&
             // Structured team members might change
             // (newData.structuredTeamMembers == existingData.structuredTeamMembers || newData.structuredTeamMembers == []) &&
             // (newData.teamMemberEmails == existingData.teamMemberEmails || newData.teamMemberEmails == []) &&
             // Funding details are preserved or reset by admin
             (newData.fundingSource == existingData.fundingSource || newData.fundingSource == null) &&
             (newData.totalFundingAllocated == existingData.totalFundingAllocated || newData.totalFundingAllocated == null) &&
             (newData.sanction1Amount == existingData.sanction1Amount || newData.sanction1Amount == null) &&
             (newData.sanction2Amount == existingData.sanction2Amount || newData.sanction2Amount == null) &&
             (newData.sanction1DisbursedAt == existingData.sanction1DisbursedAt || newData.sanction1DisbursedAt == null) &&
             (newData.sanction2DisbursedAt == existingData.sanction2DisbursedAt || newData.sanction2DisbursedAt == null) &&
             // Beneficiary details are preserved
             (newData.beneficiaryName == existingData.beneficiaryName || newData.beneficiaryName == null) &&
             (newData.beneficiaryAccountNo == existingData.beneficiaryAccountNo || newData.beneficiaryAccountNo == null) &&
             (newData.beneficiaryBankName == existingData.beneficiaryBankName || newData.beneficiaryBankName == null) &&
             (newData.beneficiaryIfscCode == existingData.beneficiaryIfscCode || newData.beneficiaryIfscCode == null) &&
             (newData.beneficiaryAccountType == existingData.beneficiaryAccountType || newData.beneficiaryAccountType == null) &&
             (newData.beneficiaryCity == existingData.beneficiaryCity || newData.beneficiaryCity == null) &&
             (newData.beneficiaryBranchName == existingData.beneficiaryBranchName || newData.beneficiaryBranchName == null)
             ;
    }

    // Utility function to get changed keys
    function changedKeys(before, after) {
      let keys = before.keys().concat(after.keys()).toSet();
      let changed = [];
      for (let key in keys) {
        if (before[key] != after[key]) {
          changed.push(key);
        }
      }
      return changed.toSet();
    }
    // Utility to check if a Map has only specified keys (more robust than directly using `in` on a list)
    function hasOnly(map, keys) {
      return map.keys().toSet().difference(keys.toSet()).size() == 0;
    }


    // Users collection
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isUser(userId) &&
                       isUserProfileDataValid(request.resource.data) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       // New users cannot set themselves as super admin unless it's the specific email
                       (request.resource.data.isSuperAdmin == false || request.auth.email == 'pranavrathi07@gmail.com') &&
                       // Role can be null on initial profile creation stub by auth, then set by user in profile setup
                       (request.resource.data.role == null || request.resource.data.role in ['STUDENT', 'EXTERNAL_USER', 'ADMIN_FACULTY']) &&
                       // Ensure uid matches the document id
                       request.resource.data.uid == userId;
      allow update: if // Admin can update any user's role/superadmin status
                       ( isAdmin() &&
                         isUserProfileDataValid(request.resource.data) &&
                         request.resource.data.updatedAt == request.time &&
                         request.resource.data.uid == userId && // uid should not change
                         request.resource.data.email == resource.data.email && // email should not change
                         request.resource.data.createdAt == resource.data.createdAt // createdAt should not change
                         // Admin can change 'role' and 'isSuperAdmin'
                       ) ||
                       // User can update their own profile
                       ( isUser(userId) &&
                         isUserProfileDataValid(request.resource.data) &&
                         request.resource.data.updatedAt == request.time &&
                         request.resource.data.uid == userId &&
                         request.resource.data.email == resource.data.email &&
                         request.resource.data.createdAt == resource.data.createdAt &&
                         // User cannot change their own role or superAdmin status directly
                         request.resource.data.role == resource.data.role &&
                         request.resource.data.isSuperAdmin == resource.data.isSuperAdmin
                       );
      allow delete: if isAdmin() && request.auth.uid != userId; // Admin can delete other users, but not themselves via this rule
                      // Self-deletion should be handled by a Cloud Function that also deletes auth user.
    }

    // Ideas collection
    match /ideas/{ideaId} {
      allow read: if isSignedIn(); // Any signed-in user can read idea details (e.g. for team member view)
      allow create: if request.auth != null &&
                       request.resource.data.userId == request.auth.uid &&
                       isValidInitialOrResubmittedIdeaState(request.resource.data) &&
                       isValidIdeaData(request.resource.data) && // General validation for all idea data
                       request.resource.data.createdAt == request.time && // Ensure timestamps are server-generated on create
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.submittedAt == request.time;

      allow update: if request.auth != null &&
        // User can only update their own idea if it's not locked for admin review OR if it's archived and they are resubmitting.
        (
          (
            request.resource.data.userId == request.auth.uid &&
            resource.data.userId == request.auth.uid &&
            // Allow if ARCHIVED_BY_ADMIN and user is resubmitting (status becomes SUBMITTED and other fields are reset)
            ( (resource.data.status == 'ARCHIVED_BY_ADMIN' && request.resource.data.status == 'SUBMITTED' && isValidInitialOrResubmittedIdeaState(request.resource.data) && isUnchangedForUserResubmit(resource.data, request.resource.data) ) ||
            // OR allow if NOT SELECTED and user is resubmitting (status becomes SUBMITTED and other fields are reset by admin, or user just changes title/problem etc via profile)
              (resource.data.status == 'NOT_SELECTED' && request.resource.data.status == 'SUBMITTED' && isValidInitialOrResubmittedIdeaState(request.resource.data) && isUnchangedForUserResubmit(resource.data, request.resource.data) ) ||
            // OR allow user to update their own idea if it's not yet deeply in admin process (e.g., not selected, cohort, incubated)
              ( !(resource.data.status in ['SELECTED', 'IN_EVALUATION']) && !(resource.data.programPhase in ['COHORT', 'INCUBATED']) &&
                isIdeaDataInternallyConsistent(request.resource.data) &&
                isValidIdeaData(request.resource.data) &&
                (
                    isUpdatingOnlyAllowedUserIdeaFields(changedKeys(resource.data, request.resource.data)) ||
                    // Allow user to update beneficiary details if idea is INCUBATED and they own it
                    (resource.data.programPhase == 'INCUBATED' && isUpdatingOnlyAllowedBeneficiaryFields(changedKeys(resource.data, request.resource.data)))
                )

              )
            )
          ) ||
        // Admin can update status, phase, remarks, nextPhaseDetails, mentor, cohortId, phase2Marks, funding details.
          (
            isAdmin() && // Or request.auth.email == 'pranavrathi07@gmail.com'
            isIdeaDataInternallyConsistent(request.resource.data) &&
            isValidIdeaData(request.resource.data) &&
            isUpdatingOnlyAllowedAdminIdeaFields(changedKeys(resource.data, request.resource.data)) &&
            // Ensure admin doesn't change user-owned core data unless it's part of status change logic (e.g., rejection remarks)
            (request.resource.data.title == resource.data.title) &&
            (request.resource.data.problem == resource.data.problem) &&
            (request.resource.data.solution == resource.data.solution) &&
            (request.resource.data.uniqueness == resource.data.uniqueness) &&
            (request.resource.data.developmentStage == resource.data.developmentStage) &&
            (request.resource.data.applicantType == resource.data.applicantType) &&
            (request.resource.data.userId == resource.data.userId)
          )
        );


      allow delete: if false; // Ideas should be archived, not deleted, by admins.
    }

    // Announcements collection
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isAdmin() &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.title is string && request.resource.data.title.size() > 0 &&
                       request.resource.data.content is string && request.resource.data.content.size() > 0 &&
                       request.resource.data.isUrgent is bool &&
                       request.resource.data.targetAudience is string && request.resource.data.targetAudience in ['ALL', 'SPECIFIC_COHORT'] &&
                       (request.resource.data.targetAudience == 'ALL' || request.resource.data.cohortId is string) &&
                       (request.resource.data.cohortId == null || request.resource.data.cohortId is string) &&
                       request.resource.data.creatorDisplayName is string;
      allow update: if isAdmin() &&
                       request.resource.data.updatedAt == request.time &&
                       // Prevent changing creator or creation time
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.creatorDisplayName == resource.data.creatorDisplayName &&
                       request.resource.data.title is string && request.resource.data.title.size() > 0 &&
                       request.resource.data.content is string && request.resource.data.content.size() > 0 &&
                       request.resource.data.isUrgent is bool &&
                       request.resource.data.targetAudience is string && request.resource.data.targetAudience in ['ALL', 'SPECIFIC_COHORT'] &&
                       (request.resource.data.targetAudience == 'ALL' || request.resource.data.cohortId is string) &&
                       (request.resource.data.cohortId == null || request.resource.data.cohortId is string);
      allow delete: if isAdmin();
    }

     // Cohorts collection
    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isAdmin() &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                       request.resource.data.startDate is timestamp &&
                       request.resource.data.endDate is timestamp &&
                       request.resource.data.endDate > request.resource.data.startDate &&
                       request.resource.data.batchSize is number && request.resource.data.batchSize > 0 &&
                       request.resource.data.ideaIds is list &&
                       request.resource.data.schedule is list &&
                       request.resource.data.creatorDisplayName is string;

      allow update: if isAdmin() &&
                       request.resource.data.updatedAt == request.time &&
                       // Prevent changing creator or creation time
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.creatorDisplayName == resource.data.creatorDisplayName &&
                       request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                       request.resource.data.startDate is timestamp &&
                       request.resource.data.endDate is timestamp &&
                       request.resource.data.endDate > request.resource.data.startDate &&
                       request.resource.data.batchSize is number && request.resource.data.batchSize > 0 &&
                       request.resource.data.ideaIds is list && // Admin can update assigned ideas
                       request.resource.data.schedule is list; // Admin can update schedule

      allow delete: if isAdmin() && resource.data.ideaIds.size() == 0; // Only if no ideas assigned
    }


    // System Settings collection
    match /systemSettings/{docId} {
      allow read: if isSignedIn(); // All signed-in users might need to read some settings (e.g., maintenance mode)
      allow create, update: if isAdmin() &&
                                request.resource.data.updatedAt == request.time &&
                                request.resource.data.updatedByUid == request.auth.uid &&
                                request.resource.data.portalName is string && request.resource.data.portalName.size() > 0 &&
                                request.resource.data.maintenanceMode is bool &&
                                request.resource.data.allowNewRegistrations is bool &&
                                request.resource.data.defaultCohortSize is number && request.resource.data.defaultCohortSize > 0;
      allow delete: if false; // Settings should not be deleted.
    }

    // Activity Logs collection
    match /activityLogs/{logId} {
      allow read: if isAdmin();
      allow create: if isSignedIn(); // Any signed-in user can trigger an activity log write (server-side logic should ensure legitimacy)
                        // Validation: Ensure required fields are present
                        // request.resource.data.timestamp == request.time && // This might be an issue if client provides it
                        // request.resource.data.actorUid == request.auth.uid && (No, admin can log for others)
                        // request.resource.data.action is string &&
                        // (request.resource.data.target == null || request.resource.data.target is map) &&
                        // (request.resource.data.details == null || request.resource.data.details is map);
      allow update, delete: if false; // Logs should be immutable
    }
  }
}

    