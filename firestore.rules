
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function isUserProfileAdmin() {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN_FACULTY';
    }

    function isUserProfileSuperAdmin() {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    function getMentorEmails() {
      return [
        'prashant.khanna8747@paruluniversity.ac.in',
        'riddhi.bagha29080@paruluniversity.ac.in',
        'nikhil.jumade24167@paruluniversity.ac.in',
        'jay.sudani@paruluniversity.ac.in',
        'hardik.kharva2899@paruluniversity.ac.in',
        'sonal.sudani23321@paruluniversity.ac.in',
        'panchamkumar.baraiya28771@paruluniversity.ac.in',
        'juned.shaikh32161@paruluniversity.ac.in'
      ];
    }

    function isMentorEmail(email) {
      return email in getMentorEmails();
    }

    function isSuperAdminEmail(email) {
      return email == 'pranavrathi07@gmail.com';
    }

    // User Profile Validation Helpers
    function isValidRole(role) {
      return role == 'STUDENT' || role == 'EXTERNAL_USER' || role == 'ADMIN_FACULTY';
    }

    function isValidApplicantCategory(category) {
      return category == 'PARUL_STUDENT' || category == 'PARUL_STAFF' || category == 'PARUL_ALUMNI' || category == 'OTHERS';
    }

    function isValidCurrentStage(stage) {
      return stage == 'IDEA' || stage == 'PROTOTYPE_STAGE' || stage == 'STARTUP_STAGE';
    }

    function isNonEmptyString(value) {
      return value is string && value.size() > 0;
    }
    function isNonEmptyStringMin(value, min) {
      return value is string && value.size() >= min;
    }
    function isStringOrNull(value) {
      return value is string || value == null;
    }
    function isBoolean(value) {
      return value is bool;
    }

    function hasRequiredPersonalFields(data) {
      return isNonEmptyStringMin(data.fullName, 3) &&
             isNonEmptyStringMin(data.contactNumber, 10);
    }

    function hasValidAcademicFields(data) {
      return (isStringOrNull(data.enrollmentNumber)) &&
             (isStringOrNull(data.college)) &&
             (isStringOrNull(data.instituteName));
    }

    // Placeholder data validation
    function isMentorPlaceholderFields(data) {
      return data.startupTitle == 'Faculty/Mentor Account' &&
             data.problemDefinition == 'Manages portal functions and/or mentorship.' &&
             data.solutionDescription == 'Provides administrative or mentorship support.' &&
             data.uniqueness == 'Unique administrative/mentorship role.' &&
             data.currentStage == 'STARTUP_STAGE' && // Default for mentors
             data.applicantCategory == 'PARUL_STAFF'; // Default for mentors
    }

    function isSuperAdminPlaceholderFields(data) {
      return data.startupTitle == 'Administrative Account' &&
             data.problemDefinition == 'Handles portal administration.' &&
             data.solutionDescription == 'Provides administrative functions and support.' &&
             data.uniqueness == 'Unique administrative role for system management.' &&
             data.currentStage == 'STARTUP_STAGE' && // Default for super admin
             data.applicantCategory == 'PARUL_STAFF'; // Default for super admin
    }

    // Full idea owner fields validation
    function hasValidIdeaOwnerSpecificFields(data) {
      return isNonEmptyStringMin(data.startupTitle, 5) &&
             isNonEmptyStringMin(data.problemDefinition, 10) &&
             isNonEmptyStringMin(data.solutionDescription, 10) &&
             isNonEmptyStringMin(data.uniqueness, 10) &&
             isValidApplicantCategory(data.applicantCategory) &&
             isValidCurrentStage(data.currentStage) &&
             isStringOrNull(data.teamMembers); // teamMembers can be empty string or null
    }

    function isValidUserProfileData(userId, data, isCreate) {
      let expectedFields = [
        'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin',
        'fullName', 'contactNumber', 'isTeamMemberOnly', 'updatedAt'
      ];
      let allExpectedFields = expectedFields.concat([
        'enrollmentNumber', 'college', 'instituteName', 'associatedIdeaId', 'associatedTeamLeaderUid',
        'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
        'applicantCategory', 'currentStage', 'teamMembers'
      ]);
      if (isCreate) {
        allExpectedFields.add('createdAt');
      }

      let commonValidations = data.uid == userId &&
                              data.email == request.auth.token.email &&
                              (isStringOrNull(data.displayName)) &&
                              (isStringOrNull(data.photoURL)) &&
                              isValidRole(data.role) &&
                              isBoolean(data.isSuperAdmin) &&
                              hasRequiredPersonalFields(data) &&
                              hasValidAcademicFields(data) &&
                              isBoolean(data.isTeamMemberOnly) &&
                              (isStringOrNull(data.associatedIdeaId)) &&
                              (isStringOrNull(data.associatedTeamLeaderUid)) &&
                              (isCreate ? data.createdAt == request.time : true) &&
                              data.updatedAt == request.time &&
                              data.keys().hasOnly(allExpectedFields);

      if (!commonValidations) {
        return false;
      }

      // Role and SuperAdmin specific logic
      if (isSuperAdminEmail(data.email)) {
        if (!(data.role == 'ADMIN_FACULTY' && data.isSuperAdmin == true)) {
          return false;
        }
      } else if (isMentorEmail(data.email)) {
         if (!(data.role == 'ADMIN_FACULTY' && data.isSuperAdmin == false)) {
          return false;
        }
      } else { // Regular user
        if (!(data.role != 'ADMIN_FACULTY' && data.isSuperAdmin == false)) {
          return false;
        }
      }

      // Field validations based on role and type
      if (data.role == 'ADMIN_FACULTY') {
        // Admins/Mentors can have placeholder idea fields OR actual idea fields
        let placeholderValid = (isSuperAdminEmail(data.email) && isSuperAdminPlaceholderFields(data)) ||
                               (isMentorEmail(data.email) && isMentorPlaceholderFields(data));
        let ideaOwnerFieldsValid = hasValidIdeaOwnerSpecificFields(data) &&
                                   !isSuperAdminPlaceholderFields(data) && !isMentorPlaceholderFields(data); // Not placeholders if full idea
        return (placeholderValid || ideaOwnerFieldsValid) && data.isTeamMemberOnly == false;
      } else if (data.isTeamMemberOnly == true) {
        // Team members should not have idea-specific fields filled by themselves
        return data.startupTitle == null && data.problemDefinition == null &&
               data.solutionDescription == null && data.uniqueness == null &&
               data.applicantCategory == null && data.currentStage == null &&
               data.teamMembers == null;
      } else { // Regular Idea Owner (Student/External)
        return hasValidIdeaOwnerSpecificFields(data) &&
               // Ensure idea titles are not the admin/mentor placeholders
               data.startupTitle != 'Administrative Account' &&
               data.startupTitle != 'Faculty/Mentor Account';
      }
    }

    function isCreatingOwnValidProfile(userId, data) {
      return isValidUserProfileData(userId, data, true);
    }

    function isUpdatingOwnValidProfile(userId, existingData, newData) {
      // Fields that user cannot change themselves directly after creation
      let immutableByOwner = existingData.role == newData.role &&
                             existingData.isSuperAdmin == newData.isSuperAdmin &&
                             existingData.isTeamMemberOnly == newData.isTeamMemberOnly &&
                             existingData.associatedIdeaId == newData.associatedIdeaId &&
                             existingData.associatedTeamLeaderUid == newData.associatedTeamLeaderUid &&
                             existingData.uid == newData.uid && // uid should never change
                             existingData.email == newData.email && // email should not change post-creation
                             existingData.createdAt == newData.createdAt; // createdAt immutable

      if (!immutableByOwner) {
        return false;
      }
      return isValidUserProfileData(userId, newData, false);
    }

    function isAdminUpdatingUserProfile(existingData, newData) {
      // Admin can update role, fullName, contactNumber. isSuperAdmin is special.
      // Admin cannot change uid, email, createdAt.
      // Admin cannot change isSuperAdmin for the primary super admin.
      let immutableByAdmin = existingData.uid == newData.uid &&
                             existingData.email == newData.email &&
                             existingData.createdAt == newData.createdAt;

      let superAdminUnchangedForPrimary = (existingData.email == 'pranavrathi07@gmail.com') ?
                                           (existingData.isSuperAdmin == true && newData.isSuperAdmin == true) : true;

      let onlyAllowedFieldsUpdatedByAdmin = newData.keys().hasOnly([
        'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'updatedAt',
        'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
        'applicantCategory', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'currentStage', 'teamMembers',
        'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid', 'createdAt' // Allow createdAt for completeness, though immutable
      ]);

      return immutableByAdmin &&
             superAdminUnchangedForPrimary &&
             isValidRole(newData.role) && // Admin can change roles
             isBoolean(newData.isSuperAdmin) && // Admin can change isSuperAdmin (except for primary)
             hasRequiredPersonalFields(newData) &&
             hasValidAcademicFields(newData) &&
             newData.updatedAt == request.time &&
             onlyAllowedFieldsUpdatedByAdmin;
    }

    // Idea Submission Validation Helpers
    function isValidIdeaContent(data) {
      return isNonEmptyStringMin(data.title, 5) &&
             isNonEmptyStringMin(data.problem, 10) &&
             isNonEmptyStringMin(data.solution, 10) &&
             isNonEmptyStringMin(data.uniqueness, 10) &&
             isValidCurrentStage(data.developmentStage) &&
             isValidApplicantCategory(data.applicantType) &&
             (data.teamMembers is string) && // Can be empty string
             (isStringOrNull(data.fileURL)) &&
             (isStringOrNull(data.fileName)) &&
             (isStringOrNull(data.studioLocation));
    }

    function areAdminFieldsNullOrInitial(data) {
      return data.programPhase == null &&
             (data.phase2Marks is map && data.phase2Marks.size() == 0) &&
             data.mentor == null &&
             data.cohortId == null &&
             data.rejectionRemarks == null &&
             data.rejectedByUid == null &&
             data.rejectedAt == null &&
             data.phase2PptUrl == null &&
             data.phase2PptFileName == null &&
             data.phase2PptUploadedAt == null &&
             data.nextPhaseDate == null &&
             data.nextPhaseStartTime == null &&
             data.nextPhaseEndTime == null &&
             data.nextPhaseVenue == null &&
             data.nextPhaseGuidelines == null;
    }

    function creatorIsNotUsingAdminPlaceholderForIdea(userId) {
        let userProfile = get(/databases/$(database)/documents/users/$(userId)).data;
        return userProfile.startupTitle != 'Administrative Account' &&
               userProfile.startupTitle != 'Faculty/Mentor Account';
    }

    function isValidIdeaSubmissionOnCreateOrResubmit(userId, data, isCreate) {
        let userProfile = get(/databases/$(database)/documents/users/$(userId)).data;
        let commonValidations = data.userId == userId &&
                                data.applicantDisplayName == (userProfile.displayName == null ? userProfile.fullName : userProfile.displayName) &&
                                data.applicantEmail == userProfile.email &&
                                isValidIdeaContent(data) &&
                                (data.structuredTeamMembers is list) && // Allow empty list
                                (data.teamMemberEmails is list) &&     // Allow empty list
                                data.status == 'SUBMITTED' &&
                                data.updatedAt == request.time &&
                                (isCreate ? data.submittedAt == request.time : true) && // submittedAt on create
                                areAdminFieldsNullOrInitial(data) &&
                                creatorIsNotUsingAdminPlaceholderForIdea(userId);

        return commonValidations;
    }

    function isUpdatingOwnIdeaPPT(existingData, newData) {
      return isOwner(existingData.userId) &&
             newData.userId == existingData.userId &&
             newData.title == existingData.title && // Title immutable by user
             // other core fields immutable by user
             newData.problem == existingData.problem &&
             newData.solution == existingData.solution &&
             newData.uniqueness == existingData.uniqueness &&
             newData.developmentStage == existingData.developmentStage &&
             newData.applicantType == existingData.applicantType &&
             newData.teamMembers == existingData.teamMembers &&
             newData.status == existingData.status && // Status not changed by user PPT upload
             newData.programPhase == existingData.programPhase &&
             // PPT fields are being updated
             isStringOrNull(newData.phase2PptUrl) &&
             isStringOrNull(newData.phase2PptFileName) &&
             (newData.phase2PptUploadedAt == request.time || newData.phase2PptUploadedAt == null) &&
             newData.updatedAt == request.time &&
             request.writeFields.hasAny(['phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt']);
    }

    function isUpdatingOwnIdeaTeamMembers(existingData, newData) {
      return isOwner(existingData.userId) &&
             newData.userId == existingData.userId &&
             newData.title == existingData.title && // Title immutable by user
             // Other core fields immutable
             newData.status == existingData.status &&
             newData.programPhase == existingData.programPhase &&
             (newData.structuredTeamMembers is list) &&
             (newData.teamMemberEmails is list) &&
             newData.updatedAt == request.time &&
             request.writeFields.hasAny(['structuredTeamMembers', 'teamMemberEmails', 'updatedAt']);
    }


    // Security Rules for Collections
    match /users/{userId} {
      allow read: if request.auth != null && (isOwner(userId) || isUserProfileAdmin());
      allow create: if request.auth != null && isOwner(userId) &&
                       isCreatingOwnValidProfile(userId, request.resource.data);
      allow update: if request.auth != null && (
                      (isOwner(userId) && isUpdatingOwnValidProfile(userId, resource.data, request.resource.data)) ||
                      (isUserProfileSuperAdmin() && isAdminUpdatingUserProfile(resource.data, request.resource.data))
                    );
      allow delete: if request.auth != null && isUserProfileSuperAdmin() && resource.data.email != 'pranavrathi07@gmail.com';
    }

    match /ideas/{ideaId} {
      allow read: if request.auth != null && (
                    isOwner(resource.data.userId) ||
                    isUserProfileAdmin() ||
                    (resource.data.teamMemberEmails != null && request.auth.token.email in resource.data.teamMemberEmails)
                  );

      allow create: if request.auth != null &&
                       isOwner(request.resource.data.userId) &&
                       isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, true) &&
                       request.resource.data.keys().hasOnly([
                         'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category', 'problem',
                         'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers',
                         'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId',
                         'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                         'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                         'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                         'submittedAt', 'updatedAt',
                         'fileURL', 'fileName', 'studioLocation', // Optional fields from form
                         'structuredTeamMembers', 'teamMemberEmails' // Ensure these are present
                       ]);

      allow update: if request.auth != null && (
                      // Admin: Archiving an idea
                      (
                        isUserProfileAdmin() &&
                        request.resource.data.status == 'ARCHIVED_BY_ADMIN' &&
                        resource.data.userId == request.resource.data.userId && // userId cannot change
                        resource.data.title == request.resource.data.title &&   // title cannot change
                        request.resource.data.updatedAt == request.time &&
                        request.writeFields.hasOnly([
                          'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId',
                          'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                          'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                          'updatedAt'
                        ])
                      ) ||
                      // Admin: General status/phase/mentor/cohort updates
                      (
                        isUserProfileAdmin() &&
                        resource.data.userId == request.resource.data.userId && // userId cannot change
                        request.resource.data.updatedAt == request.time &&
                        (
                          // Allowed fields for admin update
                          request.writeFields.hasAny([
                            'status', 'programPhase', 'mentor', 'cohortId',
                            'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                            'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                            'updatedAt'
                          ]) ||
                          // For phase 2 marks, specific map update
                          request.writeFields.hasAny(['phase2Marks', 'updatedAt']) ||
                          request.writeFields.hasAny(['updatedByMentorAssignerUid', 'updatedAt']) // For mentor assignment logging
                        ) &&
                        // Ensure core idea content is not changed by admin here, except title for logging
                        request.resource.data.title == resource.data.title
                      ) ||
                      // Owner: Resubmitting an archived idea (via profile save)
                      (
                        isOwner(resource.data.userId) &&
                        resource.data.status == 'ARCHIVED_BY_ADMIN' &&
                        request.resource.data.status == 'SUBMITTED' &&
                        isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, false) && // false for update
                        // Check only expected fields are being written during resubmission
                        request.writeFields.hasOnly([
                          'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category', 'problem',
                          'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers',
                          'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId',
                          'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                          'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                          'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                          'updatedAt', // submittedAt is not changed on update
                          'fileURL', 'fileName', 'studioLocation', // these could be updated from profile
                          'structuredTeamMembers', 'teamMemberEmails'
                        ])
                      ) ||
                      // Owner: Updating PPT
                      (
                        isOwner(resource.data.userId) &&
                        isUpdatingOwnIdeaPPT(resource.data, request.resource.data)
                      ) ||
                      // Owner: Updating Team Members
                      (
                        isOwner(resource.data.userId) &&
                        isUpdatingOwnIdeaTeamMembers(resource.data, request.resource.data)
                      )
                    );
      allow delete: if false; // Prevent direct deletion, force archive flow
    }

    match /announcements/{announcementId} {
      allow read: if request.auth != null; // All authenticated users can read announcements
      allow create, update, delete: if request.auth != null && isUserProfileAdmin();
    }

    match /cohorts/{cohortId} {
      allow read: if request.auth != null; // All authenticated users can read cohort info
      allow create, update, delete: if request.auth != null && isUserProfileAdmin();
    }

    match /systemSettings/{settingsId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null && isUserProfileSuperAdmin() && settingsId == 'config';
      // No delete for system settings config document
    }

    match /activityLogs/{logId} {
      allow read: if request.auth != null && isUserProfileAdmin(); // Only admins can read activity logs
      allow create: if request.auth != null; // System (via backend/functions) or admins can create
      allow update, delete: if false; // Logs should be immutable
    }
  }
}

    