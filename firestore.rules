
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isAdmin() {
      return isAuthenticated() && getUserData(request.auth.uid).role == 'ADMIN_FACULTY';
    }

    function isSuperAdmin() {
      return isAuthenticated() && isAdmin() && getUserData(request.auth.uid).isSuperAdmin == true;
    }

    function isPrimarySuperAdmin(userId) {
        return getUserData(userId).email == 'pranavrathi07@gmail.com';
    }

    // User Profile Rules
    match /users/{userId} {
      allow read: if isAuthenticated() && (isUser(userId) || isAdmin());
      allow create: if isAuthenticated() &&
                       request.auth.uid == userId &&
                       isValidUserProfileOnCreate(request.resource.data, userId, request);
      allow update: if isAuthenticated() &&
                       ( (isUser(userId) && isOwnProfileUpdateSafe(request.resource.data, resource.data, userId, request)) ||
                         (isAdmin() && isAdminProfileUpdateSafe(request.resource.data, resource.data, userId, request))
                       ) &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == resource.data.email;

      allow delete: if isAuthenticated() &&
                       ( (isUser(userId) && !isPrimarySuperAdmin(userId)) ||
                         (isSuperAdmin() && !isPrimarySuperAdmin(userId)) );
    }

    function isValidUserProfileOnCreate(data, userId, req) {
      let expectedFields = ['uid', 'email', 'displayName', 'photoURL', 'role', 'fullName', 'contactNumber', 'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers', 'enrollmentNumber', 'college', 'instituteName', 'createdAt', 'updatedAt', 'isSuperAdmin', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'];
      return data.uid == userId &&
             (data.email == req.auth.token.email || data.email == null) &&
             (data.displayName is string || data.displayName == null) &&
             (data.photoURL is string || data.photoURL == null) &&
             (data.role is string || data.role == null) &&
             data.fullName is string && data.fullName.size() > 0 &&
             data.contactNumber is string && data.contactNumber.size() > 0 &&
             (data.applicantCategory is string || data.applicantCategory == null) &&
             (data.currentStage is string || data.currentStage == null) &&
             (data.startupTitle is string || data.startupTitle == null) &&
             (data.problemDefinition is string || data.problemDefinition == null) &&
             (data.solutionDescription is string || data.solutionDescription == null) &&
             (data.uniqueness is string || data.uniqueness == null) &&
             (data.teamMembers is string || data.teamMembers == null) &&
             (data.enrollmentNumber is string || data.enrollmentNumber == null) &&
             (data.college is string || data.college == null) &&
             (data.instituteName is string || data.instituteName == null) &&
             data.createdAt == req.time &&
             data.updatedAt == req.time &&
             (data.isSuperAdmin == false || (data.email == 'pranavrathi07@gmail.com' && data.isSuperAdmin == true) ) &&
             data.isTeamMemberOnly is bool &&
             ( (data.isTeamMemberOnly == true &&
                data.startupTitle == null && data.problemDefinition == null && data.solutionDescription == null && data.uniqueness == null && data.applicantCategory == null && data.currentStage == null &&
                (data.associatedIdeaId is string || data.associatedIdeaId == null) && (data.associatedTeamLeaderUid is string || data.associatedTeamLeaderUid == null)
               ) ||
               (data.isTeamMemberOnly == false &&
                ( (data.role == 'ADMIN_FACULTY' && data.applicantCategory is string && data.currentStage is string && data.startupTitle is string && data.problemDefinition is string && data.solutionDescription is string && data.uniqueness is string) ||
                  (data.role != 'ADMIN_FACULTY' && data.applicantCategory is string && data.currentStage is string && data.startupTitle is string && data.problemDefinition is string && data.solutionDescription is string && data.uniqueness is string) ||
                  (data.role == null && data.applicantCategory == null && data.startupTitle == null) // Allows initial profile creation with minimal data
                ) &&
                data.associatedIdeaId == null && data.associatedTeamLeaderUid == null
               )
             ) &&
             data.keys().hasOnly(expectedFields);
    }

    function isOwnProfileUpdateSafe(newData, oldData, userId, req) {
      let allowedToChange = ['fullName', 'contactNumber', 'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers', 'enrollmentNumber', 'college', 'instituteName', 'photoURL', 'displayName', 'updatedAt', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'];
      return newData.uid == oldData.uid &&
             newData.email == oldData.email &&
             newData.createdAt == oldData.createdAt &&
             newData.role == oldData.role &&
             newData.isSuperAdmin == oldData.isSuperAdmin &&
             newData.keys().hasOnly(oldData.keys().toSet().union(allowedToChange.toSet()).toList()) &&
             isValidUserProfileOnCreate(newData, userId, req); // Re-check final state validity (passing request for timestamp)
    }

    function isAdminProfileUpdateSafe(newData, oldData, targetUserId, req) {
        let allPossibleFields = ['uid', 'email', 'displayName', 'photoURL', 'role', 'fullName', 'contactNumber', 'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers', 'enrollmentNumber', 'college', 'instituteName', 'createdAt', 'updatedAt', 'isSuperAdmin', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'];
        return newData.uid == oldData.uid &&
               newData.email == oldData.email &&
               newData.createdAt == oldData.createdAt &&
               isRoleChangeSafeForAdminUpdate(newData.role, oldData.role, targetUserId) &&
               isSuperAdminChangeSafeForAdminUpdate(newData.isSuperAdmin, oldData.isSuperAdmin, targetUserId, newData.email) &&
               newData.keys().hasOnly(allPossibleFields) &&
               isValidUserProfileOnCreate(newData, targetUserId, req); // Re-check final state
    }

    function isRoleChangeSafeForAdminUpdate(newRole, oldRole, targetUserId) {
      return (newRole == oldRole) ||
             (isSuperAdmin() && !isPrimarySuperAdmin(targetUserId));
    }

    function isSuperAdminChangeSafeForAdminUpdate(newIsSuperAdmin, oldIsSuperAdmin, targetUserId, targetUserEmail) {
      return (newIsSuperAdmin == oldIsSuperAdmin) ||
             (isSuperAdmin() && !isPrimarySuperAdmin(targetUserId) && (newIsSuperAdmin == true ? getUserData(targetUserId).role == 'ADMIN_FACULTY' : true) ) ||
             (isSuperAdmin() && newIsSuperAdmin == true && targetUserEmail == 'pranavrathi07@gmail.com');
    }

    // Ideas Collection
    match /ideas/{ideaId} {
      allow read: if isAuthenticated() &&
                     ( resource.data.userId == request.auth.uid ||
                       isAdmin() ||
                       (resource.data.teamMemberEmails != null && resource.data.teamMemberEmails.hasAny([request.auth.token.email])) ||
                       (resource.data.mentor != null && resource.data.mentor == getUserData(request.auth.uid).fullName)
                     );
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       isValidInitialOrResubmittedIdeaState(request.resource.data, request); // Pass request for timestamp
      allow update: if isAuthenticated() &&
                       isIdeaUpdateSafe(request.resource.data, resource.data, ideaId, request); // Pass request for timestamp
      allow delete: if false;
    }

    function isValidInitialOrResubmittedIdeaState(data, req) {
        let expectedFields = ['userId', 'applicantDisplayName', 'applicantEmail', 'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails', 'fileURL', 'fileName', 'studioLocation', 'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', 'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', 'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount', 'sanction1DisbursedAt', 'sanction2DisbursedAt', 'sanction1Expenses', 'sanction2Expenses', 'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'sanction1AppliedForNext', 'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt', 'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt', 'submittedAt', 'updatedAt', 'updatedByMentorAssignerUid'];
        return data.userId == req.auth.uid &&
               data.applicantDisplayName is string && data.applicantEmail is string &&
               data.title is string && data.title.size() > 0 &&
               data.problem is string && data.problem.size() > 0 &&
               data.solution is string && data.solution.size() > 0 &&
               data.uniqueness is string && data.uniqueness.size() > 0 &&
               data.developmentStage is string && data.applicantType is string &&
               (data.teamMembers is string || data.teamMembers == null) &&
               (data.structuredTeamMembers is list && data.structuredTeamMembers.size() == 0) &&
               (data.teamMemberEmails is list && data.teamMemberEmails.size() == 0) &&
               (data.fileURL is string || data.fileURL == null) && (data.fileName is string || data.fileName == null) && (data.studioLocation is string || data.studioLocation == null) &&
               data.status == 'SUBMITTED' && data.programPhase == null &&
               (data.phase2Marks is map && data.phase2Marks.size() == 0) &&
               data.mentor == null && data.cohortId == null &&
               data.rejectionRemarks == null && data.rejectedByUid == null && data.rejectedAt == null &&
               data.phase2PptUrl == null && data.phase2PptFileName == null && data.phase2PptUploadedAt == null &&
               data.nextPhaseDate == null && data.nextPhaseStartTime == null && data.nextPhaseEndTime == null && data.nextPhaseVenue == null && data.nextPhaseGuidelines == null &&
               data.totalFundingAllocated == null && data.sanction1Amount == null && data.sanction2Amount == null && data.sanction1DisbursedAt == null && data.sanction2DisbursedAt == null &&
               (data.sanction1Expenses is list && data.sanction1Expenses.size() == 0) && (data.sanction2Expenses is list && data.sanction2Expenses.size() == 0) &&
               data.beneficiaryName == null && data.beneficiaryAccountNo == null && data.beneficiaryBankName == null && data.beneficiaryIfscCode == null &&
               data.sanction1AppliedForNext == false && data.sanction1UtilizationStatus == 'NOT_APPLICABLE' && data.sanction1UtilizationRemarks == null && data.sanction1UtilizationReviewedBy == null && data.sanction1UtilizationReviewedAt == null &&
               data.sanction2UtilizationStatus == 'NOT_APPLICABLE' && data.sanction2UtilizationRemarks == null && data.sanction2UtilizationReviewedBy == null && data.sanction2UtilizationReviewedAt == null &&
               data.submittedAt == req.time && data.updatedAt == req.time &&
               data.keys().hasOnly(expectedFields);
    }

    function isIdeaUpdateSafe(newData, oldData, ideaId, req) {
      return newData.userId == oldData.userId &&
             newData.submittedAt == oldData.submittedAt &&
             newData.updatedAt == req.time &&
             ( (newData.userId == req.auth.uid && areIdeaOwnerFieldsSafeToUpdate(newData, oldData, req)) ||
               (isAdmin() && areIdeaAdminFieldsSafeToUpdate(newData, oldData, ideaId, req))
             ) &&
             hasOnlyIdeaFields(newData);
    }

    function hasOnlyIdeaFields(data) {
        let allowedFields = ['userId', 'applicantDisplayName', 'applicantEmail', 'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails', 'fileURL', 'fileName', 'studioLocation', 'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', 'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', 'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount', 'sanction1DisbursedAt', 'sanction2DisbursedAt', 'sanction1Expenses', 'sanction2Expenses', 'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'sanction1AppliedForNext', 'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt', 'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt', 'submittedAt', 'updatedAt', 'updatedByMentorAssignerUid'];
        return data.keys().hasOnly(allowedFields);
    }

    function areIdeaOwnerFieldsSafeToUpdate(newData, oldData, req) {
      let ownerModifiableFields = ['phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'structuredTeamMembers', 'teamMemberEmails', 'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'sanction1Expenses', 'sanction2Expenses', 'sanction1AppliedForNext', 'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers', 'fileURL', 'fileName', 'studioLocation'];
      let ownerImmutableFields = ['userId', 'applicantDisplayName', 'applicantEmail', 'submittedAt', 'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', 'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', 'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount', 'sanction1DisbursedAt', 'sanction2DisbursedAt', 'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt', 'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt', 'updatedByMentorAssignerUid'];

      let immutableFieldsUnchanged = ownerImmutableFields.all(field -> newData[field] == oldData[field]);
      let teamMembersValid = ( (newData.structuredTeamMembers is list && newData.structuredTeamMembers.size() <= 4) && (newData.teamMemberEmails is list && newData.teamMemberEmails.size() <= 4) && (newData.structuredTeamMembers.size() > 0 implies newData.teamMemberEmails.size() == newData.structuredTeamMembers.size()));
      let expensesValid = ( (newData.sanction1Expenses is list) && (newData.sanction2Expenses is list) );
      let beneficiaryValid = ( (newData.beneficiaryName is string || newData.beneficiaryName == null) && (newData.beneficiaryAccountNo is string || newData.beneficiaryAccountNo == null) && (newData.beneficiaryBankName is string || newData.beneficiaryBankName == null) && (newData.beneficiaryIfscCode is string || newData.beneficiaryIfscCode == null) );
      let applicationForS2Valid = ( newData.sanction1AppliedForNext is bool && (newData.sanction1AppliedForNext == true implies oldData.sanction1UtilizationStatus == 'APPROVED') );

      let coreIdeaDetailsLogic = (
        (oldData.status == 'ARCHIVED_BY_ADMIN' && newData.status == 'SUBMITTED') || // If resubmitting, allow these to change and status must become SUBMITTED
        (
         newData.title == oldData.title && newData.problem == oldData.problem && newData.solution == oldData.solution && newData.uniqueness == oldData.uniqueness &&
         newData.developmentStage == oldData.developmentStage && newData.applicantType == oldData.applicantType && newData.teamMembers == oldData.teamMembers &&
         newData.fileURL == oldData.fileURL && newData.fileName == oldData.fileName && newData.studioLocation == oldData.studioLocation &&
         newData.status == oldData.status // Status cannot change unless it was ARCHIVED
        )
      );
      // Validate phase2PptUploadedAt only if URL is set
      let pptUploadTimestampValid = (newData.phase2PptUrl != null implies newData.phase2PptUploadedAt == req.time) || (newData.phase2PptUrl == null && newData.phase2PptUploadedAt == oldData.phase2PptUploadedAt);


      return immutableFieldsUnchanged && teamMembersValid && expensesValid && beneficiaryValid && applicationForS2Valid && coreIdeaDetailsLogic && pptUploadTimestampValid;
    }

    function areIdeaAdminFieldsSafeToUpdate(newData, oldData, ideaId, req) {
      let coreContentFieldsUnchanged = (
        newData.title == oldData.title && newData.problem == oldData.problem && newData.solution == oldData.solution && newData.uniqueness == oldData.uniqueness &&
        newData.developmentStage == oldData.developmentStage && newData.applicantType == oldData.applicantType && newData.teamMembers == oldData.teamMembers &&
        newData.fileURL == oldData.fileURL && newData.fileName == oldData.fileName && newData.studioLocation == oldData.studioLocation &&
        newData.beneficiaryName == oldData.beneficiaryName && newData.beneficiaryAccountNo == oldData.beneficiaryAccountNo && newData.beneficiaryBankName == oldData.beneficiaryBankName && newData.beneficiaryIfscCode == oldData.beneficiaryIfscCode &&
        newData.sanction1Expenses == oldData.sanction1Expenses && newData.sanction2Expenses == oldData.sanction2Expenses &&
        newData.phase2PptUrl == oldData.phase2PptUrl && newData.phase2PptFileName == oldData.phase2PptFileName && newData.phase2PptUploadedAt == oldData.phase2PptUploadedAt &&
        newData.structuredTeamMembers == oldData.structuredTeamMembers && newData.teamMemberEmails == oldData.teamMemberEmails &&
        newData.sanction1AppliedForNext == oldData.sanction1AppliedForNext
      );
      let statusAndPhaseValid = ( newData.status is string && (newData.programPhase is string || newData.programPhase == null) && (newData.status == 'SELECTED' implies newData.programPhase != null) && (newData.status != 'SELECTED' implies newData.programPhase == null) );
      let mentorAssignmentValid = ( (newData.mentor is string || newData.mentor == null) && ( (newData.mentor != oldData.mentor) implies isSuperAdmin() && (newData.programPhase == 'COHORT' || newData.programPhase == 'INCUBATED') && newData.updatedByMentorAssignerUid == req.auth.uid ) );
      let cohortAssignmentValid = ( (newData.cohortId is string || newData.cohortId == null) && ( (newData.cohortId != oldData.cohortId) implies isSuperAdmin() && newData.programPhase == 'COHORT' ) );
      let phase2MarksValid = (newData.phase2Marks is map) && (newData.phase2Marks.keys().hasOnly(oldData.phase2Marks.keys().toSet().insert(req.auth.uid).toList())); // Admin can only add/update their own mark key
      let fundingDetailsValid = ( (newData.totalFundingAllocated is number || newData.totalFundingAllocated == null) && (newData.sanction1Amount is number || newData.sanction1Amount == null) && (newData.sanction2Amount is number || newData.sanction2Amount == null) && ( (newData.totalFundingAllocated != null && newData.sanction1Amount != null && newData.sanction2Amount != null) implies (newData.sanction1Amount + newData.sanction2Amount == newData.totalFundingAllocated) ) && ( (newData.totalFundingAllocated != oldData.totalFundingAllocated || newData.sanction1Amount != oldData.sanction1Amount || newData.sanction2Amount != oldData.sanction2Amount) implies isSuperAdmin() ) );
      let sanctionDisbursementValid = ( (newData.sanction1DisbursedAt is timestamp || newData.sanction1DisbursedAt == null) && (newData.sanction2DisbursedAt is timestamp || newData.sanction2DisbursedAt == null) && ( (newData.sanction1DisbursedAt != oldData.sanction1DisbursedAt || newData.sanction2DisbursedAt != oldData.sanction2DisbursedAt) implies isSuperAdmin() ) && ( (newData.sanction2DisbursedAt != null && newData.sanction2DisbursedAt != oldData.sanction2DisbursedAt) implies (oldData.sanction1DisbursedAt != null && oldData.sanction1UtilizationStatus == 'APPROVED') ) && ( (newData.sanction1DisbursedAt != null && newData.sanction1DisbursedAt != oldData.sanction1DisbursedAt) implies (newData.sanction1UtilizationStatus == 'PENDING' || newData.sanction1UtilizationStatus == oldData.sanction1UtilizationStatus) ) && ( (newData.sanction2DisbursedAt != null && newData.sanction2DisbursedAt != oldData.sanction2DisbursedAt) implies (newData.sanction2UtilizationStatus == 'PENDING' || newData.sanction2UtilizationStatus == oldData.sanction2UtilizationStatus) ) );
      let sanctionReviewValid = ( (newData.sanction1UtilizationStatus is string) && (newData.sanction2UtilizationStatus is string) && (newData.sanction1UtilizationRemarks is string || newData.sanction1UtilizationRemarks == null) && (newData.sanction2UtilizationRemarks is string || newData.sanction2UtilizationRemarks == null) && (newData.sanction1UtilizationReviewedBy is string || newData.sanction1UtilizationReviewedBy == null) && (newData.sanction2UtilizationReviewedBy is string || newData.sanction2UtilizationReviewedBy == null) && (newData.sanction1UtilizationReviewedAt is timestamp || newData.sanction1UtilizationReviewedAt == null) && (newData.sanction2UtilizationReviewedAt is timestamp || newData.sanction2UtilizationReviewedAt == null) && ( (newData.sanction1UtilizationStatus != oldData.sanction1UtilizationStatus || newData.sanction1UtilizationRemarks != oldData.sanction1UtilizationRemarks) implies (isSuperAdmin() && newData.sanction1UtilizationReviewedBy == req.auth.uid && newData.sanction1UtilizationReviewedAt == req.time) ) && ( (newData.sanction2UtilizationStatus != oldData.sanction2UtilizationStatus || newData.sanction2UtilizationRemarks != oldData.sanction2UtilizationRemarks) implies (isSuperAdmin() && newData.sanction2UtilizationReviewedBy == req.auth.uid && newData.sanction2UtilizationReviewedAt == req.time) ) );
      let rejectionFieldsValid = ( (newData.rejectionRemarks is string || newData.rejectionRemarks == null) && (newData.rejectedByUid is string || newData.rejectedByUid == null) && (newData.rejectedAt is timestamp || newData.rejectedAt == null) && (newData.status == 'NOT_SELECTED' implies (newData.rejectionRemarks != null && newData.rejectedByUid == req.auth.uid && newData.rejectedAt == req.time)) );
      let nextPhaseDetailsUnchangedByAdmin = ( newData.nextPhaseDate == oldData.nextPhaseDate && newData.nextPhaseStartTime == oldData.nextPhaseStartTime && newData.nextPhaseEndTime == oldData.nextPhaseEndTime && newData.nextPhaseVenue == oldData.nextPhaseVenue && newData.nextPhaseGuidelines == oldData.nextPhaseGuidelines);

      // Admin sets next phase details ONLY when status becomes SELECTED and phase is set appropriately
      let nextPhaseDetailsSetByAdminCorrectly = (
        ( (newData.status == 'SELECTED' && newData.status != oldData.status) || (newData.programPhase != oldData.programPhase && newData.status == 'SELECTED') ) implies
        (
          (newData.nextPhaseDate is timestamp || newData.nextPhaseDate == null) &&
          (newData.nextPhaseStartTime is string || newData.nextPhaseStartTime == null) &&
          (newData.nextPhaseEndTime is string || newData.nextPhaseEndTime == null) &&
          (newData.nextPhaseVenue is string || newData.nextPhaseVenue == null) &&
          (newData.nextPhaseGuidelines is string || newData.nextPhaseGuidelines == null)
        )
      ) || nextPhaseDetailsUnchangedByAdmin; // Or they remained unchanged

      return coreContentFieldsUnchanged && statusAndPhaseValid && mentorAssignmentValid && cohortAssignmentValid && phase2MarksValid && fundingDetailsValid && sanctionDisbursementValid && sanctionReviewValid && rejectionFieldsValid && nextPhaseDetailsSetByAdminCorrectly;
    }

    // Announcements Collection
    match /announcements/{announcementId} {
      function isTargetedToUser(announcementData) {
          return (announcementData.targetAudience == 'ALL') ||
                 (announcementData.targetAudience == 'SPECIFIC_COHORT' && announcementData.cohortId != null && isAdmin());
      }
      allow read: if isAuthenticated() && (isAdmin() || isTargetedToUser(resource.data));
      allow create: if isAuthenticated() && isAdmin() &&
                       hasOnlyAnnouncementFields(request.resource.data) &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;
      allow update: if isAuthenticated() && isAdmin() &&
                       hasOnlyAnnouncementFields(request.resource.data) &&
                       request.resource.data.createdByUid == resource.data.createdByUid && // Cannot change creator
                       request.resource.data.createdAt == resource.data.createdAt && // Cannot change creation time
                       request.resource.data.updatedAt == request.time;
      allow delete: if isAuthenticated() && isAdmin();
    }

    function hasOnlyAnnouncementFields(data) {
        let allowedFields = ['title', 'content', 'isUrgent', 'targetAudience', 'cohortId', 'attachmentURL', 'attachmentName', 'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt'];
        return data.keys().hasOnly(allowedFields);
    }

    // Cohorts Collection
    match /cohorts/{cohortId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isAdmin() &&
                       hasOnlyCohortFields(request.resource.data) &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.ideaIds.size() == 0 && // Must be empty on create
                       request.resource.data.schedule.size() == 0;  // Must be empty on create
      allow update: if isAuthenticated() && isAdmin() &&
                       hasOnlyCohortFields(request.resource.data) &&
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.updatedAt == request.time &&
                       // Admin can add/remove ideaIds and update schedule
                       (request.resource.data.ideaIds is list) &&
                       (request.resource.data.schedule is list);
      allow delete: if isAuthenticated() && isAdmin() && resource.data.ideaIds.size() == 0; // Can only delete if no ideas assigned
    }

    function hasOnlyCohortFields(data) {
        let allowedFields = ['name', 'startDate', 'endDate', 'batchSize', 'ideaIds', 'schedule', 'createdAt', 'createdByUid', 'creatorDisplayName', 'updatedAt'];
        return data.keys().hasOnly(allowedFields);
    }

    // System Settings
    match /systemSettings/config {
      allow read: if isAuthenticated();
      allow update: if isAuthenticated() && isAdmin() &&
                       hasOnlySystemSettingsFields(request.resource.data) &&
                       request.resource.data.updatedByUid == request.auth.uid &&
                       request.resource.data.updatedAt == request.time;
    }

    function hasOnlySystemSettingsFields(data) {
        let allowedFields = ['portalName', 'maintenanceMode', 'allowNewRegistrations', 'defaultCohortSize', 'updatedAt', 'updatedByUid'];
        return data.keys().hasOnly(allowedFields);
    }

    // Activity Logs
    match /activityLogs/{logId} {
      allow read: if isAuthenticated() && isAdmin();
      allow create: if isAuthenticated() && // More specific: request.auth.uid == request.resource.data.actorUid
                       hasOnlyActivityLogFields(request.resource.data) &&
                       request.resource.data.timestamp == request.time;
      allow update, delete: if false;
    }

    function hasOnlyActivityLogFields(data) {
        let allowedFields = ['timestamp', 'actorUid', 'actorDisplayName', 'action', 'target', 'details'];
        return data.keys().hasOnly(allowedFields);
    }
  }
}

    