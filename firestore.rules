
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isSuperAdmin() {
      return isSignedIn() && (request.auth.token.isSuperAdmin == true || request.auth.email == 'pranavrathi07@gmail.com');
    }

    function isAdmin() {
      return isSignedIn() && request.auth.token.role == 'ADMIN_FACULTY';
    }

    function isUserProfileDataValid(data) {
      return data.uid is string &&
             (data.email == null || data.email is string) &&
             (data.displayName == null || data.displayName is string) &&
             (data.photoURL == null || data.photoURL is string) &&
             (data.role == null || data.role in ['STUDENT', 'EXTERNAL_USER', 'ADMIN_FACULTY']) &&
             data.fullName is string && data.fullName.size() > 0 &&
             data.contactNumber is string && data.contactNumber.size() >= 10 &&
             (data.applicantCategory == null || data.applicantCategory in ['PARUL_STUDENT', 'PARUL_STAFF', 'PARUL_ALUMNI', 'OTHERS']) &&
             (data.currentStage == null || data.currentStage in ['IDEA', 'PROTOTYPE_STAGE', 'STARTUP_STAGE']) &&
             (data.startupTitle == null || (data.startupTitle is string && data.startupTitle.size() > 0)) &&
             (data.problemDefinition == null || (data.problemDefinition is string && data.problemDefinition.size() > 0)) &&
             (data.solutionDescription == null || (data.solutionDescription is string && data.solutionDescription.size() > 0)) &&
             (data.uniqueness == null || (data.uniqueness is string && data.uniqueness.size() > 0)) &&
             (data.enrollmentNumber == null || data.enrollmentNumber is string) &&
             (data.college == null || data.college is string) &&
             (data.instituteName == null || data.instituteName is string) &&
             data.isSuperAdmin is bool &&
             (data.isTeamMemberOnly == null || data.isTeamMemberOnly is bool) &&
             (data.associatedIdeaId == null || data.associatedIdeaId is string) &&
             (data.associatedTeamLeaderUid == null || data.associatedTeamLeaderUid is string) &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp && data.updatedAt >= data.createdAt;
    }

    function isValidIdeaData(data) {
      return data.userId is string &&
             data.title is string && data.title.size() > 0 &&
             (data.category == null || data.category is string) && // Allow null for category initially
             data.problem is string && data.problem.size() > 0 &&
             data.solution is string && data.solution.size() > 0 &&
             data.uniqueness is string && data.uniqueness.size() > 0 &&
             (data.developmentStage is string && data.developmentStage in ['IDEA', 'PROTOTYPE_STAGE', 'STARTUP_STAGE']) &&
             (data.applicantType == null || data.applicantType in ['PARUL_STUDENT', 'PARUL_STAFF', 'PARUL_ALUMNI', 'OTHERS']) &&
             (data.teamMembers == null || data.teamMembers is string) &&
             (data.structuredTeamMembers == null || data.structuredTeamMembers is list) &&
             (data.teamMemberEmails == null || data.teamMemberEmails is list) &&
             (data.fileURL == null || data.fileURL is string) &&
             (data.fileName == null || data.fileName is string) &&
             (data.studioLocation == null || data.studioLocation in ['SURAT', 'RAJKOT', 'BARODA', 'AHMEDABAD']) &&
             (data.status is string && data.status in ['SUBMITTED', 'UNDER_REVIEW', 'IN_EVALUATION', 'SELECTED', 'NOT_SELECTED', 'ARCHIVED_BY_ADMIN']) &&
             (data.programPhase == null || data.programPhase in ['PHASE_1', 'PHASE_2', 'COHORT', 'INCUBATED']) &&
             (data.phase2Marks == null || data.phase2Marks is map) &&
             (data.mentor == null || data.mentor is string) && // MentorName is a string
             (data.cohortId == null || data.cohortId is string) &&
             (data.rejectionRemarks == null || data.rejectionRemarks is string) &&
             (data.rejectedByUid == null || data.rejectedByUid is string) &&
             (data.rejectedAt == null || data.rejectedAt is timestamp) &&
             (data.phase2PptUrl == null || data.phase2PptUrl is string) &&
             (data.phase2PptFileName == null || data.phase2PptFileName is string) &&
             (data.phase2PptUploadedAt == null || data.phase2PptUploadedAt is timestamp) &&
             (data.isOutlineAIGenerated == null || data.isOutlineAIGenerated is bool) &&
             (data.nextPhaseDate == null || data.nextPhaseDate is timestamp) &&
             (data.nextPhaseStartTime == null || data.nextPhaseStartTime is string) &&
             (data.nextPhaseEndTime == null || data.nextPhaseEndTime is string) &&
             (data.nextPhaseVenue == null || data.nextPhaseVenue is string) &&
             (data.nextPhaseGuidelines == null || data.nextPhaseGuidelines is string) &&
             (data.fundingSource == null || data.fundingSource is string) &&
             (data.totalFundingAllocated == null || data.totalFundingAllocated is number) &&
             (data.sanction1Amount == null || data.sanction1Amount is number) &&
             (data.sanction2Amount == null || data.sanction2Amount is number) &&
             (data.sanction1DisbursedAt == null || data.sanction1DisbursedAt is timestamp) &&
             (data.sanction2DisbursedAt == null || data.sanction2DisbursedAt is timestamp) &&
             (data.sanction1Expenses == null || data.sanction1Expenses is list) &&
             (data.sanction2Expenses == null || data.sanction2Expenses is list) &&
             (data.beneficiaryName == null || data.beneficiaryName is string) &&
             (data.beneficiaryAccountNo == null || data.beneficiaryAccountNo is string) &&
             (data.beneficiaryBankName == null || data.beneficiaryBankName is string) &&
             (data.beneficiaryIfscCode == null || data.beneficiaryIfscCode is string) &&
             (data.beneficiaryAccountType == null || data.beneficiaryAccountType in ['SAVINGS', 'CURRENT']) &&
             (data.beneficiaryCity == null || data.beneficiaryCity is string) &&
             (data.beneficiaryBranchName == null || data.beneficiaryBranchName is string) &&
             (data.sanction1AppliedForNext == null || data.sanction1AppliedForNext is bool) &&
             (data.sanction1UtilizationStatus == null || data.sanction1UtilizationStatus in ['PENDING', 'APPROVED', 'REJECTED', 'NOT_APPLICABLE']) &&
             (data.sanction1UtilizationRemarks == null || data.sanction1UtilizationRemarks is string) &&
             (data.sanction1UtilizationReviewedBy == null || data.sanction1UtilizationReviewedBy is string) &&
             (data.sanction1UtilizationReviewedAt == null || data.sanction1UtilizationReviewedAt is timestamp) &&
             (data.sanction2UtilizationStatus == null || data.sanction2UtilizationStatus in ['PENDING', 'APPROVED', 'REJECTED', 'NOT_APPLICABLE']) &&
             (data.sanction2UtilizationRemarks == null || data.sanction2UtilizationRemarks is string) &&
             (data.sanction2UtilizationReviewedBy == null || data.sanction2UtilizationReviewedBy is string) &&
             (data.sanction2UtilizationReviewedAt == null || data.sanction2UtilizationReviewedAt is timestamp) &&
             data.submittedAt is timestamp &&
             data.updatedAt is timestamp && data.updatedAt >= data.submittedAt &&
             (data.createdAt == null || data.createdAt is timestamp) && // createdAt might not exist on older docs
             (data.applicantDisplayName == null || data.applicantDisplayName is string) &&
             (data.applicantEmail == null || data.applicantEmail is string);
    }

    function isIdeaDataInternallyConsistent(data) {
      // Check if structuredTeamMembers have email
      let validTeamMembers = true;
      if (data.structuredTeamMembers != null && data.structuredTeamMembers is list) {
        // This direct iteration is not supported. We imply this check by client-side validation.
        // For rules, we might check size or presence, but not deep content validation like this easily.
        // Let's assume client ensures emails are present if member objects are.
      }
      // Check if teamMemberEmails list contains only strings
      let validTeamMemberEmails = true;
      if (data.teamMemberEmails != null && data.teamMemberEmails is list) {
          // This type of check is also hard. Firestore rules are not for deep array content validation.
      }
      return validTeamMembers && validTeamMemberEmails &&
             (data.fundingSource == null || data.fundingSource in ['SSIP_PIET', 'SSIP_PARUL_UNIVERSITY', 'SSIP_PIMSR', 'SSIP_PHYSIOTHERAPY']);
    }

    function isValidInitialOrResubmittedIdeaState(data) {
      return data.status == 'SUBMITTED' &&
             (data.programPhase == null) && // Should be null on initial submission
             (data.phase2Marks == null || data.phase2Marks.keys().size() == 0) &&
             (data.mentor == null) &&
             (data.cohortId == null) &&
             (data.rejectionRemarks == null) &&
             (data.rejectedByUid == null) &&
             (data.rejectedAt == null) &&
             (data.phase2PptUrl == null) &&
             (data.phase2PptFileName == null) &&
             (data.phase2PptUploadedAt == null) &&
             (data.isOutlineAIGenerated == false) &&
             (data.nextPhaseDate == null) &&
             (data.nextPhaseStartTime == null) &&
             (data.nextPhaseEndTime == null) &&
             (data.nextPhaseVenue == null) &&
             (data.nextPhaseGuidelines == null) &&
             (data.fundingSource == null) &&
             (data.totalFundingAllocated == null) &&
             (data.sanction1Amount == null) &&
             (data.sanction2Amount == null) &&
             (data.sanction1DisbursedAt == null) &&
             (data.sanction2DisbursedAt == null) &&
             (data.sanction1Expenses == null || data.sanction1Expenses.size() == 0) &&
             (data.sanction2Expenses == null || data.sanction2Expenses.size() == 0) &&
             (data.beneficiaryName == null) &&
             (data.beneficiaryAccountNo == null) &&
             (data.beneficiaryBankName == null) &&
             (data.beneficiaryIfscCode == null) &&
             (data.beneficiaryAccountType == null) &&
             (data.beneficiaryCity == null) &&
             (data.beneficiaryBranchName == null) &&
             (data.sanction1AppliedForNext == false) &&
             (data.sanction1UtilizationStatus == 'NOT_APPLICABLE') &&
             (data.sanction1UtilizationRemarks == null) &&
             (data.sanction1UtilizationReviewedBy == null) &&
             (data.sanction1UtilizationReviewedAt == null) &&
             (data.sanction2UtilizationStatus == 'NOT_APPLICABLE') &&
             (data.sanction2UtilizationRemarks == null) &&
             (data.sanction2UtilizationReviewedBy == null) &&
             (data.sanction2UtilizationReviewedAt == null) &&
             isIdeaDataInternallyConsistent(data);
    }

    function isOwnerMakingAllowedChanges(existingData, newData) {
      let changedKeys = newData.diff(existingData).affectedKeys();
      // Owner can update idea details, PPT, team members (via specific functions ideally), and beneficiary details.
      let allowedFields = [
        'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers', // Basic editable text
        'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', // PPT upload
        'structuredTeamMembers', 'teamMemberEmails', // Team management
        'fileURL', 'fileName', 'studioLocation', // Initial optional fields
        'updatedAt', 'isOutlineAIGenerated', // System & AI flag
        'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName', // Beneficiary details
        'sanction1Expenses', 'sanction2Expenses', // User adds expenses
        'sanction1AppliedForNext' // User applies for next sanction
      ];
      return changedKeys.hasOnly(allowedFields) &&
             // Certain fields should only be updatable if the idea is in a specific state
             (newData.phase2PptUrl == existingData.phase2PptUrl || existingData.programPhase == 'PHASE_2') && // Can only upload PPT if in Phase 2
             // If status is ARCHIVED_BY_ADMIN, only a limited set of core fields should be changeable by user to resubmit
             (existingData.status != 'ARCHIVED_BY_ADMIN' ||
                (changedKeys.hasOnly(['title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers', 'updatedAt', 'status']) && newData.status == 'SUBMITTED')
             ) &&
             // Ensure beneficiary details can only be added/updated if the idea is in INCUBATED phase
             (
                (
                    !changedKeys.hasAny(['beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName'])
                ) ||
                (
                    existingData.programPhase == 'INCUBATED'
                )
             ) &&
             // Ensure expenses can only be added if the idea is in INCUBATED phase and respective sanction is disbursed
             (
                (
                    !changedKeys.hasAny(['sanction1Expenses'])
                ) ||
                (
                    existingData.programPhase == 'INCUBATED' && existingData.sanction1DisbursedAt != null
                )
             ) &&
             (
                (
                    !changedKeys.hasAny(['sanction2Expenses'])
                ) ||
                (
                    existingData.programPhase == 'INCUBATED' && existingData.sanction2DisbursedAt != null
                )
             ) &&
             // Ensure user can apply for next sanction only if S1 is approved
             (
                (
                    !changedKeys.hasAny(['sanction1AppliedForNext']) || newData.sanction1AppliedForNext == false
                ) ||
                (
                    existingData.programPhase == 'INCUBATED' && existingData.sanction1UtilizationStatus == 'APPROVED'
                )
             );
    }

    function isAdminUpdatingAllowedFields(existingData, newData) {
      let changedKeys = newData.diff(existingData).affectedKeys();
      let allowedFields = [
        'status', 'programPhase', 'mentor', 'cohortId', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
        'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
        'updatedAt', 'phase2Marks', 'isOutlineAIGenerated',
        'fundingSource', 'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount',
        'sanction1DisbursedAt', 'sanction2DisbursedAt',
        'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt',
        'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt',
        'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', // Admins might need to clear this if status changes
        'sanction1Expenses', 'sanction2Expenses', // Admins might need to clear/reset
        'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode', 'beneficiaryAccountType', 'beneficiaryCity', 'beneficiaryBranchName', // Admins might need to clear/reset
        'sanction1AppliedForNext' // Admins might need to clear/reset
      ];
      return changedKeys.hasOnly(allowedFields);
    }


    // Users Collection
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isUser(userId) &&
                       isUserProfileDataValid(request.resource.data) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.uid == userId &&
                       (request.resource.data.email == request.auth.token.email || request.resource.data.email == null && request.auth.token.email == null) &&
                       ( // If it's a team member only profile being created
                         (request.resource.data.isTeamMemberOnly == true &&
                          request.resource.data.startupTitle == null && // Ensure no idea fields
                          request.resource.data.associatedIdeaId != null && // Must have associated idea
                          request.resource.data.associatedTeamLeaderUid != null // Must have associated leader
                         ) ||
                         // If it's a regular user/idea owner profile
                         ( (request.resource.data.isTeamMemberOnly == false || request.resource.data.isTeamMemberOnly == null) &&
                           request.resource.data.associatedIdeaId == null && // No team member fields
                           request.resource.data.associatedTeamLeaderUid == null
                         )
                       );
      allow update: if (isUser(userId) || isSuperAdmin()) &&
                       isUserProfileDataValid(request.resource.data) &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.uid == resource.data.uid && // Cannot change uid
                       request.resource.data.email == resource.data.email && // Cannot change email
                       request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis() && // Cannot change creation date
                       (isSuperAdmin() || request.resource.data.role == resource.data.role) && // Only super admin can change role
                       (isSuperAdmin() || request.resource.data.isSuperAdmin == resource.data.isSuperAdmin) && // Only super admin can change super admin status
                       (request.resource.data.isTeamMemberOnly == resource.data.isTeamMemberOnly) && // Cannot change isTeamMemberOnly status
                       (request.resource.data.associatedIdeaId == resource.data.associatedIdeaId) &&
                       (request.resource.data.associatedTeamLeaderUid == resource.data.associatedTeamLeaderUid);

      allow delete: if isSuperAdmin() && request.auth.uid != userId; // Super admin can delete others, not themselves via this rule
    }

    // Ideas Collection
    match /ideas/{ideaId} {
      allow read: if isSignedIn(); // All signed-in users can read ideas (e.g., team members, admins)

      allow create: if request.auth != null &&
                       let newData = request.resource.data;
                       let userId = request.auth.uid;
                       userId == newData.userId && // User can only create ideas for themselves
                       isValidIdeaData(newData) &&
                       isValidInitialOrResubmittedIdeaState(newData); // Checks initial default values


      allow update: if request.auth != null &&
                       let existingData = resource.data;
                       let newData = request.resource.data;
                       let userId = request.auth.uid;
                       let isAdminUser = isAdmin(); // Use isAdmin() helper
                       let isSuperAdminUser = isSuperAdmin(); // Use isSuperAdmin() helper

                       ( // Case 1: Owner making allowed changes
                         userId == existingData.userId &&
                         isOwnerMakingAllowedChanges(existingData, newData) &&
                         isValidIdeaData(newData) && // Validate final state
                         isIdeaDataInternallyConsistent(newData)
                       ) ||
                       ( // Case 2: Regular Admin (not Super Admin) making allowed changes
                         isAdminUser && !isSuperAdminUser &&
                         isAdminUpdatingAllowedFields(existingData, newData) &&
                         isIdeaDataInternallyConsistent(newData) &&
                         isValidIdeaData(newData)
                       ) ||
                       ( // Case 3: Super Admin making changes (more permissive regarding *which* fields can change)
                         isSuperAdminUser &&
                         isIdeaDataInternallyConsistent(newData) && // Still check for data integrity
                         isValidIdeaData(newData) // Still check for overall validity
                       ) &&
                       // Immutable fields check - applies to everyone, including admins and super admins
                       newData.userId == existingData.userId &&
                       newData.submittedAt.toMillis() == existingData.submittedAt.toMillis() &&
                       newData.createdAt.toMillis() == existingData.createdAt.toMillis() &&
                       (newData.applicantEmail == existingData.applicantEmail || (newData.applicantEmail == null && existingData.applicantEmail == null)) &&
                       (newData.applicantDisplayName == existingData.applicantDisplayName || (newData.applicantDisplayName == null && existingData.applicantDisplayName == null));

      allow delete: if false; // No direct client-side deletion of ideas. Handled by admin archiving or functions.
    }

    // Announcements Collection
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isAdmin() &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;
      allow update: if isAdmin() &&
                       request.resource.data.createdByUid == resource.data.createdByUid && // Cannot change creator
                       request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis() && // Cannot change creation time
                       request.resource.data.updatedAt == request.time;
      allow delete: if isAdmin();
    }

    // Cohorts Collection
    match /cohorts/{cohortId} {
        allow read: if isSignedIn();
        allow create: if isSuperAdmin() && // Only super admins can create cohorts
                       request.resource.data.createdByUid == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.ideaIds is list && request.resource.data.ideaIds.size() == 0 && // Must be empty on creation
                       request.resource.data.schedule is list && request.resource.data.schedule.size() == 0; // Must be empty on creation
        allow update: if isSuperAdmin() && // Only super admins can update cohorts (assigning ideas, schedule)
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis() &&
                       request.resource.data.updatedAt == request.time;
        allow delete: if isSuperAdmin() && resource.data.ideaIds.size() == 0; // Only delete if no ideas assigned
    }

    // System Settings Collection
    match /systemSettings/{settingsId} {
        allow read: if isSignedIn(); // All signed-in users might need to read some settings implicitly.
        allow create: if isSuperAdmin() && // Only super admin can create initial settings document
                         settingsId == 'config' &&
                         request.resource.data.updatedAt == request.time &&
                         request.resource.data.updatedByUid == request.auth.uid;
        allow update: if isSuperAdmin() && // Only super admin can update settings
                         settingsId == 'config' &&
                         request.resource.data.updatedAt == request.time &&
                         request.resource.data.updatedByUid == request.auth.uid;
        allow delete: if false; // Settings should not be deleted
    }

    // Activity Logs Collection
    match /activityLogs/{logId} {
      allow read: if isAdmin(); // Only admins can read activity logs
      allow write: if false; // Logs are written server-side or by trusted client (e.g., specific functions)
    }
  }
}

    