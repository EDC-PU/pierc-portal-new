
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isSuperAdmin(userId) {
      return isSignedIn() && getUserData(userId).isSuperAdmin == true;
    }

    function isAdmin(userId) {
      return isSignedIn() && getUserData(userId).role == 'ADMIN_FACULTY';
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function getIdeaData(ideaId) {
      return get(/databases/$(database)/documents/ideas/$(ideaId)).data;
    }
    
    function isTeamMemberOfIdeaByEmail(ideaId, userEmail) {
      let idea = getIdeaData(ideaId);
      return idea.teamMemberEmails.hasAny([userEmail]);
    }

    function isTeamMemberOfIdeaByUID(ideaId, userId) {
      // This assumes structuredTeamMembers contains objects with an 'id' field matching user UIDs
      let idea = getIdeaData(ideaId);
      return idea.structuredTeamMembers.filter(member => member.id == userId).size() > 0;
    }

    // Validation for User Profile creation
    function isCreatingOwnValidProfile(userId, req, res) {
      let commonValidations = isSignedIn()
        && req.auth.uid == userId
        && res.data.uid == userId
        && res.data.email == req.auth.token.email
        && res.data.fullName is string && res.data.fullName.size() > 0
        && res.data.contactNumber is string && res.data.contactNumber.size() >= 10
        && res.data.createdAt == request.time
        && res.data.updatedAt == request.time
        && (res.data.role == 'STUDENT' || res.data.role == 'EXTERNAL_USER' || (res.data.role == 'ADMIN_FACULTY' && req.auth.token.email == 'pranavrathi07@gmail.com'))
        && (res.data.isSuperAdmin == false || (res.data.isSuperAdmin == true && req.auth.token.email == 'pranavrathi07@gmail.com'));

      if (!commonValidations) return false;

      if (res.data.isTeamMemberOnly == true) {
        return res.data.associatedIdeaId is string && res.data.associatedIdeaId.size() > 0
               && res.data.associatedTeamLeaderUid is string && res.data.associatedTeamLeaderUid.size() > 0
               && res.data.startupTitle == null
               && res.data.problemDefinition == null
               && res.data.solutionDescription == null
               && res.data.uniqueness == null
               && res.data.applicantCategory == null
               && res.data.currentStage == null
               && res.data.teamMembers == null;
      } else { // Idea Owner or Admin
        return res.data.startupTitle is string && res.data.startupTitle.size() > 0
               && res.data.problemDefinition is string && res.data.problemDefinition.size() > 0
               && res.data.solutionDescription is string && res.data.solutionDescription.size() > 0
               && res.data.uniqueness is string && res.data.uniqueness.size() > 0
               && res.data.applicantCategory is string
               && res.data.currentStage is string
               && res.data.teamMembers is string // Can be empty string
               && res.data.associatedIdeaId == null
               && res.data.associatedTeamLeaderUid == null;
      }
    }

    // Validation for User Profile update
    function isUpdatingOwnValidProfile(userId, req, res) {
        let existingProfile = getUserData(userId);
        return isSignedIn()
            && req.auth.uid == userId
            && res.data.uid == userId // Cannot change UID
            && res.data.email == existingProfile.email // Cannot change email
            && res.data.role == existingProfile.role // User cannot change own role
            && res.data.isSuperAdmin == existingProfile.isSuperAdmin // User cannot change own super admin status
            && res.data.createdAt == existingProfile.createdAt // Cannot change createdAt
            && res.data.updatedAt == request.time
            && res.data.fullName is string && res.data.fullName.size() > 0
            && res.data.contactNumber is string && res.data.contactNumber.size() >= 10
            && (existingProfile.isTeamMemberOnly == true 
                ? ( // If team member, cannot set idea fields
                    res.data.startupTitle == null &&
                    res.data.problemDefinition == null &&
                    res.data.solutionDescription == null &&
                    res.data.uniqueness == null &&
                    res.data.applicantCategory == null &&
                    res.data.currentStage == null &&
                    res.data.teamMembers == null &&
                    res.data.associatedIdeaId == existingProfile.associatedIdeaId && // Cannot change association
                    res.data.associatedTeamLeaderUid == existingProfile.associatedTeamLeaderUid // Cannot change association
                  )
                : ( // If idea owner, can update idea fields, association fields must remain null
                    res.data.startupTitle is string && res.data.startupTitle.size() > 0 &&
                    res.data.problemDefinition is string && res.data.problemDefinition.size() > 0 &&
                    res.data.solutionDescription is string && res.data.solutionDescription.size() > 0 &&
                    res.data.uniqueness is string && res.data.uniqueness.size() > 0 &&
                    res.data.applicantCategory is string &&
                    res.data.currentStage is string &&
                    res.data.teamMembers is string &&
                    res.data.associatedIdeaId == null &&
                    res.data.associatedTeamLeaderUid == null
                  )
            );
    }

    // Validation for Idea Creation
    function isCreatingOwnIdea(userId, ideaData) {
      let userProfile = getUserData(userId);
      return isSignedIn()
             && request.auth.uid == userId
             && userProfile.isTeamMemberOnly == false // Must be an idea owner
             && ideaData.userId == userId
             && ideaData.title is string && ideaData.title.size() > 0
             && ideaData.problem is string && ideaData.problem.size() > 0
             && ideaData.solution is string && ideaData.solution.size() > 0
             && ideaData.uniqueness is string && ideaData.uniqueness.size() > 0
             && ideaData.developmentStage is string
             && ideaData.applicantType is string
             && ideaData.status == 'SUBMITTED'
             && ideaData.programPhase == null
             && ideaData.structuredTeamMembers is list && ideaData.structuredTeamMembers.size() == 0
             && ideaData.teamMemberEmails is list && ideaData.teamMemberEmails.size() == 0
             && ideaData.submittedAt == request.time
             && ideaData.updatedAt == request.time
             && ideaData.phase2Marks is map && ideaData.phase2Marks.size() == 0 // Ensure phase2Marks is an empty map
             // Ensure only allowed fields are present at creation
             && request.resource.data.keys().hasOnly([
                  'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'problem', 'solution', 'uniqueness',
                  'developmentStage', 'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
                  'status', 'programPhase', 'submittedAt', 'updatedAt', 'category', 'phase2Marks'
                ]);
    }
    
    function isValidScheduleEntry(entry) {
        return entry.id is string && entry.id.size() > 0 &&
               entry.date is string && entry.date.size() > 0 &&
               entry.day is string && entry.day.size() > 0 &&
               entry.time is string && entry.time.size() > 0 &&
               entry.category is string && entry.category.size() > 0 &&
               entry.topicActivity is string && entry.topicActivity.size() > 0 &&
               (entry.content == null || entry.content is string) &&
               (entry.speakerVenue == null || entry.speakerVenue is string);
    }

    function isValidScheduleArray(schedule) {
        return schedule is list && schedule.size() <= 50 && // Max 50 entries per schedule
               schedule.filter(entry -> !isValidScheduleEntry(entry)).size() == 0;
    }


    // Rules for /users collection
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isCreatingOwnValidProfile(userId, request, request.resource);
      allow update: if isUpdatingOwnValidProfile(userId, request, request.resource) || isAdmin(request.auth.uid); // Admins can update any profile
      allow delete: if isSuperAdmin(request.auth.uid) && request.auth.uid != userId; // Super admin can delete others, not self through this rule
    }

    // Rules for /ideas collection
    match /ideas/{ideaId} {
      allow read: if isSignedIn();
      allow create: if isCreatingOwnIdea(request.auth.uid, request.resource.data);
      allow update: if isAdmin(request.auth.uid) || 
                      (isOwner(resource.data.userId) && 
                        (
                          // Owner can update PPT details
                          (request.resource.data.phase2PptUrl is string && request.resource.data.phase2PptFileName is string && request.resource.data.phase2PptUploadedAt == request.time) ||
                          // Owner can update team members
                          (request.resource.data.structuredTeamMembers is list && request.resource.data.teamMemberEmails is list)
                        ) &&
                        // Owner cannot change these critical fields
                        request.resource.data.status == resource.data.status &&
                        request.resource.data.programPhase == resource.data.programPhase &&
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.title == resource.data.title
                      );
      allow delete: if isAdmin(request.auth.uid);
    }

    // Rules for /announcements collection
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create, update, delete: if isAdmin(request.auth.uid);
    }

    // Rules for /cohorts collection
    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isAdmin(request.auth.uid)
                     && request.resource.data.name is string && request.resource.data.name.size() > 0
                     && request.resource.data.startDate is timestamp
                     && request.resource.data.endDate is timestamp && request.resource.data.endDate > request.resource.data.startDate
                     && request.resource.data.batchSize is number && request.resource.data.batchSize > 0
                     && request.resource.data.ideaIds is list && request.resource.data.ideaIds.size() == 0
                     && request.resource.data.schedule is list && request.resource.data.schedule.size() == 0
                     && request.resource.data.createdByUid == request.auth.uid
                     && request.resource.data.createdAt == request.time;
      allow update: if isAdmin(request.auth.uid)
                      && (
                           // Allow general updates to name, dates, batchSize
                           (request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                            request.resource.data.startDate is timestamp &&
                            request.resource.data.endDate is timestamp && request.resource.data.endDate > request.resource.data.startDate &&
                            request.resource.data.batchSize is number && request.resource.data.batchSize > 0 &&
                            request.resource.data.keys().hasAny(['name', 'startDate', 'endDate', 'batchSize', 'updatedAt'])
                           ) ||
                           // Allow updates to ideaIds (assigning/unassigning ideas)
                           (request.resource.data.ideaIds is list &&
                            request.resource.data.keys().hasAny(['ideaIds', 'updatedAt'])
                           ) ||
                           // Allow updates to schedule
                           (isValidScheduleArray(request.resource.data.schedule) &&
                            request.resource.data.keys().hasAny(['schedule', 'updatedAt'])
                           )
                         )
                      && request.resource.data.updatedAt == request.time;
      allow delete: if isSuperAdmin(request.auth.uid); // Only Super Admins can delete cohorts
    }
    
    // Rules for /systemSettings collection
    match /systemSettings/config {
        allow read: if isSignedIn();
        allow write: if isSuperAdmin(request.auth.uid) 
                    && request.resource.data.portalName is string
                    && request.resource.data.maintenanceMode is bool
                    && request.resource.data.allowNewRegistrations is bool
                    && request.resource.data.defaultCohortSize is number
                    && request.resource.data.updatedAt == request.time
                    && request.resource.data.updatedByUid == request.auth.uid;
    }
    
    // Rules for /activityLogs collection
    match /activityLogs/{logId} {
      allow read: if isAdmin(request.auth.uid); // Only admins can read activity logs
      allow create: if isSignedIn(); // Any signed-in user's action can trigger a log
      allow update, delete: if false; // Logs are immutable
    }
  }
}
