
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isSuperAdmin(userId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(userId)).data.isSuperAdmin == true;
    }

    function isAdmin(userId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(userId)).data.role == 'ADMIN_FACULTY';
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isRoleChangeSafeForUpdate(currentRole, newRole, newIsSuperAdmin) {
      // STUDENT or EXTERNAL_USER can only be changed by an admin
      // ADMIN_FACULTY can only be changed by a super admin
      // Only super admins can make someone an ADMIN_FACULTY
      // If demoting from ADMIN_FACULTY, new role must be STUDENT or EXTERNAL_USER and isSuperAdmin must be false.
      let requestingUserIsAdmin = isAdmin(request.auth.uid);
      let requestingUserIsSuperAdmin = isSuperAdmin(request.auth.uid);

      return (currentRole != newRole || request.resource.data.isSuperAdmin != resource.data.isSuperAdmin) && (
        ( // Case 1: Changing role of STUDENT or EXTERNAL_USER
          (currentRole == 'STUDENT' || currentRole == 'EXTERNAL_USER') &&
          requestingUserIsAdmin && // Any admin can change STUDENT/EXTERNAL_USER
          (newRole == 'ADMIN_FACULTY' ? requestingUserIsSuperAdmin : true) && // But only super admin can promote to ADMIN_FACULTY
          (newRole == 'ADMIN_FACULTY' ? newIsSuperAdmin == false : true) // If promoting to admin, ensure isSuperAdmin is not set to true by a non-super-admin promoter
        ) ||
        ( // Case 2: Changing role of ADMIN_FACULTY
          currentRole == 'ADMIN_FACULTY' &&
          requestingUserIsSuperAdmin && // Only super admin can change ADMIN_FACULTY
          (newRole == 'STUDENT' || newRole == 'EXTERNAL_USER') && // Can only demote to STUDENT/EXTERNAL_USER
          newIsSuperAdmin == false // Demotion must clear super admin status
        ) ||
        ( // Case 3: Promoting to ADMIN_FACULTY (from non-admin)
          (currentRole != 'ADMIN_FACULTY' && newRole == 'ADMIN_FACULTY') &&
          requestingUserIsSuperAdmin // Only super admin can promote to ADMIN_FACULTY
        )
      );
    }

    function isSuperAdminChangeSafe(currentIsSuperAdmin, newIsSuperAdmin) {
      // Only a super admin can change the isSuperAdmin flag for another user.
      // A user cannot make themselves a super admin.
      // A user cannot remove super admin status from themselves if they are the one making the request.
      return (currentIsSuperAdmin != newIsSuperAdmin) &&
             isSuperAdmin(request.auth.uid) &&
             (request.auth.uid != request.resource.id || (request.auth.uid == request.resource.id && newIsSuperAdmin == false)); // Allow self-demotion from super admin
    }

    function isValidUserProfileOnCreate() {
      let data = request.resource.data;
      let userProfile = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
      let isCreatingOwnProfile = request.auth.uid == data.uid;
      let isParulEmail = data.email.matches(".*@paruluniversity.ac.in$");

      return data.uid == request.auth.uid &&
             data.email == request.auth.token.email &&
             data.displayName == request.auth.token.name && // displayName is pre-filled by Firebase Auth on first write
             (data.photoURL == request.auth.token.picture || data.photoURL == null) &&
             data.fullName is string && data.fullName.size() >= 3 && data.fullName.size() <= 100 &&
             data.contactNumber is string && data.contactNumber.size() >= 10 && data.contactNumber.size() <= 15 &&
             (data.role == 'STUDENT' || data.role == 'EXTERNAL_USER' || data.role == 'ADMIN_FACULTY') &&
             (data.isSuperAdmin == false || (data.isSuperAdmin == true && data.email == "pranavrathi07@gmail.com")) &&
             data.createdAt == request.time &&
             data.updatedAt == request.time &&
             (data.enrollmentNumber == null || (data.enrollmentNumber is string && data.enrollmentNumber.size() <= 50)) &&
             (data.college == null || (data.college is string && data.college.size() <= 100)) &&
             (data.instituteName == null || (data.instituteName is string && data.instituteName.size() <= 100)) &&
             (
               data.isTeamMemberOnly == true ?
               (
                 data.startupTitle == null &&
                 data.problemDefinition == null &&
                 data.solutionDescription == null &&
                 data.uniqueness == null &&
                 data.applicantCategory == null &&
                 data.currentStage == null &&
                 data.teamMembers == null &&
                 data.associatedIdeaId is string && data.associatedIdeaId.size() > 0 &&
                 data.associatedTeamLeaderUid is string && data.associatedTeamLeaderUid.size() > 0
               ) :
               ( // Idea Owner or Admin context
                 (data.role == 'ADMIN_FACULTY' && data.startupTitle is string && data.startupTitle.size() >= 5 && data.startupTitle.size() <= 200) || // Admin might have specific startupTitle like "Administrative Account"
                 (data.role != 'ADMIN_FACULTY' && data.startupTitle is string && data.startupTitle.size() >= 5 && data.startupTitle.size() <= 200) && // Non-admins must have a startup title
                 data.problemDefinition is string && data.problemDefinition.size() >= 10 && data.problemDefinition.size() <= 2000 &&
                 data.solutionDescription is string && data.solutionDescription.size() >= 10 && data.solutionDescription.size() <= 2000 &&
                 data.uniqueness is string && data.uniqueness.size() >= 10 && data.uniqueness.size() <= 2000 &&
                 (data.applicantCategory == 'PARUL_STUDENT' || data.applicantCategory == 'PARUL_STAFF' || data.applicantCategory == 'PARUL_ALUMNI' || data.applicantCategory == 'OTHERS') &&
                 (data.currentStage == 'IDEA' || data.currentStage == 'PROTOTYPE_STAGE' || data.currentStage == 'STARTUP_STAGE') &&
                 (data.teamMembers is string && data.teamMembers.size() <= 500) && // teamMembers for idea owners
                 data.associatedIdeaId == null &&
                 data.associatedTeamLeaderUid == null &&
                 // Conditional requirement for enrollmentNumber and college based on applicantCategory if idea owner
                 (
                    (data.applicantCategory == 'PARUL_STUDENT' && data.enrollmentNumber is string && data.enrollmentNumber.size() > 0 && data.college is string && data.college.size() > 0) ||
                    (data.applicantCategory != 'PARUL_STUDENT')
                 )
               )
             ) &&
             request.resource.data.keys().hasOnly([
                'uid', 'email', 'displayName', 'photoURL', 'role', 'fullName', 'contactNumber',
                'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition',
                'solutionDescription', 'uniqueness', 'teamMembers', 'enrollmentNumber',
                'college', 'instituteName', 'createdAt', 'updatedAt', 'isSuperAdmin',
                'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'
             ]);
    }

    function isValidUserProfileOnUpdate(userId) {
      let data = request.resource.data;
      let existingData = resource.data;
      let requestingUserIsAdmin = isAdmin(request.auth.uid);
      let requestingUserIsSuperAdmin = isSuperAdmin(request.auth.uid);
      let isUpdatingOwnProfile = request.auth.uid == userId;

      return data.uid == existingData.uid && // Cannot change uid
             data.email == existingData.email && // Cannot change email
             data.createdAt == existingData.createdAt && // Cannot change createdAt
             data.updatedAt == request.time && // updatedAt must be server timestamp
             (isUpdatingOwnProfile || requestingUserIsAdmin) && // Owner or an Admin can update
             (
                // Role change safety
                (data.role == existingData.role) ||
                (isRoleChangeSafeForUpdate(existingData.role, data.role, data.isSuperAdmin))
             ) &&
             (
                // isSuperAdmin change safety
                (data.isSuperAdmin == existingData.isSuperAdmin) ||
                (isSuperAdminChangeSafe(existingData.isSuperAdmin, data.isSuperAdmin))
             ) &&
             // Validate the entire new state against creation rules (excluding immutable fields already checked)
             // This ensures that even if an admin updates a profile, the resulting state is valid.
             // We extract the relevant fields from `data` and check them as if it's a new creation.
             // This is a bit complex, but ensures data integrity.
             // A simpler alternative might be to list all updatable fields and their validation,
             // but this reuses the detailed creation logic.
             (
                // Core personal fields
                data.fullName is string && data.fullName.size() >= 3 && data.fullName.size() <= 100 &&
                data.contactNumber is string && data.contactNumber.size() >= 10 && data.contactNumber.size() <= 15 &&
                (data.photoURL == existingData.photoURL || data.photoURL == null || data.photoURL is string) &&
                (data.enrollmentNumber == null || (data.enrollmentNumber is string && data.enrollmentNumber.size() <= 50)) &&
                (data.college == null || (data.college is string && data.college.size() <= 100)) &&
                (data.instituteName == null || (data.instituteName is string && data.instituteName.size() <= 100)) &&
                // Idea/Team specific fields logic (similar to create)
                (
                  data.isTeamMemberOnly == true ?
                  (
                    data.startupTitle == null &&
                    data.problemDefinition == null &&
                    data.solutionDescription == null &&
                    data.uniqueness == null &&
                    data.applicantCategory == null &&
                    data.currentStage == null &&
                    data.teamMembers == null &&
                    data.associatedIdeaId is string && data.associatedIdeaId.size() > 0 &&
                    data.associatedTeamLeaderUid is string && data.associatedTeamLeaderUid.size() > 0
                  ) :
                  ( // Idea Owner or Admin context
                    (data.role == 'ADMIN_FACULTY' && data.startupTitle is string && data.startupTitle.size() >= 5 && data.startupTitle.size() <= 200) ||
                    (data.role != 'ADMIN_FACULTY' && data.startupTitle is string && data.startupTitle.size() >= 5 && data.startupTitle.size() <= 200) &&
                    data.problemDefinition is string && data.problemDefinition.size() >= 10 && data.problemDefinition.size() <= 2000 &&
                    data.solutionDescription is string && data.solutionDescription.size() >= 10 && data.solutionDescription.size() <= 2000 &&
                    data.uniqueness is string && data.uniqueness.size() >= 10 && data.uniqueness.size() <= 2000 &&
                    (data.applicantCategory == 'PARUL_STUDENT' || data.applicantCategory == 'PARUL_STAFF' || data.applicantCategory == 'PARUL_ALUMNI' || data.applicantCategory == 'OTHERS') &&
                    (data.currentStage == 'IDEA' || data.currentStage == 'PROTOTYPE_STAGE' || data.currentStage == 'STARTUP_STAGE') &&
                    (data.teamMembers is string && data.teamMembers.size() <= 500) &&
                    data.associatedIdeaId == null &&
                    data.associatedTeamLeaderUid == null &&
                    (
                       (data.applicantCategory == 'PARUL_STUDENT' && data.enrollmentNumber is string && data.enrollmentNumber.size() > 0 && data.college is string && data.college.size() > 0) ||
                       (data.applicantCategory != 'PARUL_STUDENT')
                    )
                  )
                )
             ) &&
             request.resource.data.keys().hasOnly([
                'uid', 'email', 'displayName', 'photoURL', 'role', 'fullName', 'contactNumber',
                'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition',
                'solutionDescription', 'uniqueness', 'teamMembers', 'enrollmentNumber',
                'college', 'instituteName', 'createdAt', 'updatedAt', 'isSuperAdmin',
                'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'
             ]);
    }

    function isIdeaOwner(ideaId) {
      return isSignedIn() && get(/databases/$(database)/documents/ideas/$(ideaId)).data.userId == request.auth.uid;
    }

    function isIdeaTeamMember(ideaId) {
        let idea = get(/databases/$(database)/documents/ideas/$(ideaId)).data;
        return isSignedIn() && request.auth.token.email in idea.teamMemberEmails;
    }

    function hasOnlyIdeaFields() {
      let allowedFields = [
        'userId', 'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType',
        'teamMembers', 'structuredTeamMembers', 'teamMemberEmails', 'fileURL', 'fileName', 'studioLocation',
        'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId',
        'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
        'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
        'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
        'submittedAt', 'updatedAt', 'applicantDisplayName', 'applicantEmail', // applicantDisplayName/Email are derived but stored
        'updatedByMentorAssignerUid', // Field to track who assigned mentor
        // Funding related fields
        'totalFundingAllocated', 'sanction1Amount', 'sanction2Amount',
        'sanction1DisbursedAt', 'sanction2DisbursedAt',
        'sanction1Expenses', 'sanction2Expenses',
        'beneficiaryName', 'beneficiaryAccountNo', 'beneficiaryBankName', 'beneficiaryIfscCode',
        'sanction1AppliedForNext',
        'sanction1UtilizationStatus', 'sanction1UtilizationRemarks', 'sanction1UtilizationReviewedBy', 'sanction1UtilizationReviewedAt',
        'sanction2UtilizationStatus', 'sanction2UtilizationRemarks', 'sanction2UtilizationReviewedBy', 'sanction2UtilizationReviewedAt'
      ];
      return request.resource.data.keys().hasOnly(allowedFields);
    }

    function isValidIdeaSubmissionOnCreateOrResubmit() {
        let data = request.resource.data;
        // Fetch user profile data once to avoid multiple get() calls if possible, or ensure fields are passed correctly
        let userProfile = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;

        return data.userId == request.auth.uid &&
               data.applicantDisplayName == (userProfile.displayName == null ? userProfile.fullName : userProfile.displayName) && // Match how it's set in createIdeaFromProfile
               data.applicantEmail == userProfile.email &&
               data.title is string && data.title.size() > 0 && data.title.size() <= 200 &&
               data.problem is string && data.problem.size() >= 10 && data.problem.size() <= 2000 &&
               data.solution is string && data.solution.size() >= 10 && data.solution.size() <= 2000 &&
               data.uniqueness is string && data.uniqueness.size() >= 10 && data.uniqueness.size() <= 2000 &&
               (data.developmentStage == 'IDEA' || data.developmentStage == 'PROTOTYPE_STAGE' || data.developmentStage == 'STARTUP_STAGE') &&
               (data.applicantType == 'PARUL_STUDENT' || data.applicantType == 'PARUL_STAFF' || data.applicantType == 'PARUL_ALUMNI' || data.applicantType == 'OTHERS') &&
               (data.teamMembers is string && data.teamMembers.size() <= 500) &&
               data.structuredTeamMembers is list && data.structuredTeamMembers.size() <= 4 && // Max 4 members
               (data.structuredTeamMembers.size() == 0 || data.structuredTeamMembers[0].keys().hasAll(['id', 'name', 'email', 'phone', 'institute', 'department', 'enrollmentNumber'])) && // Check structure of first member if any
               data.teamMemberEmails is list && data.teamMemberEmails.size() <= 4 &&
               (data.fileURL == null || (data.fileURL is string && data.fileURL.matches("https?://.+"))) &&
               (data.fileName == null || (data.fileName is string && data.fileName.size() > 0)) &&
               (data.studioLocation == null || data.studioLocation in ['SURAT', 'RAJKOT', 'BARODA', 'AHMEDABAD']) &&
               data.status == 'SUBMITTED' && // On create or resubmit from ARCHIVED_BY_ADMIN
               data.programPhase == null &&
               data.cohortId == null &&
               data.phase2Marks.size() == 0 && // Should be an empty map
               data.mentor == null &&
               data.rejectionRemarks == null && data.rejectedByUid == null && data.rejectedAt == null &&
               data.phase2PptUrl == null && data.phase2PptFileName == null && data.phase2PptUploadedAt == null &&
               data.nextPhaseDate == null && data.nextPhaseStartTime == null && data.nextPhaseEndTime == null && data.nextPhaseVenue == null && data.nextPhaseGuidelines == null &&
               // Funding fields initialized to null/default on creation
               data.totalFundingAllocated == null && data.sanction1Amount == null && data.sanction2Amount == null &&
               data.sanction1DisbursedAt == null && data.sanction2DisbursedAt == null &&
               data.sanction1Expenses is list && data.sanction1Expenses.size() == 0 &&
               data.sanction2Expenses is list && data.sanction2Expenses.size() == 0 &&
               data.beneficiaryName == null && data.beneficiaryAccountNo == null && data.beneficiaryBankName == null && data.beneficiaryIfscCode == null &&
               data.sanction1AppliedForNext == false &&
               data.sanction1UtilizationStatus == 'NOT_APPLICABLE' && data.sanction1UtilizationRemarks == null && data.sanction1UtilizationReviewedBy == null && data.sanction1UtilizationReviewedAt == null &&
               data.sanction2UtilizationStatus == 'NOT_APPLICABLE' && data.sanction2UtilizationRemarks == null && data.sanction2UtilizationReviewedBy == null && data.sanction2UtilizationReviewedAt == null &&
               ( // If it's a new document (create)
                (request.resource.id == null && data.submittedAt == request.time && data.updatedAt == request.time) ||
                // If it's an update from ARCHIVED_BY_ADMIN (resubmit)
                (resource.data.status == 'ARCHIVED_BY_ADMIN' && data.submittedAt == resource.data.submittedAt && data.updatedAt == request.time)
               ) &&
               hasOnlyIdeaFields();
    }

    function isValidIdeaUpdateByOwner() {
        let data = request.resource.data;
        let existingData = resource.data;
        return isOwner(existingData.userId) && // Must be owner
               // Owner can only update specific fields if idea is not archived by admin
               existingData.status != 'ARCHIVED_BY_ADMIN' &&
               // Immutable fields by owner (except for potential resubmission handled by create rule)
               data.userId == existingData.userId &&
               data.applicantDisplayName == existingData.applicantDisplayName &&
               data.applicantEmail == existingData.applicantEmail &&
               data.status == existingData.status && // Status can only be changed by admin or via resubmit logic
               data.programPhase == existingData.programPhase && // Phase can only be changed by admin
               data.mentor == existingData.mentor && // Mentor can only be changed by admin
               data.cohortId == existingData.cohortId && // Cohort can only be changed by admin
               data.rejectionRemarks == existingData.rejectionRemarks && // Admin field
               data.rejectedByUid == existingData.rejectedByUid && // Admin field
               data.rejectedAt == existingData.rejectedAt && // Admin field
               data.phase2Marks == existingData.phase2Marks && // Admin field
               data.submittedAt == existingData.submittedAt && // Submission date is immutable
               data.updatedAt == request.time && // Update timestamp
               // Owner updatable fields (basic info from profile sync, PPT, team members, beneficiary, expenses, S2 application)
               data.title is string && data.title.size() > 0 && data.title.size() <= 200 &&
               data.problem is string && data.problem.size() >= 10 && data.problem.size() <= 2000 &&
               data.solution is string && data.solution.size() >= 10 && data.solution.size() <= 2000 &&
               data.uniqueness is string && data.uniqueness.size() >= 10 && data.uniqueness.size() <= 2000 &&
               (data.developmentStage == 'IDEA' || data.developmentStage == 'PROTOTYPE_STAGE' || data.developmentStage == 'STARTUP_STAGE') &&
               (data.applicantType == 'PARUL_STUDENT' || data.applicantType == 'PARUL_STAFF' || data.applicantType == 'PARUL_ALUMNI' || data.applicantType == 'OTHERS') &&
               (data.teamMembers is string && data.teamMembers.size() <= 500) &&
               data.structuredTeamMembers is list && data.structuredTeamMembers.size() <= 4 &&
               data.teamMemberEmails is list && data.teamMemberEmails.size() <= 4 &&
               (data.fileURL == existingData.fileURL || (data.fileURL == null || (data.fileURL is string && data.fileURL.matches("https?://.+")))) && // Can update or keep existing
               (data.fileName == existingData.fileName || (data.fileName == null || (data.fileName is string && data.fileName.size() > 0))) &&
               (data.studioLocation == existingData.studioLocation || (data.studioLocation == null || data.studioLocation in ['SURAT', 'RAJKOT', 'BARODA', 'AHMEDABAD'])) &&
               // Phase 2 PPT can be updated by owner if in PHASE_2
               (
                 (existingData.programPhase == 'PHASE_2' &&
                  (data.phase2PptUrl == null || (data.phase2PptUrl is string && data.phase2PptUrl.matches("https?://.+"))) &&
                  (data.phase2PptFileName == null || (data.phase2PptFileName is string && data.phase2PptFileName.size() > 0)) &&
                  (data.phase2PptUploadedAt == null || data.phase2PptUploadedAt == request.time || data.phase2PptUploadedAt == existingData.phase2PptUploadedAt)
                 ) ||
                 (existingData.programPhase != 'PHASE_2' &&
                  data.phase2PptUrl == existingData.phase2PptUrl &&
                  data.phase2PptFileName == existingData.phase2PptFileName &&
                  data.phase2PptUploadedAt == existingData.phase2PptUploadedAt
                 )
               ) &&
               // Next phase details are set by admin, owner cannot change
               data.nextPhaseDate == existingData.nextPhaseDate &&
               data.nextPhaseStartTime == existingData.nextPhaseStartTime &&
               data.nextPhaseEndTime == existingData.nextPhaseEndTime &&
               data.nextPhaseVenue == existingData.nextPhaseVenue &&
               data.nextPhaseGuidelines == existingData.nextPhaseGuidelines &&
               // Funding fields updatable by owner (beneficiary, expenses, apply for S2)
               data.totalFundingAllocated == existingData.totalFundingAllocated && // Set by admin
               data.sanction1Amount == existingData.sanction1Amount && // Set by admin
               data.sanction2Amount == existingData.sanction2Amount && // Set by admin
               data.sanction1DisbursedAt == existingData.sanction1DisbursedAt && // Set by admin
               data.sanction2DisbursedAt == existingData.sanction2DisbursedAt && // Set by admin
               data.sanction1Expenses is list && (data.sanction1Expenses.size() == 0 || (data.sanction1Expenses[0].keys().hasAll(['id','description','amount','proofUrl','proofFileName','uploadedAt']))) && // Valid structure
               data.sanction2Expenses is list && (data.sanction2Expenses.size() == 0 || (data.sanction2Expenses[0].keys().hasAll(['id','description','amount','proofUrl','proofFileName','uploadedAt']))) && // Valid structure
               (data.beneficiaryName == null || (data.beneficiaryName is string && data.beneficiaryName.size() >= 3 && data.beneficiaryName.size() <= 100)) &&
               (data.beneficiaryAccountNo == null || (data.beneficiaryAccountNo is string && data.beneficiaryAccountNo.size() >= 8 && data.beneficiaryAccountNo.size() <= 20 && data.beneficiaryAccountNo.matches("^[0-9]+$"))) &&
               (data.beneficiaryBankName == null || (data.beneficiaryBankName is string && data.beneficiaryBankName.size() >= 3 && data.beneficiaryBankName.size() <= 100)) &&
               (data.beneficiaryIfscCode == null || (data.beneficiaryIfscCode is string && data.beneficiaryIfscCode.size() == 11 && data.beneficiaryIfscCode.matches("^[A-Z]{4}0[A-Z0-9]{6}$"))) &&
               data.sanction1AppliedForNext is bool && (data.sanction1AppliedForNext == true ? existingData.sanction1UtilizationStatus == 'APPROVED' : true) && // Can only apply if S1 approved
               data.sanction1UtilizationStatus == existingData.sanction1UtilizationStatus && // Set by admin
               data.sanction1UtilizationRemarks == existingData.sanction1UtilizationRemarks && // Set by admin
               data.sanction1UtilizationReviewedBy == existingData.sanction1UtilizationReviewedBy && // Set by admin
               data.sanction1UtilizationReviewedAt == existingData.sanction1UtilizationReviewedAt && // Set by admin
               data.sanction2UtilizationStatus == existingData.sanction2UtilizationStatus && // Set by admin
               data.sanction2UtilizationRemarks == existingData.sanction2UtilizationRemarks && // Set by admin
               data.sanction2UtilizationReviewedBy == existingData.sanction2UtilizationReviewedBy && // Set by admin
               data.sanction2UtilizationReviewedAt == existingData.sanction2UtilizationReviewedAt && // Set by admin
               hasOnlyIdeaFields();
    }

    function isValidIdeaUpdateByAdmin() {
        let data = request.resource.data;
        let existingData = resource.data;
        let adminProfile = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
        return isAdmin(request.auth.uid) &&
               // Immutable by Admin too (except specific flows like archive/resubmit)
               data.userId == existingData.userId &&
               data.applicantDisplayName == existingData.applicantDisplayName &&
               data.applicantEmail == existingData.applicantEmail &&
               data.title == existingData.title &&
               data.problem == existingData.problem &&
               data.solution == existingData.solution &&
               data.uniqueness == existingData.uniqueness &&
               data.developmentStage == existingData.developmentStage &&
               data.applicantType == existingData.applicantType &&
               data.teamMembers == existingData.teamMembers &&
               data.structuredTeamMembers == existingData.structuredTeamMembers &&
               data.teamMemberEmails == existingData.teamMemberEmails &&
               data.fileURL == existingData.fileURL &&
               data.fileName == existingData.fileName &&
               data.studioLocation == existingData.studioLocation &&
               data.phase2PptUrl == existingData.phase2PptUrl &&
               data.phase2PptFileName == existingData.phase2PptFileName &&
               data.phase2PptUploadedAt == existingData.phase2PptUploadedAt &&
               data.submittedAt == existingData.submittedAt &&
               data.updatedAt == request.time &&
               // Admin updatable fields
               (data.status in ['SUBMITTED', 'UNDER_REVIEW', 'IN_EVALUATION', 'SELECTED', 'NOT_SELECTED', 'ARCHIVED_BY_ADMIN']) &&
               (data.programPhase == null || data.programPhase in ['PHASE_1', 'PHASE_2', 'COHORT', 'INCUBATED']) &&
               (data.phase2Marks.size() == 0 || (adminProfile.uid in data.phase2Marks.keys() && data.phase2Marks[adminProfile.uid].keys().hasAll(['mark', 'adminDisplayName', 'markedAt']) && (data.phase2Marks[adminProfile.uid].mark == null || data.phase2Marks[adminProfile.uid].mark >=0 && data.phase2Marks[adminProfile.uid].mark <=100) && data.phase2Marks[adminProfile.uid].markedAt == request.time)) && // Admin can only add/update their own mark
               (data.mentor == null || data.mentor in ['Prashant Khanna', 'Riddhi Bagha', 'Nikhil Jumde', 'Jay Sudani', 'Hardik Kharva', 'Sonal Sudani', 'Pancham Baraiya', 'Juned Shaikh']) && // Enum check
               (data.cohortId == null || (data.cohortId is string && data.cohortId.size() > 0)) && // Can be string ID
               (data.rejectionRemarks == null || (data.rejectionRemarks is string && data.rejectionRemarks.size() > 0)) &&
               (data.rejectedByUid == null || data.rejectedByUid == request.auth.uid) &&
               (data.rejectedAt == null || data.rejectedAt == request.time) &&
               (data.nextPhaseDate == null || data.nextPhaseDate is timestamp) &&
               (data.nextPhaseStartTime == null || data.nextPhaseStartTime is string) &&
               (data.nextPhaseEndTime == null || data.nextPhaseEndTime is string) &&
               (data.nextPhaseVenue == null || data.nextPhaseVenue is string) &&
               (data.nextPhaseGuidelines == null || data.nextPhaseGuidelines is string) &&
               // Admin funding management
               (data.totalFundingAllocated == null || data.totalFundingAllocated is number && data.totalFundingAllocated > 0) &&
               (data.sanction1Amount == null || data.sanction1Amount is number && data.sanction1Amount > 0) &&
               (data.sanction2Amount == null || data.sanction2Amount is number && data.sanction2Amount > 0) &&
               (data.sanction1DisbursedAt == null || data.sanction1DisbursedAt == request.time) &&
               (data.sanction2DisbursedAt == null || data.sanction2DisbursedAt == request.time) &&
               data.sanction1Expenses == existingData.sanction1Expenses && // Expenses are added by user
               data.sanction2Expenses == existingData.sanction2Expenses && // Expenses are added by user
               data.beneficiaryName == existingData.beneficiaryName && // Set by user
               data.beneficiaryAccountNo == existingData.beneficiaryAccountNo && // Set by user
               data.beneficiaryBankName == existingData.beneficiaryBankName && // Set by user
               data.beneficiaryIfscCode == existingData.beneficiaryIfscCode && // Set by user
               data.sanction1AppliedForNext == existingData.sanction1AppliedForNext && // Set by user
               (data.sanction1UtilizationStatus in ['PENDING', 'APPROVED', 'REJECTED', 'NOT_APPLICABLE']) &&
               (data.sanction1UtilizationRemarks == null || data.sanction1UtilizationRemarks is string) &&
               (data.sanction1UtilizationReviewedBy == null || data.sanction1UtilizationReviewedBy == request.auth.uid) &&
               (data.sanction1UtilizationReviewedAt == null || data.sanction1UtilizationReviewedAt == request.time) &&
               (data.sanction2UtilizationStatus in ['PENDING', 'APPROVED', 'REJECTED', 'NOT_APPLICABLE']) &&
               (data.sanction2UtilizationRemarks == null || data.sanction2UtilizationRemarks is string) &&
               (data.sanction2UtilizationReviewedBy == null || data.sanction2UtilizationReviewedBy == request.auth.uid) &&
               (data.sanction2UtilizationReviewedAt == null || data.sanction2UtilizationReviewedAt == request.time) &&
               hasOnlyIdeaFields();
    }

    // Firestore Rules
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isValidUserProfileOnCreate();
      allow update: if isSignedIn() && isValidUserProfileOnUpdate(userId);
      allow delete: if isSignedIn() && (isOwner(userId) || isSuperAdmin(request.auth.uid)) && userId != "pranavrathi07@gmail.com"; // Super admin cannot delete self by this rule
    }

    match /ideas/{ideaId} {
      allow read: if isSignedIn() && (isOwner(ideaId) || isIdeaTeamMember(ideaId) || isAdmin(request.auth.uid));
      allow create: if isSignedIn() && isValidIdeaSubmissionOnCreateOrResubmit();
      allow update: if isSignedIn() && (
                      (isOwner(ideaId) && isValidIdeaUpdateByOwner()) ||
                      (isAdmin(request.auth.uid) && isValidIdeaUpdateByAdmin()) ||
                      // Special case for resubmitting an archived idea (owner changes status and some fields)
                      (isOwner(ideaId) && resource.data.status == 'ARCHIVED_BY_ADMIN' && isValidIdeaSubmissionOnCreateOrResubmit())
                    );
      allow delete: if false; // Ideas are typically archived, not deleted by users/admins directly
    }

    match /announcements/{announcementId} {
      allow read: if isSignedIn(); // All signed-in users can read announcements
      allow list: if isSignedIn();
      allow create, update, delete: if isSignedIn() && isAdmin(request.auth.uid); // Only admins can manage
    }

    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow list: if isSignedIn();
      allow create, update, delete: if isSignedIn() && isAdmin(request.auth.uid);
    }

    match /systemSettings/config {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn() && isSuperAdmin(request.auth.uid); // Only super admins can change system settings
    }

    match /activityLogs/{logId} {
      allow read: if isSignedIn() && isAdmin(request.auth.uid); // Only admins can read activity logs
      allow list: if isSignedIn() && isAdmin(request.auth.uid);
      allow create: if true; // Allow services or trusted clients (like backend functions or secured client-side for user actions) to write
      allow update, delete: if false; // Logs should be immutable
    }
  }
}

      