
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAdmin() {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN_FACULTY';
    }

    function isSuperAdmin() {
      return isAdmin() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    function isPrimarySuperAdminEmail(email) {
      return email == 'pranavrathi07@gmail.com';
    }

    // User is creating their own profile, not assigning super admin, not assigning admin role unless they are the primary super admin.
    function isCreatingOwnValidProfile(data) {
      let isAttemptingPrivilegeEscalation = data.isSuperAdmin == true || data.role == 'ADMIN_FACULTY';
      let isAllowedRoleAssignment = !isAttemptingPrivilegeEscalation || (isAttemptingPrivilegeEscalation && isPrimarySuperAdminEmail(request.auth.token.email));

      // request.resource.data refers to the data being written in a create operation
      return request.auth.uid == data.uid && // UID in document must match authenticated user
             data.email == request.auth.token.email && // Email in document must match authenticated user
             isAllowedRoleAssignment &&
             // Ensure team member specific fields are only set if isTeamMemberOnly is true
             (data.isTeamMemberOnly == false || data.isTeamMemberOnly == null || (data.isTeamMemberOnly == true && data.associatedIdeaId != null && data.associatedTeamLeaderUid != null)) &&
             // Ensure idea owner specific fields are only set if isTeamMemberOnly is false (or not present, defaulting to false)
             (data.isTeamMemberOnly == true || (
                (data.isTeamMemberOnly == false || data.isTeamMemberOnly == null) && // allow isTeamMemberOnly to be absent for non-team members
                 data.startupTitle != null &&
                 data.problemDefinition != null &&
                 data.solutionDescription != null &&
                 data.uniqueness != null &&
                 data.currentStage != null &&
                 data.applicantCategory != null
             ));
    }

    // User is updating their own profile, not changing critical fields
    function isUpdatingOwnValidProfile(newData, oldData) {
      return request.auth.uid == newData.uid &&
             newData.uid == oldData.uid &&
             newData.email == oldData.email &&
             newData.role == oldData.role && 
             newData.isSuperAdmin == oldData.isSuperAdmin && 
             newData.isTeamMemberOnly == oldData.isTeamMemberOnly &&
             newData.associatedIdeaId == oldData.associatedIdeaId &&
             newData.associatedTeamLeaderUid == oldData.associatedTeamLeaderUid &&
             newData.createdAt.toMillis() == oldData.createdAt.toMillis(); // Compare millis for Timestamp
    }

    // Idea owner is updating their idea, not changing status, phase, or admin-controlled fields
    function isIdeaOwnerUpdatingValidFields(newData, oldData) {
      let allowedUserModifiableFields = [
        'title', 'category', 'problem', 'solution', 'uniqueness', 'developmentStage',
        'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
        'fileURL', 'fileName', 'studioLocation',
        'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt'
      ];
      // Get keys that are different between newData and oldData or new in newData
      let affectedKeys = newData.keys().filter(key => newData[key] != oldData[key] || !(key in oldData));
      
      let onlyAllowedFieldsChanged = affectedKeys.hasOnly(allowedUserModifiableFields);

      return onlyAllowedFieldsChanged &&
             newData.userId == oldData.userId && 
             newData.status == oldData.status && 
             newData.programPhase == oldData.programPhase && 
             newData.phase2Marks == oldData.phase2Marks && 
             newData.mentor == oldData.mentor &&
             newData.rejectionRemarks == oldData.rejectionRemarks && 
             newData.rejectedByUid == oldData.rejectedByUid && 
             newData.rejectedAt == oldData.rejectedAt && 
             newData.nextPhaseDate == oldData.nextPhaseDate && 
             newData.nextPhaseStartTime == oldData.nextPhaseStartTime && 
             newData.nextPhaseEndTime == oldData.nextPhaseEndTime && 
             newData.nextPhaseVenue == oldData.nextPhaseVenue && 
             newData.nextPhaseGuidelines == oldData.nextPhaseGuidelines && 
             newData.submittedAt.toMillis() == oldData.submittedAt.toMillis();
    }

    // Check if idea submission data is valid during creation by owner
    function isValidIdeaSubmission(data) {
      return data.userId == request.auth.uid &&
             data.title != null && data.title.size() > 0 &&
             data.problem != null && data.problem.size() > 0 &&
             data.solution != null && data.solution.size() > 0 &&
             data.uniqueness != null && data.uniqueness.size() > 0 &&
             data.developmentStage != null &&
             data.status == 'SUBMITTED' && 
             data.programPhase == null && 
             (data.teamMemberEmails == null || data.teamMemberEmails.size() >= 0) && 
             (data.structuredTeamMembers == null || data.structuredTeamMembers.size() >= 0);
    }

    // Team member is updating their own entry in an idea's structuredTeamMembers array
    function isTeamMemberUpdatingOwnDetailsInIdea(request, resource) {
        let newData = request.resource.data; // Data being written
        let oldData = resource.data;         // Existing data

        // 1. Determine changed top-level fields. Only 'structuredTeamMembers' and 'updatedAt' are allowed to change.
        let allTopLevelKeys = newData.keys().concat(oldData.keys()).toSet();
        let changedTopLevelKeys = allTopLevelKeys.filter(key => newData[key] != oldData[key]);
        
        if (!changedTopLevelKeys.hasOnly(['structuredTeamMembers', 'updatedAt'])) {
            return false;
        }

        // 2. If 'structuredTeamMembers' is not even part of the write (only updatedAt changed), it's valid.
        if (!changedTopLevelKeys.has('structuredTeamMembers')) {
            return true; 
        }

        // 3. Constraints on 'structuredTeamMembers' update
        let newMembers = newData.structuredTeamMembers;
        let oldMembers = oldData.structuredTeamMembers;

        if (newMembers == null || oldMembers == null) return false; 
        if (newMembers.size() != oldMembers.size()) {
            return false; // Team members cannot add or remove other members via this specific update path.
        }

        let selfUpdateValidated = false;
        let otherMembersUnchangedCount = 0;

        for (let i = 0; i < newMembers.size(); i++) {
            let newMemberMap = newMembers[i]; // This is a map in security rules
            
            // Find corresponding old member by email. Assumes emails are unique within a team and don't change.
            let originalMemberEntryList = oldMembers.filter(om => om.email == newMemberMap.email);
            if (originalMemberEntryList.size() != 1) {
                 return false; // Member not found or duplicate old emails.
            }
            let oldMemberMap = originalMemberEntryList[0];

            if (newMemberMap.email == request.auth.token.email) {
                // This is the authenticated user's entry.
                if (newMemberMap.email != oldMemberMap.email) return false; // Email itself cannot be changed by member.

                // Key conditions:
                // A) Member is "claiming" their spot: old ID was not their UID, new ID is their UID.
                // B) Member is updating details: old ID was their UID, new ID is still their UID.
                let isClaimingSpot = (newMemberMap.id == request.auth.uid && oldMemberMap.id != request.auth.uid);
                let isUpdatingDetails = (newMemberMap.id == request.auth.uid && oldMemberMap.id == request.auth.uid);

                if (isClaimingSpot || isUpdatingDetails) {
                    // Other fields (name, phone, etc.) can change.
                    // We assume client sends correct details; rules don't cross-ref client form data.
                    selfUpdateValidated = true;
                } else {
                    // Any other ID change for self, or trying to change an ID that isn't the placeholder or their own.
                    return false;
                }
            } else {
                // This is another team member's entry. It must be entirely unchanged.
                if (newMemberMap.id != oldMemberMap.id ||
                    newMemberMap.name != oldMemberMap.name ||
                    newMemberMap.email != oldMemberMap.email || 
                    newMemberMap.phone != oldMemberMap.phone ||
                    newMemberMap.institute != oldMemberMap.institute ||
                    newMemberMap.department != oldMemberMap.department ||
                    newMemberMap.enrollmentNumber != oldMemberMap.enrollmentNumber) {
                    return false; // Other member's data was changed.
                }
                otherMembersUnchangedCount++;
            }
        }
        return selfUpdateValidated && (otherMembersUnchangedCount == (oldMembers.size() -1));
    }


    // Users Collection
    match /users/{userId} {
      allow read: if request.auth != null;

      allow create: if request.auth.uid == userId &&
                      isCreatingOwnValidProfile(request.resource.data);

      allow update: if (request.auth.uid == userId &&
                       isUpdatingOwnValidProfile(request.resource.data, resource.data)) ||
                      (isSuperAdmin() && !(isPrimarySuperAdminEmail(resource.data.email) && request.resource.data.isSuperAdmin == false && request.resource.data.role != 'ADMIN_FACULTY')) || // SuperAdmins can update
                      (isAdmin() && !isSuperAdmin() && request.auth.uid != userId && !(isPrimarySuperAdminEmail(resource.data.email))); // Admins can update others, not primary, not self if not superAdmin

      allow delete: if isSuperAdmin() && !isPrimarySuperAdminEmail(resource.data.email); // Super Admin can delete, but not primary super admin
    }

    // Ideas Collection
    match /ideas/{ideaId} {
      allow read: if request.auth != null &&
                    (resource.data.userId == request.auth.uid ||
                     (resource.data.teamMemberEmails != null && request.auth.token.email in resource.data.teamMemberEmails) ||
                     isAdmin());

      allow create: if request.auth.uid == request.resource.data.userId &&
                     isValidIdeaSubmission(request.resource.data);

      allow update: if isAdmin() ||
                     (request.auth.uid == resource.data.userId &&
                      isIdeaOwnerUpdatingValidFields(request.resource.data, resource.data)) ||
                     ((resource.data.teamMemberEmails != null && request.auth.token.email in resource.data.teamMemberEmails) &&
                      isTeamMemberUpdatingOwnDetailsInIdea(request, resource));

      allow delete: if isAdmin() || request.auth.uid == resource.data.userId;
    }

    // Announcements Collection
    match /announcements/{announcementId} {
      allow read: if request.auth != null;
      allow list: if request.auth != null;
      allow create, update, delete: if isAdmin();
    }

    // Cohorts Collection (Future Use)
    match /cohorts/{cohortId} {
      allow read: if request.auth != null; 
      allow create, update, delete: if isAdmin();
    }

    // System Settings Document
    match /systemSettings/config {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }
  }
}

    