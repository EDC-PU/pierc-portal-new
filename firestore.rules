
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to get user data (memoized by Firestore)
    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    // Helper function to check if the currently authenticated user is the owner of the resource
    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to check if the user has an 'ADMIN_FACULTY' role
    function isAdmin() {
      return isAuthenticated() && getUserData(request.auth.uid).role == 'ADMIN_FACULTY';
    }

    // Helper function to check if the user is a Super Admin
    function isSuperAdmin() {
      return isAuthenticated() && getUserData(request.auth.uid).isSuperAdmin == true;
    }
    
    function isPrimarySuperAdminEmail(email) {
      return email == 'pranavrathi07@gmail.com';
    }

    // Validates if the data being written for a user profile is acceptable during creation.
    function isCreatingOwnValidProfile(userId, data) {
      let isAttemptingPrivilegeEscalation = data.isSuperAdmin == true || data.role == 'ADMIN_FACULTY';
      let isAllowedToSetPrivilegedRole = isPrimarySuperAdminEmail(request.auth.token.email);
      
      // Common conditions
      let commonConditions = request.auth.uid == userId &&
                             data.uid == userId &&
                             data.email == request.auth.token.email &&
                             data.fullName != null && data.fullName.size() > 0 &&
                             data.contactNumber != null && data.contactNumber.size() >= 10;

      // Role and superAdmin checks
      let roleCheck = (data.role == 'ADMIN_FACULTY' || data.isSuperAdmin == true) ? isAllowedToSetPrivilegedRole : true;

      // Idea owner specific field checks (must be present if not team member only)
      let ideaOwnerFieldsValid = (
        data.applicantCategory != null &&
        data.currentStage != null &&
        data.startupTitle != null && data.startupTitle.size() > 0 &&
        data.problemDefinition != null && data.problemDefinition.size() > 0 &&
        data.solutionDescription != null && data.solutionDescription.size() > 0 &&
        data.uniqueness != null && data.uniqueness.size() > 0
      );
      
      // Team member specific field checks (must be present if team member only)
      let teamMemberFieldsValid = (
        data.associatedIdeaId != null &&
        data.associatedTeamLeaderUid != null
      );

      // Ensure no cross-contamination of fields for specific roles
      let noIdeaFieldsIfTeamMember = (
        data.applicantCategory == null &&
        data.currentStage == null &&
        (data.startupTitle == null || data.startupTitle == "") && // allow empty string for initial nulls
        (data.problemDefinition == null || data.problemDefinition == "") &&
        (data.solutionDescription == null || data.solutionDescription == "") &&
        (data.uniqueness == null || data.uniqueness == "")
      );

      let noTeamAssocFieldsIfOwner = (
        data.associatedIdeaId == null &&
        data.associatedTeamLeaderUid == null
      );

      return commonConditions && roleCheck &&
             (
               (data.isTeamMemberOnly == true && teamMemberFieldsValid && noIdeaFieldsIfTeamMember) ||
               ((data.isTeamMemberOnly == false || !('isTeamMemberOnly' in data)) && ideaOwnerFieldsValid && noTeamAssocFieldsIfOwner) ||
               (isPrimarySuperAdminEmail(request.auth.token.email) && (data.role == 'ADMIN_FACULTY' && data.isSuperAdmin == true)) // Special case for primary admin setup
             );
    }

    // Validates if a user is updating their own profile with allowed fields.
    function isUpdatingOwnAllowedProfileFields(newData, oldData) {
      // Fields a user CANNOT change about themselves directly after creation
      let forbiddenToChange = ['uid', 'email', 'role', 'isSuperAdmin', 'createdAt', 
                               'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'];
      let changedKeys = newData.diff(oldData).affectedKeys();
      
      return request.auth.uid == newData.uid && // Must be their own profile
             !changedKeys.hasAny(forbiddenToChange); // Must not change forbidden fields
    }
    
    // Validates if an idea owner is updating their idea with allowed fields.
    function isIdeaOwnerUpdatingAllowedIdeaFields(newData, oldData) {
        // Fields an idea owner CANNOT change directly
        let forbiddenToChange = [
            'userId', 'status', 'programPhase', 'phase2Marks', 'rejectionRemarks', 
            'rejectedByUid', 'rejectedAt', 'nextPhaseDate', 'nextPhaseStartTime', 
            'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', 'mentor', 
            'submittedAt', 'cohortId' // cohortId for future
        ];
        let changedKeys = newData.diff(oldData).affectedKeys();

        return request.auth.uid == oldData.userId && // Must be the idea owner
               !changedKeys.hasAny(forbiddenToChange);
    }


    // User Profiles
    match /users/{userId} {
      allow read: if isAuthenticated();

      allow create: if isCreatingOwnValidProfile(userId, request.resource.data);

      allow update: if (
                      // Admin can update, with protection for primary super admin
                      (isAdmin() && 
                        (resource.data.email != "pranavrathi07@gmail.com" || 
                          (request.resource.data.role == 'ADMIN_FACULTY' && request.resource.data.isSuperAdmin == true)
                        ) &&
                        // Admin cannot change creation timestamp or user's email/uid
                        request.resource.data.uid == resource.data.uid &&
                        request.resource.data.email == resource.data.email &&
                        request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis()
                      ) ||
                      // User can update their own allowed fields
                      (isUser(userId) && isUpdatingOwnAllowedProfileFields(request.resource.data, resource.data))
                    );
      
      allow delete: if isAdmin() && resource.data.email != "pranavrathi07@gmail.com";
    }

    // Idea Submissions
    match /ideas/{ideaId} {
      allow read: if isAuthenticated() &&
                     (isUser(resource.data.userId) ||
                      (resource.data.teamMemberEmails != null && request.auth.token.email in resource.data.teamMemberEmails) ||
                      isAdmin());

      // User must be authenticated and be the owner specified in the idea data.
      // Basic data validation (e.g. required fields for an idea).
      allow create: if isAuthenticated() && 
                      isUser(request.resource.data.userId) &&
                      request.resource.data.title != null && request.resource.data.title.size() > 0 &&
                      request.resource.data.status == 'SUBMITTED'; // Initial status

      allow update: if isAuthenticated() && (
                      isAdmin() || // Admins can update
                      (isUser(resource.data.userId) && isIdeaOwnerUpdatingAllowedIdeaFields(request.resource.data, resource.data)) || // Idea owner restricted update
                      ( // Team member updating their own details in structuredTeamMembers
                        resource.data.teamMemberEmails != null && request.auth.token.email in resource.data.teamMemberEmails &&
                        request.writeFields.hasOnly(['structuredTeamMembers', 'updatedAt']) && // MUST only be these top-level fields
                        request.resource.data.structuredTeamMembers.size() == resource.data.structuredTeamMembers.size() && // Array size cannot change
                        // Ensure the change to structuredTeamMembers is valid:
                        // 1. Only one member object is different between old and new array.
                        // 2. That different member object in the new array has an email matching request.auth.token.email.
                        // 3. That different member object in the new array has an id matching request.auth.uid.
                        // (This is a simplified check; complex array diffs are hard in rules. Client must be robust.)
                        (
                            // This logic is complex to express perfectly. We trust the client to form the correct
                            // structuredTeamMembers array and here we mostly ensure no other fields are touched
                            // and the array size remains the same.
                            // The client ensures only the member's own data is changed and their ID is set to their UID.
                            true 
                        )
                      )
                    );

      allow delete: if isAuthenticated() && (isUser(resource.data.userId) || isAdmin());
    }

    // Announcements
    match /announcements/{announcementId} {
      allow read: if isAuthenticated();
      allow list: if isAuthenticated(); // For feeds
      allow create, update, delete: if isAdmin();
    }
    
    // Activity Logs
    match /activityLogs/{logId} {
      allow read: if isAdmin(); // Only admins can read logs
      // Authenticated users can create log entries, but only if they are the actor
      allow create: if isAuthenticated() && request.resource.data.actorUid == request.auth.uid;
    }

    // System Settings (single document 'config')
    match /systemSettings/config {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
  }
}
