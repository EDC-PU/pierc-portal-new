
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isUserProfileAdmin(userId) {
      let userProfile = getUserData(userId);
      return userProfile.role == 'ADMIN_FACULTY';
    }

    function isUserProfileSuperAdmin(userId) {
      let userProfile = getUserData(userId);
      return userProfile.role == 'ADMIN_FACULTY' && userProfile.isSuperAdmin == true;
    }

    function isValidRole(role) {
      return role == 'STUDENT' || role == 'EXTERNAL_USER' || role == 'ADMIN_FACULTY' || role == null;
    }

    function isValidApplicantCategory(category) {
      return category == 'PARUL_STUDENT' || category == 'PARUL_STAFF' || category == 'PARUL_ALUMNI' || category == 'OTHERS';
    }

    function isValidCurrentStage(stage) {
      return stage == 'IDEA' || stage == 'PROTOTYPE_STAGE' || stage == 'STARTUP_STAGE';
    }

    function isValidIdeaStatus(status) {
      return status == 'SUBMITTED' || status == 'UNDER_REVIEW' || status == 'IN_EVALUATION' || status == 'SELECTED' || status == 'NOT_SELECTED' || status == 'ARCHIVED_BY_ADMIN';
    }

    function isValidProgramPhase(phase) {
      return phase == 'PHASE_1' || phase == 'PHASE_2' || phase == 'COHORT' || phase == null;
    }

    // Validate string lengths (basic checks)
    function isValidString(str, min, max) {
      return str is string && str.size() >= min && str.size() <= max;
    }
    function isOptionalValidString(str, min, max) {
      return str == null || (str is string && str.size() >= min && str.size() <= max);
    }
    function isOptionalString(str) {
      return str == null || str is string;
    }
     function isOptionalTimestamp(ts) {
      return ts == null || ts is timestamp;
    }

    function isListOfStrings(list) {
      return list is list && (list.size() == 0 || list[0] is string);
    }

    function isValidTeamMemberMap(member) {
      return member is map &&
             member.keys().hasAll(['id', 'name', 'email', 'phone', 'institute', 'department']) && // enrollmentNumber is optional key
             isValidString(member.id, 1, 50) &&
             isValidString(member.name, 1, 100) &&
             isValidString(member.email, 5, 100) && member.email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') &&
             isValidString(member.phone, 10, 15) &&
             isValidString(member.institute, 1, 100) &&
             isValidString(member.department, 1, 100) &&
             (member.get('enrollmentNumber', null) == null || isValidString(member.enrollmentNumber, 0, 50)); // Allow empty or valid string
    }

    function isValidStructuredTeamMembersList(list) {
      return list is list && list.size() <= 4 && (list.size() == 0 || list.all(member, isValidTeamMemberMap(member)));
    }

    // User Profile Validation
    function isValidUserProfileOnCreate(userId, data) {
      let isSuperAdminUser = data.email == 'pranavrathi07@gmail.com';
      let isMentorUser = data.email in [
        'prashant.khanna8747@paruluniversity.ac.in', 'riddhi.bagha29080@paruluniversity.ac.in',
        'nikhil.jumade24167@paruluniversity.ac.in', 'jay.sudani@paruluniversity.ac.in',
        'hardik.kharva2899@paruluniversity.ac.in', 'sonal.sudani23321@paruluniversity.ac.in',
        'panchamkumar.baraiya28771@paruluniversity.ac.in', 'juned.shaikh32161@paruluniversity.ac.in'
      ];

      let expectedRole = data.role;
      if (isSuperAdminUser || isMentorUser) {
        expectedRole = 'ADMIN_FACULTY';
      }

      // Common validations for all profiles
      let commonValidations = data.uid == userId
                         && data.email == request.auth.email
                         && (data.displayName == request.auth.displayName || (data.displayName == data.fullName))
                         && (data.photoURL == request.auth.token.picture || data.photoURL == null)
                         && data.role == expectedRole && isValidRole(data.role)
                         && data.isSuperAdmin == isSuperAdminUser
                         && isValidString(data.fullName, 3, 100)
                         && isValidString(data.contactNumber, 10, 15)
                         && data.createdAt == request.time && data.updatedAt == request.time;

      // Validations specific to user type (idea owner vs. team member vs. admin placeholders)
      let typeSpecificValidations = false;
      if (data.isTeamMemberOnly == true) {
        typeSpecificValidations = data.startupTitle == null
                                && data.problemDefinition == null
                                && data.solutionDescription == null
                                && data.uniqueness == null
                                && data.applicantCategory == null
                                && data.currentStage == null
                                && data.teamMembers == null // Text field for team members
                                && data.associatedIdeaId is string // Must have associatedIdeaId
                                && data.associatedTeamLeaderUid is string; // Must have associatedTeamLeaderUid
      } else if (isSuperAdminUser) { // Super Admin placeholder data
          typeSpecificValidations = data.startupTitle == 'Administrative Account'
                                 && data.problemDefinition == 'Handles portal administration.'
                                 && data.solutionDescription == 'Provides administrative functions and support.'
                                 && data.uniqueness == 'Unique administrative role for system management.'
                                 && data.applicantCategory == 'PARUL_STAFF'
                                 && data.currentStage == 'STARTUP_STAGE'
                                 && (data.teamMembers == '' || data.teamMembers == null)
                                 && data.associatedIdeaId == null
                                 && data.associatedTeamLeaderUid == null;
      } else if (isMentorUser && data.role == 'ADMIN_FACULTY') { // Mentor placeholder data
          typeSpecificValidations = data.startupTitle == 'Faculty/Mentor Account'
                                 && data.problemDefinition == 'Manages portal functions and/or mentorship.'
                                 && data.solutionDescription == 'Provides administrative or mentorship support.'
                                 && data.uniqueness == 'Unique administrative/mentorship role.'
                                 && data.applicantCategory == 'PARUL_STAFF'
                                 && data.currentStage == 'STARTUP_STAGE'
                                 && (data.teamMembers == '' || data.teamMembers == null)
                                 && data.associatedIdeaId == null
                                 && data.associatedTeamLeaderUid == null;
      } else { // Regular idea owner
        typeSpecificValidations = isValidString(data.startupTitle, 5, 200)
                                && isValidString(data.problemDefinition, 10, 2000)
                                && isValidString(data.solutionDescription, 10, 2000)
                                && isValidString(data.uniqueness, 10, 2000)
                                && isValidApplicantCategory(data.applicantCategory)
                                && isValidCurrentStage(data.currentStage)
                                && isOptionalValidString(data.teamMembers, 0, 500) // Text field
                                && data.associatedIdeaId == null
                                && data.associatedTeamLeaderUid == null;
      }

      // Academic/Institutional info (optional fields, validate if present)
      let academicInfoValid = isOptionalValidString(data.enrollmentNumber, 0, 50)
                             && isOptionalValidString(data.college, 0, 100)
                             && isOptionalValidString(data.instituteName, 0, 100);

      return commonValidations && typeSpecificValidations && academicInfoValid;
    }

    function isValidUserProfileOnUpdate(userId, requestData, existingData) {
      let isSuperAdminUser = existingData.email == 'pranavrathi07@gmail.com'; // Check based on existing email

      // Fields admins are allowed to change (subset of UserProfile)
      let adminAllowedUpdateFields = [
        'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
        'applicantCategory', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'currentStage',
        'teamMembers', 'updatedAt'
      ];
      // Fields users are allowed to change for themselves
      let selfUpdateAllowedFields = [
        'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
        'applicantCategory', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'currentStage',
        'teamMembers', // User can update their own idea's team members text
        'updatedAt', 'photoURL', 'displayName' // Users can update their photo/displayName from Google
      ];

      let commonValidations = requestData.uid == existingData.uid // UID immutable
                         && requestData.email == existingData.email // Email immutable by this function
                         && requestData.role == existingData.role // Role not changed here
                         && requestData.isSuperAdmin == existingData.isSuperAdmin // Super admin status not changed here
                         && requestData.createdAt.toMillis() == existingData.createdAt.toMillis() // CreatedAt immutable
                         && requestData.updatedAt == request.time
                         && isValidString(requestData.fullName, 3, 100)
                         && isValidString(requestData.contactNumber, 10, 15);

      // Validations for non-team-member specific fields (idea fields)
      let ideaFieldsValid = true;
      if (existingData.isTeamMemberOnly == false && !(isSuperAdminUser || (existingData.email in [
          'prashant.khanna8747@paruluniversity.ac.in', 'riddhi.bagha29080@paruluniversity.ac.in',
          'nikhil.jumade24167@paruluniversity.ac.in', 'jay.sudani@paruluniversity.ac.in',
          'hardik.kharva2899@paruluniversity.ac.in', 'sonal.sudani23321@paruluniversity.ac.in',
          'panchamkumar.baraiya28771@paruluniversity.ac.in', 'juned.shaikh32161@paruluniversity.ac.in'
        ] && existingData.role == 'ADMIN_FACULTY'))) {
          // Regular idea owner: their idea fields must be valid
          ideaFieldsValid = isValidString(requestData.startupTitle, 5, 200)
                           && isValidString(requestData.problemDefinition, 10, 2000)
                           && isValidString(requestData.solutionDescription, 10, 2000)
                           && isValidString(requestData.uniqueness, 10, 2000)
                           && isValidApplicantCategory(requestData.applicantCategory)
                           && isValidCurrentStage(requestData.currentStage)
                           && isOptionalValidString(requestData.teamMembers, 0, 500);
      } else if (existingData.isTeamMemberOnly == true) {
          // Team member: idea fields should remain null/empty
          ideaFieldsValid = requestData.startupTitle == null
                           && requestData.problemDefinition == null
                           && requestData.solutionDescription == null
                           && requestData.uniqueness == null
                           && requestData.applicantCategory == null
                           && requestData.currentStage == null
                           && requestData.teamMembers == null;
      }
      // For admin/mentor placeholder accounts, idea fields are specific and usually not self-edited here this way
      // but if an admin edits *another* user who is an idea owner, those fields must be valid.

      let academicInfoValid = isOptionalValidString(requestData.enrollmentNumber, 0, 50)
                             && isOptionalValidString(requestData.college, 0, 100)
                             && isOptionalValidString(requestData.instituteName, 0, 100);

      // Check for fields immutable by user (self-update)
      let selfUpdateImmutablesValid = true;
      if (isOwner(userId)) {
        selfUpdateImmutablesValid = requestData.isTeamMemberOnly == existingData.isTeamMemberOnly
                                 && requestData.associatedIdeaId == existingData.associatedIdeaId
                                 && requestData.associatedTeamLeaderUid == existingData.associatedTeamLeaderUid;
      }

      return commonValidations && ideaFieldsValid && academicInfoValid && selfUpdateImmutablesValid;
    }

    function creatorIsNotUsingAdminPlaceholderForIdea(userId, ideaTitle, ideaProblem) {
      let userProfile = getUserData(userId);
      // Check if the user has an admin-like role
      if (userProfile.role == 'ADMIN_FACULTY') {
        // Check if idea details match known admin placeholder text
        let isPlaceholderTitle = userProfile.isSuperAdmin ?
                                 ideaTitle == 'Administrative Account' :
                                 ideaTitle == 'Faculty/Mentor Account';
        let isPlaceholderProblem = userProfile.isSuperAdmin ?
                                   ideaProblem == 'Handles portal administration.' :
                                   ideaProblem == 'Manages portal functions and/or mentorship.';

        // If both title and problem match placeholders, then this is not a valid user-created idea
        return !(isPlaceholderTitle && isPlaceholderProblem);
      }
      // If not ADMIN_FACULTY, this check doesn't apply, so return true (it's a valid idea from this perspective)
      return true;
    }

    // --- Idea Submission Validation ---
    function isValidIdeaContent(data) {
      return isValidString(data.title, 5, 200)
          && isValidString(data.problem, 10, 2000)
          && isValidString(data.solution, 10, 2000)
          && isValidString(data.uniqueness, 10, 2000)
          && isValidCurrentStage(data.developmentStage)
          && isValidApplicantCategory(data.applicantType) // Renamed from 'category' in payload to 'applicantType' in DB
          && (data.teamMembers is string && data.teamMembers.size() <= 500) // text field
          && (data.fileURL == null || (data.fileURL is string && data.fileURL.size() <= 500))
          && (data.fileName == null || (data.fileName is string && data.fileName.size() <= 100))
          && (data.studioLocation == null || (data.studioLocation is string && data.studioLocation in ['SURAT', 'RAJKOT', 'BARODA', 'AHMEDABAD']));
    }

    function isValidIdeaSubmissionOnCreateOrResubmit(userId, data, isCreate) {
      let commonValidations = isValidIdeaContent(data)
                           && data.userId == userId
                           && data.applicantDisplayName == getUserData(userId).displayName
                           && data.applicantEmail == getUserData(userId).email
                           && data.status == 'SUBMITTED'
                           && data.updatedAt == request.time
                           && data.programPhase == null
                           && data.cohortId == null
                           && data.phase2Marks.keys().size() == 0 // Ensure it's an empty map
                           && data.mentor == null
                           && data.rejectionRemarks == null
                           && data.rejectedByUid == null
                           && data.rejectedAt == null
                           && data.phase2PptUrl == null
                           && data.phase2PptFileName == null
                           && data.phase2PptUploadedAt == null
                           && data.nextPhaseDate == null
                           && data.nextPhaseStartTime == null
                           && data.nextPhaseEndTime == null
                           && data.nextPhaseVenue == null
                           && data.nextPhaseGuidelines == null
                           && data.structuredTeamMembers is list && data.structuredTeamMembers.size() == 0 // Must be empty list on create
                           && data.teamMemberEmails is list && data.teamMemberEmails.size() == 0; // Must be empty list on create

      if (isCreate) {
        return commonValidations
               && data.submittedAt == request.time;
      } else { // isUpdate (for resubmitting archived)
        return commonValidations
               && data.submittedAt == resource.data.submittedAt; // submittedAt is immutable on update
      }
    }

    // --- Security Rules ---
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(request.auth.uid)
                      && isValidUserProfileOnCreate(request.auth.uid, request.resource.data)
                      // No hasAll check, covered by isValidUserProfileOnCreate and hasOnly
                      && request.resource.data.keys().hasOnly([
                           'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'fullName', 'contactNumber',
                           'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                           'teamMembers', 'enrollmentNumber', 'college', 'instituteName',
                           'createdAt', 'updatedAt', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid'
                         ]);

      allow update: if isSignedIn() && (
                      // User updating their own profile
                      (isOwner(userId)
                        && isValidUserProfileOnUpdate(userId, request.resource.data, resource.data)
                        && request.resource.data.keys().hasOnly([
                             'displayName', 'photoURL', 'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                             'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                             'teamMembers', 'updatedAt' // Note: uid, email, role, isSuperAdmin, createdAt, isTeamMemberOnly, associatedIdeaId, associatedTeamLeaderUid are immutable by user here
                           ])
                      ) ||
                      // Admin updating any user's profile (limited fields, e.g. not role directly)
                      (isUserProfileAdmin(request.auth.uid)
                        && isValidUserProfileOnUpdate(userId, request.resource.data, resource.data) // Validates data consistency
                        && request.resource.data.keys().hasOnly([ // Admins can update these specific fields
                             'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                             'applicantCategory', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'currentStage',
                             'teamMembers', 'updatedAt'
                           ])
                      ) ||
                      // Super Admin updating role or super admin status
                      (isUserProfileSuperAdmin(request.auth.uid)
                        && request.resource.data.updatedAt == request.time
                        && request.resource.data.uid == resource.data.uid
                        && request.resource.data.email == resource.data.email
                        && request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis()
                        && isValidRole(request.resource.data.role)
                        && request.resource.data.isSuperAdmin is bool
                        && (request.resource.data.email == 'pranavrathi07@gmail.com' ? // Primary Super Admin specific restrictions
                            (request.resource.data.role == 'ADMIN_FACULTY' && request.resource.data.isSuperAdmin == true) : true
                           )
                        // Allow only role and isSuperAdmin to be changed by super admin in this specific rule branch
                        && request.resource.data.keys().hasAll(resource.data.keys()) // Ensure no fields are removed
                        && request.writeFields.hasAny(['role', 'isSuperAdmin', 'updatedAt']) // Must update at least one of these + updatedAt
                        && request.writeFields.size() <= 3 // At most role, isSuperAdmin, updatedAt
                        && (request.writeFields.size() == 1 ? request.writeFields[0] == 'updatedAt' : true) // if only 1 field, it must be updatedAt (e.g. a no-op)
                      )
                    );
      allow delete: if false; // User profiles are not deleted directly, use callable function for account deletion
    }

    match /ideas/{ideaId} {
      allow read: if isSignedIn();

      allow create: if isOwner(request.auth.uid)
                      && isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, true) // true for create
                      && creatorIsNotUsingAdminPlaceholderForIdea(request.auth.uid, request.resource.data.title, request.resource.data.problem)
                      && request.resource.data.keys().hasOnly([
                           'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category',
                           'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType',
                           'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
                           'status', 'programPhase', 'cohortId', 'phase2Marks', 'mentor',
                           'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                           'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                           'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                           'submittedAt', 'updatedAt'
                           // Note: fileURL, fileName, studioLocation are optional and not part of initial profile-to-idea creation.
                         ]);

      allow update: if isSignedIn() && (
                      // User updating their own idea's PPT
                      (isOwner(resource.data.userId)
                        && request.resource.data.userId == resource.data.userId
                        && request.resource.data.title == resource.data.title // Title immutable by user here
                        && request.resource.data.status == resource.data.status // Status not changed by user PPT upload
                        && request.resource.data.programPhase == 'PHASE_2' // PPT only for Phase 2
                        && request.resource.data.updatedAt == request.time
                        && (request.resource.data.phase2PptUrl is string || request.resource.data.phase2PptUrl == null)
                        && (request.resource.data.phase2PptFileName is string || request.resource.data.phase2PptFileName == null)
                        && (request.resource.data.phase2PptUploadedAt is timestamp || request.resource.data.phase2PptUploadedAt == null)
                        // Only allow these fields to be updated by user for PPT upload
                        && request.writeFields.hasAll(['updatedAt', 'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt'])
                        && request.writeFields.size() == 4
                      ) ||
                      // User resubmitting an archived idea (via profile save)
                      (isOwner(resource.data.userId)
                        && resource.data.status == 'ARCHIVED_BY_ADMIN'
                        && request.resource.data.status == 'SUBMITTED' // Status must change to SUBMITTED
                        && isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, false) // false for update
                        && creatorIsNotUsingAdminPlaceholderForIdea(request.auth.uid, request.resource.data.title, request.resource.data.problem)
                        && request.resource.data.keys().hasOnly([ // Same fields as create, as it's a full overwrite/reset
                             'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category',
                             'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType',
                             'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
                             'status', 'programPhase', 'cohortId', 'phase2Marks', 'mentor',
                             'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                             'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                             'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                             'submittedAt', 'updatedAt'
                           ])
                      ) ||
                      // Admin updating idea status, phase, marks, mentor, cohortId, etc.
                      (isUserProfileAdmin(request.auth.uid)
                        && request.resource.data.userId == resource.data.userId // userId cannot change
                        && request.resource.data.title == resource.data.title   // title cannot change by admin here
                        && request.resource.data.submittedAt.toMillis() == resource.data.submittedAt.toMillis() // submittedAt immutable
                        && request.resource.data.updatedAt == request.time
                        && isValidIdeaStatus(request.resource.data.status)
                        && isValidProgramPhase(request.resource.data.programPhase)
                        && (request.resource.data.cohortId == null || request.resource.data.cohortId is string)
                        && (request.resource.data.mentor == null || request.resource.data.mentor is string) // Assuming MentorName is string
                        && isOptionalString(request.resource.data.rejectionRemarks)
                        && (request.resource.data.rejectedByUid == null || request.resource.data.rejectedByUid is string)
                        && isOptionalTimestamp(request.resource.data.rejectedAt)
                        && isOptionalTimestamp(request.resource.data.nextPhaseDate)
                        && isOptionalString(request.resource.data.nextPhaseStartTime)
                        && isOptionalString(request.resource.data.nextPhaseEndTime)
                        && isOptionalString(request.resource.data.nextPhaseVenue)
                        && isOptionalString(request.resource.data.nextPhaseGuidelines)
                        // Admin can write to specific fields related to review and progression
                        && request.writeFields.hasAny([
                             'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId',
                             'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                             'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                             'updatedAt', 'updatedByMentorAssignerUid' // If admin is assigning mentor
                           ])
                        // Ensure only allowed fields are part of the write operation for admin actions
                        && request.writeFields.hasOnly([ // Should include all fields that can be set/cleared by admin during status/phase update
                              'status', 'programPhase', 'phase2Marks', 'mentor', 'cohortId',
                              'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                              'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                              'updatedAt', 'updatedByMentorAssignerUid'
                            ].removeAll(request.resource.data.phase2Marks.keys().map(key, 'phase2Marks.' + key))) // Allow dynamic phase2Marks fields
                      ) ||
                      // User or Admin managing structured team members
                      ((isOwner(resource.data.userId) || isUserProfileAdmin(request.auth.uid))
                        && request.resource.data.userId == resource.data.userId
                        && request.resource.data.title == resource.data.title
                        && request.resource.data.updatedAt == request.time
                        && isValidStructuredTeamMembersList(request.resource.data.structuredTeamMembers)
                        && isListOfStrings(request.resource.data.teamMemberEmails)
                        && request.resource.data.teamMemberEmails.size() <= 4
                        && request.writeFields.hasAny(['structuredTeamMembers', 'teamMemberEmails', 'updatedAt'])
                        && request.writeFields.hasOnly(['structuredTeamMembers', 'teamMemberEmails', 'updatedAt'])
                      )
                    );
      allow delete: if false; // Ideas are archived by admin via update, not deleted directly
    }

    // Announcements: Only Admins can create, update, delete
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isUserProfileAdmin(request.auth.uid)
                      && request.resource.data.createdByUid == request.auth.uid
                      && request.resource.data.creatorDisplayName == getUserData(request.auth.uid).displayName
                      && isValidString(request.resource.data.title, 5, 100)
                      && isValidString(request.resource.data.content, 10, 5000)
                      && request.resource.data.isUrgent is bool
                      && request.resource.data.targetAudience in ['ALL', 'SPECIFIC_COHORT']
                      && (request.resource.data.targetAudience == 'ALL' ? request.resource.data.cohortId == null : (request.resource.data.cohortId is string && request.resource.data.cohortId.size() > 0))
                      && request.resource.data.createdAt == request.time
                      && request.resource.data.updatedAt == request.time
                      && request.resource.data.keys().hasOnly(['title', 'content', 'isUrgent', 'targetAudience', 'cohortId', 'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt', 'attachmentURL', 'attachmentName']);
      allow update: if isUserProfileAdmin(request.auth.uid)
                      && request.resource.data.createdByUid == resource.data.createdByUid // Cannot change creator
                      && request.resource.data.creatorDisplayName == resource.data.creatorDisplayName
                      && request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis() // Cannot change creation date
                      && isValidString(request.resource.data.title, 5, 100)
                      && isValidString(request.resource.data.content, 10, 5000)
                      && request.resource.data.isUrgent is bool
                      && request.resource.data.targetAudience in ['ALL', 'SPECIFIC_COHORT']
                      && (request.resource.data.targetAudience == 'ALL' ? request.resource.data.cohortId == null : (request.resource.data.cohortId is string && request.resource.data.cohortId.size() > 0))
                      && request.resource.data.updatedAt == request.time
                      && request.writeFields.hasOnly(['title', 'content', 'isUrgent', 'targetAudience', 'cohortId', 'updatedAt', 'attachmentURL', 'attachmentName']);
      allow delete: if isUserProfileAdmin(request.auth.uid);
    }

    // Cohorts: Only Admins can manage
    function isValidCohortScheduleEntry(entry) {
      return entry is map &&
             entry.keys().hasAll(['id', 'date', 'day', 'time', 'category', 'topicActivity']) && // content, speakerVenue are optional keys
             isValidString(entry.id, 1, 50) &&
             isValidString(entry.date, 10, 10) && // YYYY-MM-DD
             isValidString(entry.day, 1, 15) &&
             isValidString(entry.time, 1, 50) &&
             isValidString(entry.category, 1, 50) &&
             isValidString(entry.topicActivity, 1, 200) &&
             (entry.get('content', null) == null || isValidString(entry.content, 0, 1000)) &&
             (entry.get('speakerVenue', null) == null || isValidString(entry.speakerVenue, 0, 200));
    }
    function isValidCohortSchedule(schedule) {
        return schedule is list && (schedule.size() == 0 || schedule.all(item, isValidCohortScheduleEntry(item)));
    }

    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isUserProfileAdmin(request.auth.uid)
                      && request.resource.data.createdByUid == request.auth.uid
                      && request.resource.data.creatorDisplayName == getUserData(request.auth.uid).displayName
                      && isValidString(request.resource.data.name, 3, 100)
                      && request.resource.data.startDate is timestamp
                      && request.resource.data.endDate is timestamp
                      && request.resource.data.startDate < request.resource.data.endDate
                      && request.resource.data.batchSize is number && request.resource.data.batchSize >= 1 && request.resource.data.batchSize <= 200
                      && request.resource.data.ideaIds is list && request.resource.data.ideaIds.size() == 0
                      && request.resource.data.schedule is list && request.resource.data.schedule.size() == 0
                      && request.resource.data.createdAt == request.time
                      && request.resource.data.updatedAt == request.time
                      && request.resource.data.keys().hasOnly(['name', 'startDate', 'endDate', 'batchSize', 'ideaIds', 'schedule', 'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt']);
      allow update: if isUserProfileAdmin(request.auth.uid)
                      && request.resource.data.createdByUid == resource.data.createdByUid
                      && request.resource.data.creatorDisplayName == resource.data.creatorDisplayName
                      && request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis()
                      && request.resource.data.updatedAt == request.time
                      && ( // Branch for general cohort data update by admin
                           isValidString(request.resource.data.name, 3, 100)
                           && request.resource.data.startDate is timestamp
                           && request.resource.data.endDate is timestamp
                           && request.resource.data.startDate < request.resource.data.endDate
                           && request.resource.data.batchSize is number && request.resource.data.batchSize >= 1 && request.resource.data.batchSize <= 200
                           && request.writeFields.hasAny(['name', 'startDate', 'endDate', 'batchSize', 'updatedAt'])
                           && request.writeFields.hasOnly(['name', 'startDate', 'endDate', 'batchSize', 'updatedAt', // from create/update cohort form
                                                          'schedule', // from schedule update form
                                                          'ideaIds' // from assigning/unassigning ideas
                                                          ])
                           && isValidCohortSchedule(request.resource.data.schedule) // Validate full schedule if it's being written
                           && (request.resource.data.ideaIds is list && (request.resource.data.ideaIds.size() == 0 || request.resource.data.ideaIds[0] is string)) // Basic check for ideaIds list
                         );
      allow delete: if false; // Cohorts are not deleted for now
    }

    // System Settings: Only Super Admins can manage
    match /systemSettings/{settingsId} {
      allow read: if isSignedIn();
      allow write: if isUserProfileSuperAdmin(request.auth.uid) // Only super admin can write
                     && settingsId == 'config' // Only one config document
                     && request.resource.data.updatedAt == request.time
                     && request.resource.data.updatedByUid == request.auth.uid
                     && isValidString(request.resource.data.portalName, 3, 50)
                     && request.resource.data.maintenanceMode is bool
                     && request.resource.data.allowNewRegistrations is bool
                     && request.resource.data.defaultCohortSize is number && request.resource.data.defaultCohortSize >= 1 && request.resource.data.defaultCohortSize <= 100
                     && request.resource.data.keys().hasOnly(['portalName', 'maintenanceMode', 'allowNewRegistrations', 'defaultCohortSize', 'updatedAt', 'updatedByUid']);
    }

    // Activity Logs: Write-only for authenticated users (server-side or trusted client calls)
    // Read access should be highly restricted, e.g., only to super admins or not at all from client.
    match /activityLogs/{logId} {
      allow read: if isUserProfileSuperAdmin(request.auth.uid); // Or false if logs shouldn't be client-readable
      allow create: if isSignedIn()
                      && request.resource.data.actorUid == request.auth.uid
                      && request.resource.data.timestamp == request.time
                      && isValidString(request.resource.data.action, 3, 50)
                      && (request.resource.data.target == null || (
                            request.resource.data.target is map &&
                            request.resource.data.target.keys().hasAll(['type', 'id']) &&
                            request.resource.data.target.type is string &&
                            request.resource.data.target.id is string &&
                            (request.resource.data.target.displayName == null || request.resource.data.target.displayName is string)
                          ))
                      && (request.resource.data.details == null || request.resource.data.details is map);
      allow update, delete: if false;
    }
  }
}

    