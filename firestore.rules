
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ======== Helper Functions ========
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isSpecificUser(userId) {
      return request.auth.uid == userId;
    }

    function getUserProfileData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isUserAdmin(userId) {
      let profile = getUserProfileData(userId);
      return profile != null && profile.role == 'ADMIN_FACULTY';
    }

    function isUserSuperAdmin(userId) {
      let profile = getUserProfileData(userId);
      return profile != null && profile.role == 'ADMIN_FACULTY' && profile.isSuperAdmin == true;
    }

    function isValidRole(role) {
      return role == 'STUDENT' || role == 'EXTERNAL_USER' || role == 'ADMIN_FACULTY';
    }

    function isValidApplicantCategory(category) {
      return category == 'PARUL_STUDENT' || category == 'PARUL_STAFF' || category == 'PARUL_ALUMNI' || category == 'OTHERS';
    }

    function isValidCurrentStage(stage) {
      return stage == 'IDEA' || stage == 'PROTOTYPE_STAGE' || stage == 'STARTUP_STAGE';
    }

    function isStringAndNotEmpty(value) {
      return value is string && value.size() > 0;
    }

    function isStringOrNull(value) {
      return value == null || value is string;
    }

    function isTimestampOrServerTimestamp(value) {
      return value is timestamp || value == request.time;
    }

    // ======== User Profile Validation Functions ========
    function hasRequiredPersonalFields(data) {
      return isStringAndNotEmpty(data.fullName) &&
             isStringAndNotEmpty(data.contactNumber);
    }

    function hasRequiredIdeaFieldsForUserProfile(data) {
      return isStringAndNotEmpty(data.startupTitle) && data.startupTitle.size() >= 5 &&
             isStringAndNotEmpty(data.problemDefinition) && data.problemDefinition.size() >= 10 &&
             isStringAndNotEmpty(data.solutionDescription) && data.solutionDescription.size() >= 10 &&
             isStringAndNotEmpty(data.uniqueness) && data.uniqueness.size() >= 10 &&
             isValidApplicantCategory(data.applicantCategory) &&
             isValidCurrentStage(data.currentStage);
    }

    // Validates data for creating or updating a user profile.
    function isValidUserProfileWrite(data, existingData, isCreate) {
      // Common checks for create and update
      let commonChecks =
        isValidRole(data.role) &&
        (data.isSuperAdmin == false || (data.isSuperAdmin == true && data.role == 'ADMIN_FACULTY')) &&
        hasRequiredPersonalFields(data) &&
        isStringOrNull(data.enrollmentNumber) &&
        isStringOrNull(data.college) &&
        isStringOrNull(data.instituteName) &&
        (data.teamMembers == null || (data.teamMembers is string && data.teamMembers.size() <= 500));

      // Idea-related field checks, conditional on role and type of account
      let ideaChecks =
        (data.isTeamMemberOnly == true &&
          data.startupTitle == null && data.problemDefinition == null && data.solutionDescription == null && data.uniqueness == null &&
          data.applicantCategory == null && data.currentStage == null && data.teamMembers == null &&
          data.associatedIdeaId is string && data.associatedTeamLeaderUid is string
        ) ||
        (data.isTeamMemberOnly == false && data.role != 'ADMIN_FACULTY' &&
          hasRequiredIdeaFieldsForUserProfile(data) &&
          data.associatedIdeaId == null && data.associatedTeamLeaderUid == null
        ) ||
        (data.isTeamMemberOnly == false && data.role == 'ADMIN_FACULTY' &&
          (data.startupTitle == 'Administrative Account' || data.startupTitle == 'Faculty/Mentor Account') && // Specific placeholder titles
          isStringAndNotEmpty(data.problemDefinition) &&
          isStringAndNotEmpty(data.solutionDescription) &&
          isStringAndNotEmpty(data.uniqueness) &&
          data.applicantCategory == 'PARUL_STAFF' && // Default for admin/mentor
          data.currentStage == 'STARTUP_STAGE' &&     // Default for admin/mentor
          data.associatedIdeaId == null && data.associatedTeamLeaderUid == null
        );

      return commonChecks && ideaChecks;
    }

    // ======== Idea Submission Validation Functions ========
    function isValidIdeaStatus(status) {
      return status == 'SUBMITTED' || status == 'UNDER_REVIEW' || status == 'IN_EVALUATION' ||
             status == 'SELECTED' || status == 'NOT_SELECTED' || status == 'ARCHIVED_BY_ADMIN';
    }

    function isValidProgramPhase(phase) {
      return phase == 'PHASE_1' || phase == 'PHASE_2' || phase == 'COHORT';
    }

    function isValidIdeaCoreContent(data) {
      return data.title is string && data.title.size() >= 5 && data.title.size() <= 200 &&
             data.problem is string && data.problem.size() >= 10 && data.problem.size() <= 2000 &&
             data.solution is string && data.solution.size() >= 10 && data.solution.size() <= 2000 &&
             data.uniqueness is string && data.uniqueness.size() >= 10 && data.uniqueness.size() <= 2000 &&
             isValidApplicantCategory(data.applicantType) &&
             isValidCurrentStage(data.developmentStage) &&
             (data.teamMembers == null || (data.teamMembers is string && data.teamMembers.size() <= 500));
    }

    function isValidOptionalIdeaFields(data) {
        return (data.fileURL == null || data.fileURL is string) &&
               (data.fileName == null || data.fileName is string) &&
               (data.studioLocation == null || (data.studioLocation is string && (data.studioLocation == 'SURAT' || data.studioLocation == 'RAJKOT' || data.studioLocation == 'BARODA' || data.studioLocation == 'AHMEDABAD'))) &&
               (data.phase2PptUrl == null || data.phase2PptUrl is string) &&
               (data.phase2PptFileName == null || data.phase2PptFileName is string) &&
               (data.phase2PptUploadedAt == null || data.phase2PptUploadedAt is timestamp);
    }

    function isValidAdminIdeaFieldsOnUserSubmit(data) {
        return data.programPhase == null &&
               data.cohortId == null &&
               data.mentor == null &&
               data.phase2Marks == {} &&
               data.rejectionRemarks == null &&
               data.rejectedByUid == null &&
               data.rejectedAt == null &&
               data.nextPhaseDate == null && data.nextPhaseStartTime == null && data.nextPhaseEndTime == null && data.nextPhaseVenue == null && data.nextPhaseGuidelines == null;
    }

    function isValidTeamMemberMap(member) {
      return member.id is string && member.id.size() > 0 &&
             member.name is string && member.name.size() >= 1 && member.name.size() <= 100 &&
             member.email is string && member.email.matches('.+@.+\\..+') &&
             member.phone is string && member.phone.size() >= 10 && member.phone.size() <= 15 &&
             member.institute is string && member.institute.size() >= 1 && member.institute.size() <= 100 &&
             member.department is string && member.department.size() >= 1 && member.department.size() <= 100 &&
             (member.enrollmentNumber == null || (member.enrollmentNumber is string && member.enrollmentNumber.size() <= 50)) &&
             // Ensure only these keys are present in a team member map
             member.keys().hasOnly(['id', 'name', 'email', 'phone', 'institute', 'department', 'enrollmentNumber']);
    }

    function isValidStructuredTeamMembersList(membersList) {
      return membersList is list && membersList.size() <= 4 &&
             (membersList.size() == 0 || membersList.all(member, isValidTeamMemberMap(member)));
    }

    function isValidTeamMemberEmailsList(emailsList) {
      return emailsList is list && emailsList.size() <= 4 &&
             (emailsList.size() == 0 || emailsList.all(email, email is string && email.matches('.+@.+\\..+')));
    }

    // Validates data for idea creation or for owner resubmitting an archived idea
    function isIdeaDataValidForUserCreateOrResubmit(userId, data, isCreate, existingData) {
      let userProfile = getUserProfileData(userId);
      return data.userId == userId &&
             data.applicantDisplayName == (userProfile.displayName == null ? userProfile.fullName : userProfile.displayName) &&
             data.applicantEmail == userProfile.email &&
             isValidIdeaCoreContent(data) &&
             isValidOptionalIdeaFields(data) && // Checks optional user-settable fields
             isValidStructuredTeamMembersList(data.structuredTeamMembers) &&
             isValidTeamMemberEmailsList(data.teamMemberEmails) &&
             data.status == 'SUBMITTED' &&
             isValidAdminIdeaFieldsOnUserSubmit(data) && // Ensures admin fields are reset
             isTimestampOrServerTimestamp(data.updatedAt) && data.updatedAt == request.time &&
             (isCreate && isTimestampOrServerTimestamp(data.submittedAt) && data.submittedAt == request.time ||
              !isCreate && data.submittedAt == existingData.submittedAt); // submittedAt immutable on update by user
    }

    function isIdeaDataValidForAdminUpdate(data, existingData) {
        return data.userId == existingData.userId && // immutable
               data.applicantDisplayName == existingData.applicantDisplayName && // immutable
               data.applicantEmail == existingData.applicantEmail && // immutable
               data.title == existingData.title && // immutable by admin
               data.problem == existingData.problem && // immutable by admin
               data.solution == existingData.solution && // immutable by admin
               data.uniqueness == existingData.uniqueness && // immutable by admin
               data.applicantType == existingData.applicantType && // immutable
               data.developmentStage == existingData.developmentStage && // immutable
               data.teamMembers == existingData.teamMembers && // immutable by admin
               data.submittedAt == existingData.submittedAt && // immutable
               (data.fileURL == existingData.fileURL || data.fileURL == null) && // file related fields are user-managed
               (data.fileName == existingData.fileName || data.fileName == null) &&
               (data.phase2PptUrl == existingData.phase2PptUrl || data.phase2PptUrl == null) &&
               (data.phase2PptFileName == existingData.phase2PptFileName || data.phase2PptFileName == null) &&
               (data.phase2PptUploadedAt == existingData.phase2PptUploadedAt || data.phase2PptUploadedAt == null) &&
               (data.studioLocation == existingData.studioLocation || data.studioLocation == null) &&
               isValidIdeaStatus(data.status) &&
               (data.programPhase == null || isValidProgramPhase(data.programPhase)) &&
               (data.cohortId == null || data.cohortId is string) &&
               (data.mentor == null || data.mentor is string) && // Ideally check against MentorName list
               data.phase2Marks is map &&
               (data.rejectionRemarks == null || data.rejectionRemarks is string) &&
               (data.rejectedByUid == null || data.rejectedByUid is string) &&
               (data.rejectedAt == null || data.rejectedAt is timestamp) &&
               (data.nextPhaseDate == null || data.nextPhaseDate is timestamp) &&
               (data.nextPhaseStartTime == null || data.nextPhaseStartTime is string) &&
               (data.nextPhaseEndTime == null || data.nextPhaseEndTime is string) &&
               (data.nextPhaseVenue == null || data.nextPhaseVenue is string) &&
               (data.nextPhaseGuidelines == null || data.nextPhaseGuidelines is string) &&
               isTimestampOrServerTimestamp(data.updatedAt) && data.updatedAt == request.time;
    }

    // ======== Cohort Validation Functions ========
    function isValidCohortScheduleEntryMap(entry) {
      return entry.id is string && isStringAndNotEmpty(entry.id) &&
             entry.date is string && isStringAndNotEmpty(entry.date) &&
             entry.day is string && isStringAndNotEmpty(entry.day) &&
             entry.time is string && isStringAndNotEmpty(entry.time) &&
             entry.category is string && isStringAndNotEmpty(entry.category) &&
             entry.topicActivity is string && isStringAndNotEmpty(entry.topicActivity) &&
             entry.content is string && // content can be empty
             entry.speakerVenue is string && // speakerVenue can be empty
             entry.keys().hasOnly(['id', 'date', 'day', 'time', 'category', 'topicActivity', 'content', 'speakerVenue']);
    }

    function isValidCohortScheduleList(scheduleList) {
      return scheduleList is list &&
             (scheduleList.size() == 0 || scheduleList.all(entry, isValidCohortScheduleEntryMap(entry)));
    }

    function isValidCohortData(data, isCreate, existingData) {
      let userProfile = getUserProfileData(request.auth.uid);
      return isStringAndNotEmpty(data.name) && data.name.size() <= 100 &&
             data.startDate is timestamp &&
             data.endDate is timestamp && data.endDate > data.startDate &&
             data.batchSize is int && data.batchSize >= 1 && data.batchSize <= 200 &&
             data.ideaIds is list && (data.ideaIds.size() == 0 || data.ideaIds.all(id, id is string)) &&
             isValidCohortScheduleList(data.schedule) &&
             isTimestampOrServerTimestamp(data.updatedAt) && data.updatedAt == request.time &&
             (isCreate && data.createdByUid == request.auth.uid && data.creatorDisplayName == (userProfile.displayName == null ? userProfile.fullName : userProfile.displayName) &&
              isTimestampOrServerTimestamp(data.createdAt) && data.createdAt == request.time ||
              !isCreate && data.createdAt == existingData.createdAt && data.createdByUid == existingData.createdByUid && data.creatorDisplayName == existingData.creatorDisplayName);
    }

    // ======== Announcement Validation Functions ========
    function isValidAnnouncementData(data, isCreate, existingData) {
      let userProfile = getUserProfileData(request.auth.uid);
      return isStringAndNotEmpty(data.title) && data.title.size() <= 100 &&
             isStringAndNotEmpty(data.content) && data.content.size() <= 5000 &&
             data.isUrgent is bool &&
             (data.targetAudience == 'ALL' || data.targetAudience == 'SPECIFIC_COHORT') &&
             (data.targetAudience == 'ALL' && data.cohortId == null ||
              data.targetAudience == 'SPECIFIC_COHORT' && data.cohortId is string && isStringAndNotEmpty(data.cohortId)) &&
             isTimestampOrServerTimestamp(data.updatedAt) && data.updatedAt == request.time &&
             (isCreate && data.createdByUid == request.auth.uid && data.creatorDisplayName == (userProfile.displayName == null ? userProfile.fullName : userProfile.displayName) &&
              isTimestampOrServerTimestamp(data.createdAt) && data.createdAt == request.time ||
              !isCreate && data.createdAt == existingData.createdAt && data.createdByUid == existingData.createdByUid && data.creatorDisplayName == existingData.creatorDisplayName) &&
             (data.attachmentURL == null || data.attachmentURL is string) &&
             (data.attachmentName == null || data.attachmentName is string);
    }

    // ======== System Settings Validation Functions ========
    function isValidSystemSettingsData(data) {
        return isStringAndNotEmpty(data.portalName) && data.portalName.size() <= 50 &&
               data.maintenanceMode is bool &&
               data.allowNewRegistrations is bool &&
               data.defaultCohortSize is int && data.defaultCohortSize >= 1 && data.defaultCohortSize <= 100 &&
               isTimestampOrServerTimestamp(data.updatedAt) && data.updatedAt == request.time &&
               data.updatedByUid == request.auth.uid;
    }

    // ======== Firestore Rules ========

    // User Profiles (/users/{userId})
    match /users/{userId} {
      allow read: if isAuthenticated();

      allow create: if isSpecificUser(userId) &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       isValidUserProfileWrite(request.resource.data, null, true) &&
                       isTimestampOrServerTimestamp(request.resource.data.createdAt) && request.resource.data.createdAt == request.time &&
                       isTimestampOrServerTimestamp(request.resource.data.updatedAt) && request.resource.data.updatedAt == request.time &&
                       (request.resource.data.isSuperAdmin == (request.auth.token.email == 'pranavrathi07@gmail.com')) &&
                       request.resource.data.keys().hasOnly([
                         'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin',
                         'fullName', 'contactNumber',
                         'applicantCategory', 'currentStage', 'startupTitle',
                         'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers',
                         'enrollmentNumber', 'college', 'instituteName',
                         'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid',
                         'createdAt', 'updatedAt'
                       ]);

      allow update: if
        // Owner updating their own profile (excluding role, isSuperAdmin)
        (isSpecificUser(userId) &&
         request.resource.data.uid == resource.data.uid &&
         request.resource.data.email == resource.data.email && // email immutable
         request.resource.data.role == resource.data.role && // role not changed by user here
         request.resource.data.isSuperAdmin == resource.data.isSuperAdmin && // superAdmin not changed by user here
         isValidUserProfileWrite(request.resource.data, resource.data, false) &&
         isTimestampOrServerTimestamp(request.resource.data.updatedAt) && request.resource.data.updatedAt == request.time &&
         request.resource.data.createdAt == resource.data.createdAt && // createdAt immutable
         // isTeamMemberOnly status reflects idea linkage, not directly user-editable here
         request.resource.data.isTeamMemberOnly == resource.data.isTeamMemberOnly &&
         request.resource.data.associatedIdeaId == resource.data.associatedIdeaId &&
         request.resource.data.associatedTeamLeaderUid == resource.data.associatedTeamLeaderUid &&
         request.writeFields.hasAll(['updatedAt']) && // Ensure updatedAt is always part of the update
         !request.writeFields.hasAny(['uid', 'email', 'role', 'isSuperAdmin', 'createdAt'])
        ) ||
        // Admin updating another user's profile
        (isUserAdmin(request.auth.uid) &&
         request.resource.data.uid == userId &&
         request.resource.data.email == resource.data.email && // email immutable
         isValidRole(request.resource.data.role) &&
         (request.resource.data.isSuperAdmin == false || (request.resource.data.isSuperAdmin == true && request.resource.data.role == 'ADMIN_FACULTY')) &&
         // Check if the primary super admin is being demoted or role changed by non-self
         !(resource.data.email == 'pranavrathi07@gmail.com' && request.auth.token.email != 'pranavrathi07@gmail.com' &&
           (request.resource.data.role != 'ADMIN_FACULTY' || request.resource.data.isSuperAdmin == false)) &&
         // SuperAdmin status can only be granted by another SuperAdmin
         (request.resource.data.isSuperAdmin == true && resource.data.isSuperAdmin == false && !isUserSuperAdmin(request.auth.uid) ? false : true) &&
         isValidUserProfileWrite(request.resource.data, resource.data, false) && // Validates personal/idea fields if changed by admin
         isTimestampOrServerTimestamp(request.resource.data.updatedAt) && request.resource.data.updatedAt == request.time &&
         request.resource.data.createdAt == resource.data.createdAt && // createdAt immutable
         !request.writeFields.hasAny(['uid', 'email', 'createdAt'])
        );

      allow delete: if isUserAdmin(request.auth.uid) &&
                       resource.data.email != 'pranavrathi07@gmail.com'; // Prevent primary super admin deletion
    }

    // Idea Submissions (/ideas/{ideaId})
    match /ideas/{ideaId} {
      allow read: if isAuthenticated();

      allow create: if isOwner(request.resource.data.userId) &&
                       isIdeaDataValidForUserCreateOrResubmit(request.auth.uid, request.resource.data, true, null) &&
                       request.resource.data.keys().hasOnly([
                         'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category', 'problem', 'solution', 'uniqueness',
                         'developmentStage', 'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
                         'fileURL', 'fileName', 'studioLocation', // optional user fields
                         'status', 'programPhase', 'cohortId', 'phase2Marks', 'mentor',
                         'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                         'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                         'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                         'submittedAt', 'updatedAt'
                       ]);

      allow update: if
        // Case 1: Owner resubmitting an ARCHIVED_BY_ADMIN idea
        (isOwner(resource.data.userId) &&
         resource.data.status == 'ARCHIVED_BY_ADMIN' &&
         request.resource.data.status == 'SUBMITTED' &&
         isIdeaDataValidForUserCreateOrResubmit(request.auth.uid, request.resource.data, false, resource.data) &&
         request.writeFields.hasOnly([ // Exact fields that can change during resubmit
            'title', 'problem', 'solution', 'uniqueness', 'applicantType', 'developmentStage', 'teamMembers',
            'structuredTeamMembers', 'teamMemberEmails', // User can update team
            'status', // to SUBMITTED
            'programPhase', 'cohortId', 'phase2Marks', 'mentor', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', // Reset by system
            'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', // Reset by system
            'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', // Reset by system
            'updatedAt'
         ])
        ) ||
        // Case 2: Owner updating specific allowed fields (PPT, team) on their non-archived idea
        (isOwner(resource.data.userId) &&
         resource.data.status != 'ARCHIVED_BY_ADMIN' &&
         request.resource.data.userId == resource.data.userId && // userId immutable
         request.resource.data.status == resource.data.status && // status not changed by user here
         request.resource.data.programPhase == resource.data.programPhase && // programPhase not changed by user here
         isTimestampOrServerTimestamp(request.resource.data.updatedAt) && request.resource.data.updatedAt == request.time &&
         ( // Either PPT update or Team update
           ( // PPT Update
             request.writeFields.hasAll(['phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt']) &&
             request.writeFields.size() == 4 && // only these fields
             isStringOrNull(request.resource.data.phase2PptUrl) &&
             isStringOrNull(request.resource.data.phase2PptFileName) &&
             (request.resource.data.phase2PptUploadedAt == null || request.resource.data.phase2PptUploadedAt is timestamp)
           ) ||
           ( // Team Management Update
             (request.writeFields.has('structuredTeamMembers') || request.writeFields.has('teamMemberEmails')) &&
             request.writeFields.has('updatedAt') &&
             isValidStructuredTeamMembersList(request.resource.data.structuredTeamMembers) &&
             isValidTeamMemberEmailsList(request.resource.data.teamMemberEmails) &&
             // Ensure no other fields are being modified during team management
             request.writeFields.hasOnly(['structuredTeamMembers', 'teamMemberEmails', 'updatedAt'])
           )
         )
        ) ||
        // Case 3: Admin updating an idea
        (isUserAdmin(request.auth.uid) &&
         isIdeaDataValidForAdminUpdate(request.resource.data, resource.data) && // Validates admin-modifiable fields
         // Ensure admin is only writing fields they are allowed to, and not user-core content
         request.writeFields.hasAny([
            'status', 'programPhase', 'cohortId', 'mentor', 'phase2Marks',
            'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
            'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
            'updatedAt'
         ]) &&
         !request.writeFields.hasAny([ // Fields admin cannot change
            'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'problem', 'solution', 'uniqueness',
            'applicantType', 'developmentStage', 'teamMembers', 'submittedAt',
            'fileURL', 'fileName', 'studioLocation',
            'structuredTeamMembers', 'teamMemberEmails',
            'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt'
         ])
        );

      allow delete: if false; // No direct deletion, only archive-via-update by admin
    }

    // Cohorts (/cohorts/{cohortId})
    match /cohorts/{cohortId} {
      allow read: if isAuthenticated();

      allow create: if isUserAdmin(request.auth.uid) &&
                       isValidCohortData(request.resource.data, true, null) &&
                       request.resource.data.keys().hasOnly([
                         'name', 'startDate', 'endDate', 'batchSize', 'ideaIds', 'schedule',
                         'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt'
                       ]);

      allow update: if isUserAdmin(request.auth.uid) &&
                       isValidCohortData(request.resource.data, false, resource.data) &&
                       !request.writeFields.hasAny(['createdByUid', 'creatorDisplayName', 'createdAt']);

      allow delete: if isUserSuperAdmin(request.auth.uid); // Only super admins for now
    }

    // Announcements (/announcements/{announcementId})
    match /announcements/{announcementId} {
      allow read: if isAuthenticated();

      allow create: if isUserAdmin(request.auth.uid) &&
                       isValidAnnouncementData(request.resource.data, true, null) &&
                       request.resource.data.keys().hasOnly([
                         'title', 'content', 'isUrgent', 'targetAudience', 'cohortId',
                         'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt',
                         'attachmentURL', 'attachmentName' // Optional fields
                       ]);

      allow update: if isUserAdmin(request.auth.uid) &&
                       isValidAnnouncementData(request.resource.data, false, resource.data) &&
                       !request.writeFields.hasAny(['createdByUid', 'creatorDisplayName', 'createdAt']);

      allow delete: if isUserAdmin(request.auth.uid);
    }

    // System Settings (/systemSettings/config)
    match /systemSettings/config {
      allow read: if isAuthenticated();

      allow write: if isUserAdmin(request.auth.uid) &&
                      isValidSystemSettingsData(request.resource.data) &&
                      request.resource.data.keys().hasOnly([
                        'portalName', 'maintenanceMode', 'allowNewRegistrations', 'defaultCohortSize',
                        'updatedAt', 'updatedByUid'
                      ]);
    }

    // Activity Logs (/activityLogs/{logId})
    match /activityLogs/{logId} {
      allow read: if isUserAdmin(request.auth.uid); // Only admins can read
      allow write: if false; // Typically written by backend/trusted functions
    }
  }
}

