
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    function isEmailVerified() {
      return isSignedIn() && request.auth.token.email_verified;
    }

    function getUserProfileData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isUserProfileAdmin(userId) {
      let userProfile = getUserProfileData(userId);
      return userProfile != null && userProfile.role == 'ADMIN_FACULTY';
    }

    function isUserProfileSuperAdmin(userId) {
      let userProfile = getUserProfileData(userId);
      return userProfile != null && userProfile.role == 'ADMIN_FACULTY' && userProfile.isSuperAdmin == true;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isUserProfileCompleteForIdeaSubmission(userId) {
      let userProfile = getUserProfileData(userId);
      return userProfile != null &&
             userProfile.fullName != null && userProfile.fullName.size() > 0 &&
             userProfile.contactNumber != null && userProfile.contactNumber.size() > 0 &&
             userProfile.startupTitle != null && userProfile.startupTitle.size() > 0 &&
             userProfile.problemDefinition != null && userProfile.problemDefinition.size() > 0 &&
             userProfile.solutionDescription != null && userProfile.solutionDescription.size() > 0 &&
             userProfile.uniqueness != null && userProfile.uniqueness.size() > 0 &&
             userProfile.applicantCategory != null && (
                userProfile.applicantCategory == 'PARUL_STUDENT' ||
                userProfile.applicantCategory == 'PARUL_STAFF' ||
                userProfile.applicantCategory == 'PARUL_ALUMNI' ||
                userProfile.applicantCategory == 'OTHERS'
             ) &&
             userProfile.currentStage != null && (
                userProfile.currentStage == 'IDEA' ||
                userProfile.currentStage == 'PROTOTYPE_STAGE' ||
                userProfile.currentStage == 'STARTUP_STAGE'
             );
    }
    
    function isString(value) {
      return value is string;
    }

    function isStringOrNull(value) {
      return value == null || value is string;
    }
    
    function isBoolean(value) {
      return value is bool;
    }

    function isNumber(value) {
      return value is number;
    }

    function isNumberOrNull(value) {
      return value == null || value is number;
    }

    function isTimestamp(value) {
      return value is timestamp;
    }

    function isTimestampOrNull(value) {
      return value == null || value is timestamp;
    }
    
    function isList(value) {
      return value is list;
    }

    function isMap(value) {
      return value is map;
    }
    
    function isNonEmptyString(value) {
      return value is string && value.size() > 0;
    }

    function isValidRole(role) {
      return role == 'STUDENT' || role == 'EXTERNAL_USER' || role == 'ADMIN_FACULTY';
    }

    function isValidApplicantCategory(category) {
      return category == 'PARUL_STUDENT' || category == 'PARUL_STAFF' || category == 'PARUL_ALUMNI' || category == 'OTHERS';
    }

    function isValidCurrentStage(stage) {
      return stage == 'IDEA' || stage == 'PROTOTYPE_STAGE' || stage == 'STARTUP_STAGE';
    }
    
    function isValidIdeaStatus(status) {
      return status == 'SUBMITTED' || status == 'UNDER_REVIEW' || status == 'IN_EVALUATION' || status == 'SELECTED' || status == 'NOT_SELECTED' || status == 'ARCHIVED_BY_ADMIN';
    }
    
    function isValidProgramPhaseOrNull(phase) {
      return phase == null || phase == 'PHASE_1' || phase == 'PHASE_2' || phase == 'COHORT';
    }

    function isValidMentorNameOrNull(mentor) {
      // This list must be manually kept in sync with AVAILABLE_MENTORS_DATA in src/types/index.ts
      let validMentorNames = [
        'Prashant Khanna', 'Riddhi Bagha', 'Nikhil Jumde', 'Jay Sudani', 
        'Hardik Kharva', 'Sonal Sudani', 'Pancham Baraiya', 'Juned Shaikh'
      ];
      return mentor == null || mentor in validMentorNames;
    }

    function isIdeaCreatorNotUsingAdminPlaceholderData(userId, data) {
      // Prevents ideas from being created if the user's profile has admin placeholder idea details
      let userProfile = getUserProfileData(userId);
      if (userProfile == null || userProfile.role != 'ADMIN_FACULTY') {
        return true; // Not an admin, or profile doesn't exist (should be caught by other rules)
      }
      // Check if the idea data matches the admin placeholder content
      let isUsingAdminPlaceholder = (
        (userProfile.email == 'pranavrathi07@gmail.com' && 
          data.startupTitle == 'Administrative Account' && 
          data.problemDefinition == 'Handles portal administration.' &&
          data.solutionDescription == 'Provides administrative functions and support.' &&
          data.uniqueness == 'Unique administrative role for system management.') ||
        (userProfile.email != 'pranavrathi07@gmail.com' && // Generic mentor check
          data.startupTitle == 'Faculty/Mentor Account' &&
          data.problemDefinition == 'Manages portal functions and/or mentorship.' &&
          data.solutionDescription == 'Provides administrative or mentorship support.' &&
          data.uniqueness == 'Unique administrative/mentorship role.')
      );
      return !isUsingAdminPlaceholder;
    }
    
    function isValidIdeaContent(data) {
      return isNonEmptyString(data.title) && data.title.size() <= 200 &&
             isNonEmptyString(data.problem) && data.problem.size() >= 10 && data.problem.size() <= 2000 &&
             isNonEmptyString(data.solution) && data.solution.size() >= 10 && data.solution.size() <= 2000 &&
             isNonEmptyString(data.uniqueness) && data.uniqueness.size() >= 10 && data.uniqueness.size() <= 2000 &&
             isValidApplicantCategory(data.applicantType) &&
             isValidCurrentStage(data.developmentStage) &&
             (data.teamMembers == null || (isString(data.teamMembers) && data.teamMembers.size() <= 500));
    }

    function validateAdminMarkMap(marksMap) {
      if (marksMap == null || !(marksMap is map)) {
        return false;
      }
      if (marksMap.keys().size() == 0) {
        return true; // Empty map is valid
      }
      // Check each entry in the map
      return marksMap.keys().all(adminUid =>
        marksMap[adminUid] is map &&
        (marksMap[adminUid].mark == null || (marksMap[adminUid].mark is number && marksMap[adminUid].mark >= 0 && marksMap[adminUid].mark <= 100)) &&
        isNonEmptyString(marksMap[adminUid].adminDisplayName) &&
        marksMap[adminUid].markedAt is timestamp
      );
    }
    
    function validateTeamMember(member) {
        return member is map &&
               isNonEmptyString(member.id) &&
               isNonEmptyString(member.name) && member.name.size() <= 100 &&
               isNonEmptyString(member.email) && member.email.matches('.+@.+\..+') && // Basic email regex
               isNonEmptyString(member.phone) && member.phone.size() >= 10 && member.phone.size() <= 15 &&
               isNonEmptyString(member.institute) && member.institute.size() <= 100 &&
               isNonEmptyString(member.department) && member.department.size() <= 100 &&
               (member.enrollmentNumber == null || (isString(member.enrollmentNumber) && member.enrollmentNumber.size() <= 50));
    }

    function validateStructuredTeamMembers(membersList) {
        return membersList is list && membersList.size() <= 4 &&
               membersList.all(member => validateTeamMember(member));
    }

    function validateTeamMemberEmails(emailList) {
        return emailList is list && emailList.size() <= 4 &&
               emailList.all(email => isString(email) && email.matches('.+@.+\..+'));
    }

    function isValidIdeaSubmissionOnCreateOrResubmit(userId, data, isCreate) {
      return isOwner(userId) && // User must be the owner
             data.userId == userId &&
             isUserProfileCompleteForIdeaSubmission(userId) && // User's profile must be complete
             isValidIdeaContent(data) && // Core idea content is valid
             isIdeaCreatorNotUsingAdminPlaceholderData(userId, data) && // Not using admin placeholder content
             data.status == 'SUBMITTED' && // Status must be 'SUBMITTED'
             data.programPhase == null && // programPhase must be null
             data.cohortId == null && // cohortId must be null
             data.phase2Marks is map && data.phase2Marks.keys().size() == 0 && // phase2Marks must be an empty map
             data.mentor == null && // mentor must be null
             data.rejectionRemarks == null && // rejectionRemarks must be null
             data.rejectedByUid == null && // rejectedByUid must be null
             data.rejectedAt == null && // rejectedAt must be null
             data.phase2PptUrl == null && // phase2PptUrl must be null
             data.phase2PptFileName == null && // phase2PptFileName must be null
             data.phase2PptUploadedAt == null && // phase2PptUploadedAt must be null
             data.nextPhaseDate == null && data.nextPhaseStartTime == null && data.nextPhaseEndTime == null && data.nextPhaseVenue == null && data.nextPhaseGuidelines == null &&
             validateStructuredTeamMembers(data.structuredTeamMembers) && // teamMembers array is valid
             validateTeamMemberEmails(data.teamMemberEmails) && // teamMemberEmails array is valid
             isStringOrNull(data.applicantDisplayName) && // Ensure applicantDisplayName is a string or null
             isStringOrNull(data.applicantEmail) && // Ensure applicantEmail is a string or null
             (isCreate ? data.submittedAt == request.time : data.submittedAt is timestamp) && // submittedAt is set on create, immutable on update
             data.updatedAt == request.time; // updatedAt always updated
    }
    
    function isValidUserProfileData(data, isCreate) {
        let isValidCommon = 
            isNonEmptyString(data.fullName) && data.fullName.size() <= 100 &&
            isNonEmptyString(data.contactNumber) && data.contactNumber.size() >= 10 && data.contactNumber.size() <= 15 &&
            (data.enrollmentNumber == null || (isString(data.enrollmentNumber) && data.enrollmentNumber.size() <= 50)) &&
            (data.college == null || (isString(data.college) && data.college.size() <= 100)) &&
            (data.instituteName == null || (isString(data.instituteName) && data.instituteName.size() <= 100));

        let isValidRoleSpecific;
        if (data.isTeamMemberOnly == true) {
            isValidRoleSpecific =
                data.startupTitle == null &&
                data.problemDefinition == null &&
                data.solutionDescription == null &&
                data.uniqueness == null &&
                data.applicantCategory == null &&
                data.currentStage == null &&
                data.teamMembers == null &&
                isStringOrNull(data.associatedIdeaId) &&
                isStringOrNull(data.associatedTeamLeaderUid);
        } else { // Idea owner, Admin, Mentor
            isValidRoleSpecific = 
                (data.startupTitle == null || (isString(data.startupTitle) && data.startupTitle.size() <= 200)) &&
                (data.problemDefinition == null || (isString(data.problemDefinition) && data.problemDefinition.size() <= 2000)) &&
                (data.solutionDescription == null || (isString(data.solutionDescription) && data.solutionDescription.size() <= 2000)) &&
                (data.uniqueness == null || (isString(data.uniqueness) && data.uniqueness.size() <= 2000)) &&
                (data.applicantCategory == null || isValidApplicantCategory(data.applicantCategory)) &&
                (data.currentStage == null || isValidCurrentStage(data.currentStage)) &&
                (data.teamMembers == null || (isString(data.teamMembers) && data.teamMembers.size() <= 500)) &&
                data.associatedIdeaId == null &&
                data.associatedTeamLeaderUid == null;

            // Specific checks for non-admin placeholders if not a team member
            if (data.role != 'ADMIN_FACULTY' && data.startupTitle != null) { // If idea fields are present, they must be valid
              isValidRoleSpecific = isValidRoleSpecific &&
                isNonEmptyString(data.startupTitle) && data.startupTitle.size() >= 5 &&
                isNonEmptyString(data.problemDefinition) && data.problemDefinition.size() >= 10 &&
                isNonEmptyString(data.solutionDescription) && data.solutionDescription.size() >= 10 &&
                isNonEmptyString(data.uniqueness) && data.uniqueness.size() >= 10 &&
                data.applicantCategory != null && data.currentStage != null;
            }
        }
        
        let isValidTimestamps;
        if (isCreate) {
            isValidTimestamps = data.createdAt == request.time && data.updatedAt == request.time;
        } else {
            isValidTimestamps = data.updatedAt == request.time && !('createdAt' in request.resource.data);
        }

        return isValidCommon && isValidRoleSpecific && isValidTimestamps &&
               isStringOrNull(data.email) &&
               isStringOrNull(data.displayName) &&
               isStringOrNull(data.photoURL) &&
               isValidRole(data.role) &&
               isBoolean(data.isSuperAdmin) &&
               isBoolean(data.isTeamMemberOnly);
    }
    
    // USERS collection
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(userId) &&
                       request.resource.data.uid == userId &&
                       isValidUserProfileData(request.resource.data, true) &&
                       request.resource.data.keys().hasOnly([
                         'uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'isTeamMemberOnly',
                         'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                         'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                         'applicantCategory', 'currentStage', 'teamMembers',
                         'associatedIdeaId', 'associatedTeamLeaderUid',
                         'createdAt', 'updatedAt'
                       ]);
      allow update: if (isOwner(userId) || isUserProfileSuperAdmin(request.auth.uid)) &&
                       isValidUserProfileData(request.resource.data, false) &&
                       request.resource.data.uid == resource.data.uid && // uid cannot change
                       request.resource.data.email == resource.data.email && // email cannot change
                       // Only super admin can change role or super admin status of others
                       (isUserProfileSuperAdmin(request.auth.uid) || (
                         request.resource.data.role == resource.data.role &&
                         request.resource.data.isSuperAdmin == resource.data.isSuperAdmin
                       )) &&
                       // User can only modify a subset of fields if not admin
                       (isUserProfileSuperAdmin(request.auth.uid) ?
                         request.resource.data.keys().hasOnly([ // Super admin can update almost all, except immutable
                            'displayName', 'photoURL', 'role', 'isSuperAdmin', 'isTeamMemberOnly',
                            'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                            'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                            'applicantCategory', 'currentStage', 'teamMembers',
                            'associatedIdeaId', 'associatedTeamLeaderUid',
                            'updatedAt'
                         ]) :
                         request.resource.data.keys().hasOnly([ // Regular user or non-super admin
                            'displayName', 'photoURL',
                            'fullName', 'contactNumber', 'enrollmentNumber', 'college', 'instituteName',
                            'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness',
                            'applicantCategory', 'currentStage', 'teamMembers',
                            'updatedAt'
                         ])
                       );
      allow delete: if (isOwner(userId) && resource.data.email != 'pranavrathi07@gmail.com') || // User can delete their own account (unless it's the primary super admin)
                       (isUserProfileSuperAdmin(request.auth.uid) && resource.data.email != 'pranavrathi07@gmail.com'); // Super admin can delete others (unless primary)
    }

    // IDEAS collection
    match /ideas/{ideaId} {
      allow read: if isSignedIn(); // Any signed-in user can read idea details (e.g., team members, admins)
      
      allow create: if isSignedIn() &&
                       isOwner(request.resource.data.userId) &&
                       isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, true) &&
                       // Ensure only expected fields are present on initial creation by user
                       request.resource.data.keys().hasOnly([
                         'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category',
                         'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType',
                         'teamMembers', 'structuredTeamMembers', 'teamMemberEmails', 'status', 'programPhase',
                         'cohortId', 'phase2Marks', 'mentor', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                         'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt',
                         'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                         'submittedAt', 'updatedAt'
                         // fileURL, fileName, studioLocation are optional and added by user later, not via createIdeaFromProfile
                       ]);

      allow update: if isSignedIn() && (
                      // Path 1: Owner updating their own idea details (e.g., resubmitting archived, or profile update syncs)
                      (isOwner(resource.data.userId) &&
                        isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, false) &&
                        // Specific conditions for resubmitting an archived idea by the owner
                        ( (resource.data.status == 'ARCHIVED_BY_ADMIN' && request.resource.data.status == 'SUBMITTED') || 
                          (resource.data.status != 'ARCHIVED_BY_ADMIN' && request.resource.data.status == resource.data.status) // if not archived, status cannot change by owner
                        ) &&
                        request.resource.data.userId == resource.data.userId && // userId cannot change
                        request.resource.data.applicantDisplayName == resource.data.applicantDisplayName && // these are derived from profile
                        request.resource.data.applicantEmail == resource.data.applicantEmail && // these are derived from profile
                        request.resource.data.submittedAt == resource.data.submittedAt && // submittedAt cannot change
                        // Owner can update these specific fields or reset them if archived
                        request.writeFields.hasAny([
                          'title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType',
                          'teamMembers', 'structuredTeamMembers', 'teamMemberEmails', 'status', 'updatedAt',
                          // Fields that get reset/nulled on resubmission of archived
                          'programPhase', 'cohortId', 'phase2Marks', 'mentor', 'rejectionRemarks',
                          'rejectedByUid', 'rejectedAt', 'phase2PptUrl', 'phase2PptFileName',
                          'phase2PptUploadedAt', 'nextPhaseDate', 'nextPhaseStartTime',
                          'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines'
                        ])
                      ) ||
                      // Path 2: Owner uploading Phase 2 PPT
                      (isOwner(resource.data.userId) &&
                        resource.data.status == 'SELECTED' && resource.data.programPhase == 'PHASE_2' &&
                        isStringOrNull(request.resource.data.phase2PptUrl) &&
                        isStringOrNull(request.resource.data.phase2PptFileName) &&
                        (request.resource.data.phase2PptUploadedAt == request.time || request.resource.data.phase2PptUploadedAt == null) &&
                        request.resource.data.updatedAt == request.time &&
                        request.writeFields.hasOnly([
                          'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt'
                        ]) &&
                        // Immutable fields
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.title == resource.data.title &&
                        request.resource.data.status == resource.data.status &&
                        request.resource.data.programPhase == resource.data.programPhase
                      ) ||
                      // Path 3: Admin updating status, phase, remarks, mentor, cohortId, or phase2 marks
                      (isUserProfileAdmin(request.auth.uid) &&
                        isValidIdeaStatus(request.resource.data.status) &&
                        isValidProgramPhaseOrNull(request.resource.data.programPhase) &&
                        isStringOrNull(request.resource.data.rejectionRemarks) &&
                        isStringOrNull(request.resource.data.rejectedByUid) &&
                        isTimestampOrNull(request.resource.data.rejectedAt) &&
                        isValidMentorNameOrNull(request.resource.data.mentor) &&
                        isStringOrNull(request.resource.data.cohortId) &&
                        validateAdminMarkMap(request.resource.data.phase2Marks) &&
                        isTimestampOrNull(request.resource.data.nextPhaseDate) &&
                        isStringOrNull(request.resource.data.nextPhaseStartTime) &&
                        isStringOrNull(request.resource.data.nextPhaseEndTime) &&
                        isStringOrNull(request.resource.data.nextPhaseVenue) &&
                        isStringOrNull(request.resource.data.nextPhaseGuidelines) &&
                        request.resource.data.updatedAt == request.time &&
                        // Admins can write to these fields:
                        request.writeFields.hasAny([
                          'status', 'programPhase', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt',
                          'mentor', 'cohortId', 'phase2Marks', 'updatedAt',
                          'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines',
                          'updatedByMentorAssignerUid' // Added for mentor assignment tracking
                        ]) &&
                        // Immutable by admin in this operation
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.title == resource.data.title // Title is primarily user-controlled
                      ) ||
                      // Path 4: Owner managing team members (add, update, remove - simplified check for writeFields)
                      (isOwner(resource.data.userId) &&
                        request.resource.data.userId == resource.data.userId &&
                        validateStructuredTeamMembers(request.resource.data.structuredTeamMembers) &&
                        validateTeamMemberEmails(request.resource.data.teamMemberEmails) &&
                        request.resource.data.updatedAt == request.time &&
                        request.writeFields.hasAny(['structuredTeamMembers', 'teamMemberEmails', 'updatedAt'])
                      )
                    );
      allow delete: if false; // Prevent direct deletion, use status 'ARCHIVED_BY_ADMIN' via update

    }
    
    // ANNOUNCEMENTS collection
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isUserProfileAdmin(request.auth.uid) &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       isNonEmptyString(request.resource.data.title) && request.resource.data.title.size() <= 100 &&
                       isNonEmptyString(request.resource.data.content) && request.resource.data.content.size() <= 5000 &&
                       isBoolean(request.resource.data.isUrgent) &&
                       (request.resource.data.targetAudience == 'ALL' || request.resource.data.targetAudience == 'SPECIFIC_COHORT') &&
                       (request.resource.data.targetAudience == 'ALL' ? request.resource.data.cohortId == null : isNonEmptyString(request.resource.data.cohortId)) &&
                       isStringOrNull(request.resource.data.attachmentURL) &&
                       isStringOrNull(request.resource.data.attachmentName) &&
                       isStringOrNull(request.resource.data.creatorDisplayName) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.keys().hasOnly([
                         'title', 'content', 'isUrgent', 'targetAudience', 'cohortId',
                         'attachmentURL', 'attachmentName', 'createdByUid', 'creatorDisplayName',
                         'createdAt', 'updatedAt'
                       ]);
      allow update: if isUserProfileAdmin(request.auth.uid) &&
                       // createdByUid, createdAt cannot change
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       isNonEmptyString(request.resource.data.title) && request.resource.data.title.size() <= 100 &&
                       isNonEmptyString(request.resource.data.content) && request.resource.data.content.size() <= 5000 &&
                       isBoolean(request.resource.data.isUrgent) &&
                       (request.resource.data.targetAudience == 'ALL' || request.resource.data.targetAudience == 'SPECIFIC_COHORT') &&
                       (request.resource.data.targetAudience == 'ALL' ? request.resource.data.cohortId == null : isNonEmptyString(request.resource.data.cohortId)) &&
                       isStringOrNull(request.resource.data.attachmentURL) &&
                       isStringOrNull(request.resource.data.attachmentName) &&
                       isStringOrNull(request.resource.data.creatorDisplayName) && // Admin might update display name if their profile name changes
                       request.resource.data.updatedAt == request.time &&
                       request.writeFields.hasAny([ // Allowed fields for update by admin
                         'title', 'content', 'isUrgent', 'targetAudience', 'cohortId',
                         'attachmentURL', 'attachmentName', 'creatorDisplayName', 'updatedAt'
                       ]);
      allow delete: if isUserProfileAdmin(request.auth.uid);
    }
    
    // COHORTS collection
    function isValidCohortScheduleEntry(entry) {
      return entry is map &&
             isNonEmptyString(entry.id) &&
             isNonEmptyString(entry.date) && // Assuming date is string like YYYY-MM-DD
             isNonEmptyString(entry.day) &&
             isNonEmptyString(entry.time) &&
             isNonEmptyString(entry.category) &&
             isNonEmptyString(entry.topicActivity) &&
             isString(entry.content) && // content can be empty string
             isString(entry.speakerVenue); // speakerVenue can be empty string
    }

    function isValidCohortSchedule(schedule) {
      return schedule is list && schedule.all(entry => isValidCohortScheduleEntry(entry));
    }

    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isUserProfileAdmin(request.auth.uid) &&
                       request.resource.data.createdByUid == request.auth.uid &&
                       isNonEmptyString(request.resource.data.name) && request.resource.data.name.size() <= 100 &&
                       isTimestamp(request.resource.data.startDate) &&
                       isTimestamp(request.resource.data.endDate) &&
                       request.resource.data.startDate < request.resource.data.endDate &&
                       isNumber(request.resource.data.batchSize) && request.resource.data.batchSize >= 1 && request.resource.data.batchSize <= 200 &&
                       request.resource.data.ideaIds is list && request.resource.data.ideaIds.size() == 0 && // Initially empty
                       isValidCohortSchedule(request.resource.data.schedule) && request.resource.data.schedule.size() == 0 && // Initially empty schedule
                       isStringOrNull(request.resource.data.creatorDisplayName) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.keys().hasOnly([
                         'name', 'startDate', 'endDate', 'batchSize', 'ideaIds', 'schedule',
                         'createdByUid', 'creatorDisplayName', 'createdAt', 'updatedAt'
                       ]);
      allow update: if isUserProfileAdmin(request.auth.uid) &&
                       // createdByUid, createdAt cannot change
                       request.resource.data.createdByUid == resource.data.createdByUid &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       isNonEmptyString(request.resource.data.name) && request.resource.data.name.size() <= 100 &&
                       isTimestamp(request.resource.data.startDate) &&
                       isTimestamp(request.resource.data.endDate) &&
                       request.resource.data.startDate < request.resource.data.endDate &&
                       isNumber(request.resource.data.batchSize) && request.resource.data.batchSize >= 1 && request.resource.data.batchSize <= 200 &&
                       request.resource.data.ideaIds is list && // Idea IDs can be updated
                       isValidCohortSchedule(request.resource.data.schedule) && // Schedule can be updated
                       isStringOrNull(request.resource.data.creatorDisplayName) && // Might update if admin's name changes
                       request.resource.data.updatedAt == request.time &&
                       request.writeFields.hasAny([ // Allowed fields for update by admin
                         'name', 'startDate', 'endDate', 'batchSize', 'ideaIds', 'schedule',
                         'creatorDisplayName', 'updatedAt'
                       ]);
      allow delete: if isUserProfileSuperAdmin(request.auth.uid); // Only Super Admin can delete cohorts
    }
    
    // SYSTEM SETTINGS collection
    match /systemSettings/{settingsId} {
      allow read: if isSignedIn();
      allow create, update: if isUserProfileAdmin(request.auth.uid) &&
                               settingsId == 'config' && // Only one config document
                               isNonEmptyString(request.resource.data.portalName) && request.resource.data.portalName.size() <= 50 &&
                               isBoolean(request.resource.data.maintenanceMode) &&
                               isBoolean(request.resource.data.allowNewRegistrations) &&
                               isNumber(request.resource.data.defaultCohortSize) && request.resource.data.defaultCohortSize >= 1 && request.resource.data.defaultCohortSize <= 100 &&
                               request.resource.data.updatedAt == request.time &&
                               request.resource.data.updatedByUid == request.auth.uid &&
                               request.resource.data.keys().hasOnly([
                                 'portalName', 'maintenanceMode', 'allowNewRegistrations', 'defaultCohortSize',
                                 'updatedAt', 'updatedByUid'
                               ]);
      allow delete: if false; // System settings should not be deleted
    }

    // ACTIVITY LOGS collection
    match /activityLogs/{logId} {
      allow read: if isUserProfileAdmin(request.auth.uid); // Only admins can read activity logs
      allow write: if isSignedIn(); // Any signed-in user's actions can generate a log (client-side logging implies this)
                                  // Server-side triggers would be more secure for logging admin actions.
                                  // For client-side: ensure actorUid matches request.auth.uid for self-logging.
                                  // request.resource.data.actorUid == request.auth.uid
      // For now, keeping write open for signed-in users as per client-side logging pattern.
      // Add more specific checks if moving to server-side triggers:
      // e.g., request.resource.data.actorUid == request.auth.uid &&
      //       request.resource.data.timestamp == request.time &&
      //       isNonEmptyString(request.resource.data.action)
    }
  }
}

    