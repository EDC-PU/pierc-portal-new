
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isUserProfileAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN_FACULTY';
    }

    function isUserProfileSuperAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function getMentorEmails() {
      return [
        'prashant.khanna8747@paruluniversity.ac.in',
        'riddhi.bagha29080@paruluniversity.ac.in',
        'nikhil.jumade24167@paruluniversity.ac.in',
        'jay.sudani@paruluniversity.ac.in',
        'hardik.kharva2899@paruluniversity.ac.in',
        'sonal.sudani23321@paruluniversity.ac.in',
        'panchamkumar.baraiya28771@paruluniversity.ac.in',
        'juned.shaikh32161@paruluniversity.ac.in'
      ];
    }

    function isMentorEmail(email) {
      return email in getMentorEmails();
    }
    
    function getUserProfileData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isMentorPlaceholderFields(data) {
      return (data.startupTitle == 'Administrative Account' || data.startupTitle == 'Faculty/Mentor Account') &&
             (data.problemDefinition == 'Handles portal administration and/or mentorship.' || data.problemDefinition == 'Handles portal administration.' || data.problemDefinition == 'Manages portal functions and/or mentorship.') &&
             (data.solutionDescription == 'Provides administrative/mentorship functions and support.' || data.solutionDescription == 'Provides administrative functions and support.' || data.solutionDescription == 'Provides administrative or mentorship support.') &&
             (data.uniqueness == 'Unique administrative/mentorship role for system management.' || data.uniqueness == 'Unique administrative/mentorship role.') &&
             data.currentStage == 'STARTUP_STAGE' && // Default placeholder
             data.applicantCategory == 'PARUL_STAFF'; // Default placeholder
    }

    function isValidIdeaOwnerFields(data, isParulEmailAssociated) {
      // Common fields for all idea owners
      let commonValid = data.fullName is string && data.fullName.size() > 0 &&
                       data.contactNumber is string && data.contactNumber.size() >= 10 &&
                       data.startupTitle is string && data.startupTitle.size() >= 5 &&
                       data.problemDefinition is string && data.problemDefinition.size() >= 10 &&
                       data.solutionDescription is string && data.solutionDescription.size() >= 10 &&
                       data.uniqueness is string && data.uniqueness.size() >= 10 &&
                       data.applicantCategory in ['PARUL_STUDENT', 'PARUL_STAFF', 'PARUL_ALUMNI', 'OTHERS'] &&
                       data.currentStage in ['IDEA', 'PROTOTYPE_STAGE', 'STARTUP_STAGE'] &&
                       (data.teamMembers == null || data.teamMembers is string);

      // Fields specific if Parul Student based on applicant category
      let parulStudentValid = true;
      if (data.applicantCategory == 'PARUL_STUDENT') {
        parulStudentValid = data.enrollmentNumber is string && data.enrollmentNumber.size() > 0 &&
                            data.college is string && data.college.size() > 0;
      }
      
      // Fields specific if Parul email but not student (e.g. staff, alumni)
      let parulNonStudentValid = true;
      if (isParulEmailAssociated && data.applicantCategory != 'PARUL_STUDENT') {
         // For staff/alumni with Parul email, college might be dept/last affiliated.
         // No strict enrollment no. needed here unless specific to their category.
      }

      // Institute name for "OTHERS"
      let othersValid = true;
      if (data.applicantCategory == 'OTHERS') {
        othersValid = data.instituteName is string && data.instituteName.size() > 0;
      }
      
      return commonValid && parulStudentValid && parulNonStudentValid && othersValid;
    }


    function isCreatingOwnValidProfile(userId, data) {
      let isParulEmail = data.email.matches('.*@paruluniversity\\.ac\\.in$');
      
      // Super Admin specific creation rules
      if (data.email == 'pranavrathi07@gmail.com') {
        return isOwner(userId) &&
               data.role == 'ADMIN_FACULTY' &&
               data.isSuperAdmin == true &&
               isMentorPlaceholderFields(data) && // Super admin uses placeholder structure initially
               data.keys().hasAll(['uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'fullName', 'contactNumber', 'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers', 'createdAt', 'updatedAt', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid', 'enrollmentNumber', 'college', 'instituteName']) &&
               data.uid == userId &&
               data.createdAt == request.time &&
               data.updatedAt == request.time &&
               data.isTeamMemberOnly == false &&
               data.associatedIdeaId == null &&
               data.associatedTeamLeaderUid == null;
      }

      // Mentor specific creation rules
      if (isMentorEmail(data.email)) {
         return isOwner(userId) &&
                data.role == 'ADMIN_FACULTY' &&
                data.isSuperAdmin == false &&
                (isMentorPlaceholderFields(data) || isValidIdeaOwnerFields(data, isParulEmail)) && // Mentor can have placeholder or actual idea
                data.keys().hasAll(['uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'fullName', 'contactNumber', 'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers', 'createdAt', 'updatedAt', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid', 'enrollmentNumber', 'college', 'instituteName']) &&
                data.uid == userId &&
                data.createdAt == request.time &&
                data.updatedAt == request.time &&
                data.isTeamMemberOnly == false &&
                data.associatedIdeaId == null &&
                data.associatedTeamLeaderUid == null;
      }
      
      // Team Member specific creation rules
      if (data.isTeamMemberOnly == true) {
        return isOwner(userId) &&
               data.role in ['STUDENT', 'EXTERNAL_USER'] && // Role assigned by system
               data.isSuperAdmin == false &&
               data.fullName is string && data.fullName.size() > 0 &&
               data.contactNumber is string && data.contactNumber.size() >= 10 &&
               // Team members do not have idea fields in their profile
               data.startupTitle == null && data.problemDefinition == null && data.solutionDescription == null && data.uniqueness == null && data.applicantCategory == null && data.currentStage == null && data.teamMembers == null &&
               data.keys().hasAll(['uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'fullName', 'contactNumber', 'createdAt', 'updatedAt', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid', 'enrollmentNumber', 'college', 'instituteName', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'applicantCategory', 'currentStage', 'teamMembers']) &&
               data.uid == userId &&
               data.createdAt == request.time &&
               data.updatedAt == request.time &&
               data.associatedIdeaId is string && data.associatedIdeaId.size() > 0 &&
               data.associatedTeamLeaderUid is string && data.associatedTeamLeaderUid.size() > 0;
      }

      // Regular Idea Owner (Student/External) creation rules
      return isOwner(userId) &&
             data.role in ['STUDENT', 'EXTERNAL_USER'] &&
             data.isSuperAdmin == false &&
             isValidIdeaOwnerFields(data, isParulEmail) &&
             data.keys().hasAll(['uid', 'email', 'displayName', 'photoURL', 'role', 'isSuperAdmin', 'fullName', 'contactNumber', 'applicantCategory', 'currentStage', 'startupTitle', 'problemDefinition', 'solutionDescription', 'uniqueness', 'teamMembers', 'createdAt', 'updatedAt', 'isTeamMemberOnly', 'associatedIdeaId', 'associatedTeamLeaderUid', 'enrollmentNumber', 'college', 'instituteName']) &&
             data.uid == userId &&
             data.createdAt == request.time &&
             data.updatedAt == request.time &&
             data.isTeamMemberOnly == false &&
             data.associatedIdeaId == null &&
             data.associatedTeamLeaderUid == null;
    }

    function isUpdatingOwnValidProfile(userId, requestData, existingData) {
      let immutableFieldsUnchanged = requestData.uid == existingData.uid &&
                                    requestData.email == existingData.email &&
                                    requestData.role == existingData.role &&
                                    requestData.isSuperAdmin == existingData.isSuperAdmin &&
                                    requestData.createdAt == existingData.createdAt &&
                                    requestData.isTeamMemberOnly == existingData.isTeamMemberOnly &&
                                    requestData.associatedIdeaId == existingData.associatedIdeaId &&
                                    requestData.associatedTeamLeaderUid == existingData.associatedTeamLeaderUid;

      let isParulEmail = existingData.email.matches('.*@paruluniversity\\.ac\\.in$');

      if (!immutableFieldsUnchanged) { return false; }
      if (requestData.updatedAt != request.time) { return false; }

      // Super Admin specific update rules
      if (existingData.email == 'pranavrathi07@gmail.com') {
        return isOwner(userId) &&
               isMentorPlaceholderFields(requestData) && // Super admin maintains placeholder structure
               requestData.fullName is string && requestData.fullName.size() > 0 && // Can update name/contact
               requestData.contactNumber is string && requestData.contactNumber.size() >= 10;
      }
      
      // Mentor specific update rules
      if (isMentorEmail(existingData.email)) {
         return isOwner(userId) &&
                (isMentorPlaceholderFields(requestData) || isValidIdeaOwnerFields(requestData, isParulEmail)) && // Mentor can update placeholder or their actual idea
                requestData.fullName is string && requestData.fullName.size() > 0 &&
                requestData.contactNumber is string && requestData.contactNumber.size() >= 10;
      }

      // Team Member specific update rules
      if (existingData.isTeamMemberOnly == true) {
        return isOwner(userId) &&
               requestData.fullName is string && requestData.fullName.size() > 0 &&
               requestData.contactNumber is string && requestData.contactNumber.size() >= 10 &&
               // Team members do not have idea fields in their profile
               requestData.startupTitle == null && requestData.problemDefinition == null && requestData.solutionDescription == null && requestData.uniqueness == null && requestData.applicantCategory == null && requestData.currentStage == null && requestData.teamMembers == null;
      }
      
      // Regular Idea Owner (Student/External) update rules
      return isOwner(userId) &&
             isValidIdeaOwnerFields(requestData, isParulEmail);
    }
    
    function creatorIsNotUsingAdminPlaceholderForIdea(userId) {
      let userProfile = getUserProfileData(userId);
      // Allow idea creation if profile exists and its startupTitle is NOT one of the admin placeholders
      return userProfile != null &&
             userProfile.startupTitle != 'Administrative Account' &&
             userProfile.startupTitle != 'Faculty/Mentor Account';
    }

    function isValidIdeaContent(data) {
      let requiredFields = ['title', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType'];
      let stringFieldsValid = requiredFields.reduce((acc, field) => acc && data[field] is string && data[field].size() > 0, true);
      
      // Check category field (which is applicantType for idea document)
      let categoryValid = data.category is string && data.category.size() > 0 && data.category == data.applicantType;

      return stringFieldsValid &&
             categoryValid &&
             data.teamMembers is string && // Can be empty string
             (data.structuredTeamMembers == null || data.structuredTeamMembers is list) &&
             (data.teamMemberEmails == null || data.teamMemberEmails is list);
    }

    function isValidIdeaSubmissionOnCreateOrResubmit(userId, data, isCreate) {
      let userProfile = getUserProfileData(userId);
      return data.userId == userId &&
             userProfile != null &&
             data.applicantDisplayName == (userProfile.displayName || userProfile.fullName || 'N/A') &&
             data.applicantEmail == (userProfile.email || 'N/A') &&
             isValidIdeaContent(data) && // Use the new function
             data.status == 'SUBMITTED' &&
             (isCreate ? data.submittedAt == request.time : data.submittedAt == resource.data.submittedAt) &&
             data.updatedAt == request.time &&
             data.programPhase == null &&
             data.cohortId == null &&
             (data.phase2Marks == null || data.phase2Marks.size() == 0) &&
             (data.mentor == null || data.mentor == '') &&
             (data.rejectionRemarks == null || data.rejectionRemarks == '') &&
             (data.rejectedByUid == null || data.rejectedByUid == '') &&
              data.rejectedAt == null &&
             (data.nextPhaseDate == null) &&
             (data.nextPhaseStartTime == null || data.nextPhaseStartTime == '') &&
             (data.nextPhaseEndTime == null || data.nextPhaseEndTime == '') &&
             (data.nextPhaseVenue == null || data.nextPhaseVenue == '') &&
             (data.nextPhaseGuidelines == null || data.nextPhaseGuidelines == '') &&
             creatorIsNotUsingAdminPlaceholderForIdea(userId);
    }


    // Firestore Rules
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isCreatingOwnValidProfile(userId, request.resource.data);
      allow update: if (isOwner(userId) && isUpdatingOwnValidProfile(userId, request.resource.data, resource.data)) ||
                       (isUserProfileSuperAdmin() && request.resource.data.updatedAt == request.time); // Super admin can update any profile for role changes etc.
      allow delete: if isUserProfileSuperAdmin() && userId != request.auth.uid && resource.data.email != 'pranavrathi07@gmail.com'; // Super admin can delete others, not self, not primary SA
    }

    match /ideas/{ideaId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() &&
                       request.resource.data.userId == request.auth.uid &&
                       isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, true) &&
                       // Ensures only fields appropriate for a new submission are present and correctly valued.
                       // isValidIdeaSubmissionOnCreateOrResubmit already checks admin fields are null/empty.
                       request.resource.data.keys().hasOnly([
                           'userId', 'applicantDisplayName', 'applicantEmail', 'title', 'category',
                           'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType',
                           'teamMembers', 'structuredTeamMembers', 'teamMemberEmails',
                           'status', 'submittedAt', 'updatedAt',
                           'fileURL', 'fileName', 'studioLocation', // Optional
                           'programPhase', 'cohortId', 'phase2Marks', 'mentor', // Should be null/empty
                           'rejectionRemarks', 'rejectedByUid', 'rejectedAt', // Should be null
                           'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', // Should be null
                           'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines' // Should be null
                       ]);

      allow update: if isSignedIn() && (
        // Owner updating their own idea (e.g. PPT upload, team member management)
        ( isOwner(resource.data.userId) && request.resource.data.updatedAt == request.time &&
          request.resource.data.userId == resource.data.userId && // Cannot change owner
          request.resource.data.submittedAt == resource.data.submittedAt && // Cannot change submission time
          // Allow specific fields to be updated by owner:
          (
            // PPT Upload
            ( request.writeFields.hasAll(['phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt', 'updatedAt']) &&
              request.writeFields.size() == 4 && // Only these 4 fields
              request.resource.data.phase2PptUrl is string && request.resource.data.phase2PptUrl.size() > 0 &&
              request.resource.data.phase2PptFileName is string && request.resource.data.phase2PptFileName.size() > 0 &&
              request.resource.data.phase2PptUploadedAt == request.time
            ) ||
            // Team Member Management (add, update, remove)
            ( request.writeFields.hasAny(['structuredTeamMembers', 'teamMemberEmails']) && // If these are changing
              (request.resource.data.structuredTeamMembers == null || request.resource.data.structuredTeamMembers is list) &&
              (request.resource.data.teamMemberEmails == null || request.resource.data.teamMemberEmails is list)
              // Further validation for team member structure can be complex here, rely on backend for full validation if needed.
              // Ensure other critical fields are not changed by team management.
            )
          )
        ) ||
        // Owner resubmitting an archived idea
        ( isOwner(resource.data.userId) &&
          resource.data.status == 'ARCHIVED_BY_ADMIN' &&
          request.resource.data.status == 'SUBMITTED' &&
          isValidIdeaSubmissionOnCreateOrResubmit(request.auth.uid, request.resource.data, false) &&
          // When resubmitting, user can update content fields. Admin fields are reset by isValidIdeaSubmissionOnCreateOrResubmit
          // Ensuring only fields that are part of user's profile data update or reset are touched
           request.writeFields.hasAll(['title', 'category', 'problem', 'solution', 'uniqueness', 'developmentStage', 'applicantType', 'teamMembers', 'structuredTeamMembers', 'teamMemberEmails', 'status', 'updatedAt', 'programPhase', 'cohortId', 'phase2Marks', 'mentor', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', 'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', 'phase2PptUrl', 'phase2PptFileName', 'phase2PptUploadedAt']) && // List all fields that `createIdeaFromProfile` might write for a resubmit
           // Redundant checks but safe: ensure admin fields are indeed reset
           request.resource.data.programPhase == null &&
           request.resource.data.cohortId == null &&
           (request.resource.data.phase2Marks == null || request.resource.data.phase2Marks.size() == 0)
        ) ||
        // Admin actions
        ( isUserProfileAdmin() && request.resource.data.updatedAt == request.time &&
          request.resource.data.userId == resource.data.userId && // Admin cannot change owner
          request.resource.data.submittedAt == resource.data.submittedAt && // Admin cannot change submission time
          (
            // Admin updating status, phase, remarks, next phase details
            ( request.writeFields.hasAny(['status', 'programPhase', 'rejectionRemarks', 'rejectedByUid', 'rejectedAt', 'nextPhaseDate', 'nextPhaseStartTime', 'nextPhaseEndTime', 'nextPhaseVenue', 'nextPhaseGuidelines', 'cohortId']) &&
              // If status is 'ARCHIVED_BY_ADMIN', ensure specific fields are reset/deleted
              (request.resource.data.status != 'ARCHIVED_BY_ADMIN' || (
                request.resource.data.programPhase == null &&
                request.resource.data.mentor == null && // or field is deleted
                request.resource.data.cohortId == null && // or field is deleted
                request.resource.data.phase2Marks.size() == 0 // Check it's an empty map
                // add other fields that should be reset on archive
              ))
            ) ||
            // Admin assigning/updating mentor (Super Admin only)
            ( request.writeFields.hasAny(['mentor', 'updatedByMentorAssignerUid']) && isUserProfileSuperAdmin() &&
              (request.resource.data.mentor == null || request.resource.data.mentor is string) &&
              (request.resource.data.updatedByMentorAssignerUid == request.auth.uid || request.resource.data.updatedByMentorAssignerUid == null) // Can only be set by current admin
            ) ||
            // Admin submitting Phase 2 marks
            ( request.writeFields.hasAny(['phase2Marks', 'updatedAt']) && // Can be just 'phase2Marks' if updatedAt is the only other field for this op
              request.resource.data.programPhase == 'PHASE_2' &&
              request.resource.data.phase2Marks[request.auth.uid].markedAt == request.time
            )
          )
        )
      );
      allow delete: if false; // Prevent direct deletion; use archive flow.
    }

    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isUserProfileAdmin() && request.resource.data.createdByUid == request.auth.uid && request.resource.data.createdAt == request.time && request.resource.data.updatedAt == request.time;
      allow update: if isUserProfileAdmin() && request.resource.data.updatedAt == request.time;
      allow delete: if isUserProfileAdmin();
    }

    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isUserProfileAdmin() && request.resource.data.createdByUid == request.auth.uid && request.resource.data.createdAt == request.time && request.resource.data.updatedAt == request.time && request.resource.data.ideaIds is list && request.resource.data.ideaIds.size() == 0 && (request.resource.data.schedule == null || request.resource.data.schedule is list);
      allow update: if isUserProfileAdmin() && request.resource.data.updatedAt == request.time; // Allows updating name, dates, batchSize, ideaIds, schedule
      allow delete: if isUserProfileSuperAdmin(); // Only super admin can delete cohorts
    }

    match /systemSettings/{docId} {
      allow read: if isSignedIn();
      allow write: if isUserProfileAdmin() && request.resource.data.updatedAt == request.time && request.resource.data.updatedByUid == request.auth.uid;
    }
    
    match /activityLogs/{logId} {
      allow read: if isUserProfileAdmin(); // Only admins can read activity logs
      allow write: if isSignedIn(); // System/functions can write, or specific rules for user-triggered logs if any.
                                 // For now, assuming backend/trusted environment writes these.
                                 // If client needs to write specific logs, this needs fine-tuning.
                                 // Example: allow create: if request.auth.uid == request.resource.data.actorUid;
    }
  }
}

    