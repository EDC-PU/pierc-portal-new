
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN_FACULTY';
    }

    function isSuperAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    // Get unique keys from both new and old data, then filter to keys where values differ.
    function getChangedKeys(newData, oldData) {
      let allUniqueKeys = newData.keys().toSet().union(oldData.keys().toSet());
      return allUniqueKeys.filter(key => newData[key] != oldData[key]);
    }

    // User Profiles
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if request.auth.uid == userId &&
                       request.resource.data.uid == userId &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       (request.resource.data.email == request.auth.token.email || request.resource.data.email == null) &&
                       // Role specific validations for creation
                       isValidRoleAssignmentOnCreate(request.resource.data, request.auth.token.email);


      allow update: if request.auth.uid == userId && // User can update their own profile
                       request.resource.data.uid == userId && // Cannot change UID
                       request.resource.data.email == resource.data.email && // Email cannot change
                       request.resource.data.createdAt == resource.data.createdAt && // CreatedAt cannot change
                       request.resource.data.updatedAt == request.time &&
                       // Role can only be changed by an admin (handled in specific admin rule if needed, or user cannot change own role)
                       (request.resource.data.role == resource.data.role || isAdmin()) &&
                       // isSuperAdmin can only be changed by a super admin (likely via a callable function or specific admin rule)
                       (request.resource.data.isSuperAdmin == resource.data.isSuperAdmin || isSuperAdmin()) &&
                       // isTeamMemberOnly related fields can only be set initially or by admin actions
                       (request.resource.data.isTeamMemberOnly == resource.data.isTeamMemberOnly || isAdmin()) &&
                       (request.resource.data.associatedIdeaId == resource.data.associatedIdeaId || isAdmin()) &&
                       (request.resource.data.associatedTeamLeaderUid == resource.data.associatedTeamLeaderUid || isAdmin()) &&
                       // Ensure idea fields are only set if not a team member only profile, or by admin
                       ( (request.resource.data.isTeamMemberOnly == true && areIdeaFieldsNull(request.resource.data)) ||
                         (request.resource.data.isTeamMemberOnly == false) ||
                         isAdmin() )
                   || isSuperAdmin(); // Super admin can update any user profile field

      allow delete: if request.auth.uid == userId || isSuperAdmin(); // User can delete own, super admin can delete any. Actual deletion of auth user is via callable func.
    }

    function areIdeaFieldsNull(data) {
        return data.startupTitle == null &&
               data.problemDefinition == null &&
               data.solutionDescription == null &&
               data.uniqueness == null &&
               data.applicantCategory == null &&
               data.currentStage == null &&
               data.teamMembers == null;
    }

    function isValidRoleAssignmentOnCreate(data, requestEmail) {
      let requestedRole = data.role;
      // Default user email
      let isDefaultUserEmail = requestEmail == 'pranavrathi07@gmail.com';
      // Predefined mentor emails list (ensure this list is maintained or use a dynamic check if possible)
      let mentorEmails = [
        'prashant.khanna8747@paruluniversity.ac.in', 'riddhi.bagha29080@paruluniversity.ac.in',
        'nikhil.jumade24167@paruluniversity.ac.in', 'jay.sudani@paruluniversity.ac.in',
        'hardik.kharva2899@paruluniversity.ac.in', 'sonal.sudani23321@paruluniversity.ac.in',
        'panchamkumar.baraiya28771@paruluniversity.ac.in', 'juned.shaikh32161@paruluniversity.ac.in'
      ];
      let isMentorEmail = requestEmail in mentorEmails;

      if (isDefaultUserEmail || isMentorEmail) {
        return requestedRole == 'ADMIN_FACULTY' && data.isSuperAdmin == isDefaultUserEmail;
      }
      // Regular users can only be STUDENT or EXTERNAL_USER
      return (requestedRole == 'STUDENT' || requestedRole == 'EXTERNAL_USER') && data.isSuperAdmin == false;
    }


    // Idea Submissions
    match /ideas/{ideaId} {
      allow read: if isSignedIn();
      allow create: if request.auth.uid == request.resource.data.userId &&
                       isValidIdeaSubmissionOnCreateOrResubmit(request.resource.data, null);
      allow update: if isIdeaUpdateSafe(request, resource);
      allow delete: if isAdmin(); // Only admins can delete idea submissions directly
    }

    function isValidIdeaSubmissionOnCreateOrResubmit(data, oldData) {
      return data.userId != null &&
             data.title != null && data.title.size() > 0 &&
             data.problem != null && data.problem.size() > 0 &&
             data.solution != null && data.solution.size() > 0 &&
             data.uniqueness != null && data.uniqueness.size() > 0 &&
             data.developmentStage != null &&
             data.applicantType != null &&
             data.status != null &&
             // Ensure mandatory initial fields for non-funding phases
             ( (data.programPhase != 'INCUBATED' && data.totalFundingAllocated == null && data.sanction1Amount == null && data.sanction2Amount == null) ||
               (data.programPhase == 'INCUBATED') // For INCUBATED, funding fields might be set
             ) &&
             // Ensure beneficiary fields are null if not INCUBATED, or can be set if INCUBATED
             ( (data.programPhase != 'INCUBATED' && areBeneficiaryFieldsNullOrNotPresent(data)) ||
               (data.programPhase == 'INCUBATED')
             ) &&
             isValidInitialOrResubmittedIdeaState(data, oldData);
    }

    function areBeneficiaryFieldsNullOrNotPresent(data) {
        return (data.beneficiaryName == null || data.beneficiaryName == '') &&
               (data.beneficiaryAccountNo == null || data.beneficiaryAccountNo == '') &&
               (data.beneficiaryBankName == null || data.beneficiaryBankName == '') &&
               (data.beneficiaryIfscCode == null || data.beneficiaryIfscCode == '') &&
               (data.beneficiaryAccountType == null) && // Enum, check for null
               (data.beneficiaryCity == null || data.beneficiaryCity == '') &&
               (data.beneficiaryBranchName == null || data.beneficiaryBranchName == '');
    }


    function isValidInitialOrResubmittedIdeaState(data, oldData) {
      let isNewSubmission = oldData == null;
      if (isNewSubmission) {
        return data.status == 'SUBMITTED' &&
               data.programPhase == null &&
               data.phase2Marks == {} &&
               data.mentor == null &&
               data.cohortId == null &&
               data.rejectionRemarks == null &&
               data.rejectedByUid == null &&
               data.rejectedAt == null &&
               data.phase2PptUrl == null &&
               data.phase2PptFileName == null &&
               data.phase2PptUploadedAt == null &&
               data.isOutlineAIGenerated == false &&
               data.nextPhaseDate == null &&
               data.nextPhaseStartTime == null &&
               data.nextPhaseEndTime == null &&
               data.nextPhaseVenue == null &&
               data.nextPhaseGuidelines == null &&
               data.sanction1Expenses.size() == 0 &&
               data.sanction2Expenses.size() == 0 &&
               data.sanction1AppliedForNext == false &&
               data.sanction1UtilizationStatus == 'NOT_APPLICABLE' &&
               data.sanction2UtilizationStatus == 'NOT_APPLICABLE' &&
               isValidInitialTimestamps(data);
      } else { // Resubmitting an archived idea or general update
        return isValidResubmitTimestamps(data, oldData) && data.updatedAt == request.time;
      }
    }

    function isValidInitialTimestamps(data) {
        return data.createdAt == request.time &&
               data.submittedAt == request.time && // For brand new submission
               data.updatedAt == request.time;
    }
    function isValidResubmitTimestamps(data, oldData) {
        // When resubmitting, original submittedAt and createdAt are preserved
        return data.createdAt == oldData.createdAt &&
               data.submittedAt == oldData.submittedAt;
    }


    function isIdeaUpdateSafe(request, resource) {
      let data = request.resource.data;
      let oldData = resource.data;
      return request.auth.uid == oldData.userId &&
        data.userId == oldData.userId && // User ID cannot change
        data.submittedAt == oldData.submittedAt && // Submission time cannot change
        data.createdAt == oldData.createdAt && // Creation time cannot change
        // Status can only be changed by an admin or if the user is resubmitting an archived idea
        (data.status == oldData.status || isAdmin() || (oldData.status == 'ARCHIVED_BY_ADMIN' && data.status == 'SUBMITTED')) &&
        // Program phase can only be changed by an admin
        (data.programPhase == oldData.programPhase || isAdmin()) &&
        // Cohort ID can only be changed by a super admin
        (data.cohortId == oldData.cohortId || isSuperAdmin()) &&
        // Mentor can only be assigned/unassigned by a super admin
        (data.mentor == oldData.mentor || isSuperAdmin()) &&
        // Phase 2 marks can only be added/updated by admins if phase is PHASE_2
        (isValidPhase2MarksUpdate(data, oldData) || !isUpdatingPhase2Marks(data, oldData)) &&
        // PPT details can be updated by the user if in PHASE_2
        (isPptUpdateAllowed(data, oldData) || !isUpdatingPpt(data, oldData)) &&
        // AI generated status can be updated by the user
        (data.isOutlineAIGenerated == oldData.isOutlineAIGenerated || data.isOutlineAIGenerated == true || data.isOutlineAIGenerated == false) &&
        // Team members can be updated by the user
        (isTeamMembersUpdateAllowed(data, oldData) || !isUpdatingTeamMembers(data, oldData)) &&
        // Beneficiary details can be updated by the user IF the idea is INCUBATED
        (isBeneficiaryUpdateAllowed(data, oldData) || !isUpdatingBeneficiaryFields(data, oldData)) &&
        // Expense details can be updated by the user IF the idea is INCUBATED and relevant sanction disbursed
        (isExpenseUpdateAllowed(data, oldData) || !isUpdatingExpenseFields(data, oldData)) &&
        // Sanction 1 applied for next can be updated by the user
        (isSanction1AppliedForNextUpdateAllowed(data, oldData) || data.sanction1AppliedForNext == oldData.sanction1AppliedForNext) &&
        // Ensure admin-only funding fields are not changed by user
        (areFundingAllocationFieldsUnchanged(data, oldData) || isAdmin()) &&
        (areSanctionDisbursementFieldsUnchanged(data, oldData) || isAdmin()) &&
        (areSanctionUtilizationReviewFieldsUnchanged(data, oldData) || isAdmin()) &&
        // Core idea content fields should only be updatable if resubmitting from ARCHIVED_BY_ADMIN or by admin
        (areCoreIdeaFieldsUnchangedOrResubmitting(data, oldData) || isAdmin()) &&
        data.updatedAt == request.time;
    }

    function areCoreIdeaFieldsUnchangedOrResubmitting(data, oldData) {
      // If not resubmitting, core fields must be unchanged
      let coreFieldsUnchanged = data.title == oldData.title &&
                                data.problem == oldData.problem &&
                                data.solution == oldData.solution &&
                                data.uniqueness == oldData.uniqueness &&
                                data.developmentStage == oldData.developmentStage &&
                                data.applicantType == oldData.applicantType &&
                                data.fileURL == oldData.fileURL &&
                                data.fileName == oldData.fileName &&
                                data.studioLocation == oldData.studioLocation;

      // If resubmitting an archived idea, these fields *can* change
      let isResubmittingArchived = oldData.status == 'ARCHIVED_BY_ADMIN' && data.status == 'SUBMITTED';

      return coreFieldsUnchanged || isResubmittingArchived;
    }

    function isUpdatingPhase2Marks(data, oldData) {
      // Check if any key within phase2Marks is different or added/removed
      let oldKeys = oldData.phase2Marks.keys().toSet();
      let newKeys = data.phase2Marks.keys().toSet();
      if (!oldKeys.equals(newKeys)) return true; // Keyset changed (admin added/removed mark)
      return newKeys.some(key => data.phase2Marks[key].mark != oldData.phase2Marks[key].mark); // Mark value changed
    }

    function isValidPhase2MarksUpdate(data, oldData) {
      // Only admins can update marks, and only for their own UID or if super admin
      // And idea must be in PHASE_2
      if (data.programPhase != 'PHASE_2' && oldData.programPhase != 'PHASE_2') return false; // Marks only for Phase 2
      if (!isAdmin()) return false; // Must be an admin

      let changedAdminUids = getChangedKeys(data.phase2Marks, oldData.phase2Marks);
      if (changedAdminUids.size() == 0) return true; // No marks changed

      // If marks changed, each changed entry must be for the current admin's UID
      return changedAdminUids.every(uid => uid == request.auth.uid || isSuperAdmin());
    }

    function isUpdatingPpt(data, oldData) {
      return data.phase2PptUrl != oldData.phase2PptUrl ||
             data.phase2PptFileName != oldData.phase2PptFileName ||
             data.phase2PptUploadedAt != oldData.phase2PptUploadedAt;
    }

    function isPptUpdateAllowed(data, oldData) {
      // User can upload PPT if idea is in PHASE_2
      return (data.programPhase == 'PHASE_2' || oldData.programPhase == 'PHASE_2') &&
             request.auth.uid == oldData.userId;
    }

    function isUpdatingTeamMembers(data, oldData) {
        // This is a simplified check. A deep check of array elements is complex in rules.
        // Rely on callable functions for precise array manipulation logic if needed.
        // For basic rule, check if the 'teamMembers' string changed or 'structuredTeamMembers' top-level changed
        return data.teamMembers != oldData.teamMembers ||
               data.structuredTeamMembers != oldData.structuredTeamMembers || // This might be too broad if only order changes
               data.teamMemberEmails != oldData.teamMemberEmails;
    }

    function isTeamMembersUpdateAllowed(data, oldData) {
        // User can update team members if they are the owner
        return request.auth.uid == oldData.userId;
    }

    function isUpdatingBeneficiaryFields(data, oldData) {
      return data.beneficiaryName != oldData.beneficiaryName ||
             data.beneficiaryAccountNo != oldData.beneficiaryAccountNo ||
             data.beneficiaryBankName != oldData.beneficiaryBankName ||
             data.beneficiaryIfscCode != oldData.beneficiaryIfscCode ||
             data.beneficiaryAccountType != oldData.beneficiaryAccountType ||
             data.beneficiaryCity != oldData.beneficiaryCity ||
             data.beneficiaryBranchName != oldData.beneficiaryBranchName;
    }

    function isBeneficiaryUpdateAllowed(data, oldData) {
      return oldData.programPhase == 'INCUBATED' &&
             request.auth.uid == oldData.userId && // Owner can update
             isUpdatingOnlyAllowedBeneficiaryFields(data, oldData);
    }

    function isUpdatingOnlyAllowedBeneficiaryFields(data, oldData) {
      let changedKeys = getChangedKeys(data, oldData);
      if (changedKeys.size() == 0) {
        return true;
      }
      // For each key that changed, it must be one of the allowed ones.
      return changedKeys.every(key =>
        key == 'beneficiaryName' ||
        key == 'beneficiaryAccountNo' ||
        key == 'beneficiaryBankName' ||
        key == 'beneficiaryIfscCode' ||
        key == 'beneficiaryAccountType' ||
        key == 'beneficiaryCity' ||
        key == 'beneficiaryBranchName' ||
        key == 'updatedAt' // Always allowed if other conditions pass
      );
    }

    function isUpdatingExpenseFields(data, oldData) {
        return data.sanction1Expenses != oldData.sanction1Expenses ||
               data.sanction2Expenses != oldData.sanction2Expenses;
    }

    function isExpenseUpdateAllowed(data, oldData) {
        // User can update expenses if they are the owner and idea is incubated
        // And specific sanction has been disbursed
        let isOwnerAndIncubated = request.auth.uid == oldData.userId && oldData.programPhase == 'INCUBATED';
        let s1UpdateAllowed = isOwnerAndIncubated && oldData.sanction1DisbursedAt != null && data.sanction1Expenses != oldData.sanction1Expenses;
        let s2UpdateAllowed = isOwnerAndIncubated && oldData.sanction2DisbursedAt != null && data.sanction2Expenses != oldData.sanction2Expenses;

        // If only S1 expenses changed, it's allowed if S1 conditions met.
        if (data.sanction1Expenses != oldData.sanction1Expenses && data.sanction2Expenses == oldData.sanction2Expenses) {
            return s1UpdateAllowed;
        }
        // If only S2 expenses changed, it's allowed if S2 conditions met.
        if (data.sanction2Expenses != oldData.sanction2Expenses && data.sanction1Expenses == oldData.sanction1Expenses) {
            return s2UpdateAllowed;
        }
        // If both changed (or potentially other fields), both must be allowed if they changed
        if (data.sanction1Expenses != oldData.sanction1Expenses && data.sanction2Expenses != oldData.sanction2Expenses) {
             return s1UpdateAllowed && s2UpdateAllowed;
        }
        // If neither changed, this specific check passes (delegates to other rules)
        return true;
    }

    function isSanction1AppliedForNextUpdateAllowed(data, oldData) {
        // User can update this if they are the owner, S1 is approved, and S2 not yet disbursed
        return request.auth.uid == oldData.userId &&
               oldData.sanction1UtilizationStatus == 'APPROVED' &&
               oldData.sanction2DisbursedAt == null &&
               data.sanction1AppliedForNext == true && // Can only set to true
               oldData.sanction1AppliedForNext == false; // Only if previously false
    }

    // --- Admin Only Field Checks ---
    function areFundingAllocationFieldsUnchanged(data, oldData) {
        return data.totalFundingAllocated == oldData.totalFundingAllocated &&
               data.sanction1Amount == oldData.sanction1Amount &&
               data.sanction2Amount == oldData.sanction2Amount;
    }
    function areSanctionDisbursementFieldsUnchanged(data, oldData) {
        return data.sanction1DisbursedAt == oldData.sanction1DisbursedAt &&
               data.sanction2DisbursedAt == oldData.sanction2DisbursedAt;
    }
    function areSanctionUtilizationReviewFieldsUnchanged(data, oldData) {
        return data.sanction1UtilizationStatus == oldData.sanction1UtilizationStatus &&
               data.sanction1UtilizationRemarks == oldData.sanction1UtilizationRemarks &&
               data.sanction1UtilizationReviewedBy == oldData.sanction1UtilizationReviewedBy &&
               data.sanction1UtilizationReviewedAt == oldData.sanction1UtilizationReviewedAt &&
               data.sanction2UtilizationStatus == oldData.sanction2UtilizationStatus &&
               data.sanction2UtilizationRemarks == oldData.sanction2UtilizationRemarks &&
               data.sanction2UtilizationReviewedBy == oldData.sanction2UtilizationReviewedBy &&
               data.sanction2UtilizationReviewedAt == oldData.sanction2UtilizationReviewedAt;
    }


    // Announcements
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isAdmin() && request.resource.data.createdByUid == request.auth.uid;
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Cohorts
    match /cohorts/{cohortId} {
      allow read: if isSignedIn();
      allow create: if isSuperAdmin() && request.resource.data.createdByUid == request.auth.uid;
      allow update: if isSuperAdmin(); // Only super admins can update cohort details or schedule
      allow delete: if isSuperAdmin() && resource.data.ideaIds.size() == 0; // Only if no ideas assigned
    }

    // System Settings
    match /systemSettings/{docId} {
      allow read: if isSignedIn();
      // Only super admins can write to system settings
      allow write: if isSuperAdmin() && request.resource.data.updatedByUid == request.auth.uid;
    }

    // Activity Logs
    match /activityLogs/{logId} {
      allow read: if isAdmin(); // Only admins can read activity logs
      allow create: if isSignedIn(); // System/User can create logs
      allow update, delete: if false; // Logs are immutable
    }
  }
}

